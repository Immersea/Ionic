import{bm as t,c1 as e,c2 as i}from"./p-9424d4f6.js";import"./p-cbe60c68.js";import"./p-c7ee7cfe.js";import"./p-694b8ade.js";import"./p-1af05547.js";import"./p-e9c4f463.js";import"./p-5d4a8e1f.js";import"./p-3647f076.js";import"./p-9c77ce6f.js";import"./p-ae1763fb.js";import"./p-c5936999.js";import"./p-6879854f.js";function r(t){const e=t.split("/").filter((t=>t!=="."));const i=[];e.forEach((t=>{if(t===".."&&i.length>0&&i[i.length-1]!==".."){i.pop()}else{i.push(t)}}));return i.join("/")}function o(t,e){t=r(t);e=r(e);const i=t.split("/");const o=e.split("/");return t!==e&&i.every(((t,e)=>t===o[e]))}class s extends t{constructor(){super(...arguments);this.DB_VERSION=1;this.DB_NAME="Disc";this._writeCmds=["add","put","delete"];this.downloadFile=async t=>{var i,r;const o=e(t,t.webFetchExtra);const s=await fetch(t.url,o);let n;if(!t.progress)n=await s.blob();else if(!(s===null||s===void 0?void 0:s.body))n=new Blob;else{const e=s.body.getReader();let i=0;const r=[];const o=s.headers.get("content-type");const a=parseInt(s.headers.get("content-length")||"0",10);while(true){const{done:o,value:s}=await e.read();if(o)break;r.push(s);i+=(s===null||s===void 0?void 0:s.length)||0;const n={url:t.url,bytes:i,contentLength:a};this.notifyListeners("progress",n)}const c=new Uint8Array(i);let d=0;for(const t of r){if(typeof t==="undefined")continue;c.set(t,d);d+=t.length}n=new Blob([c.buffer],{type:o||undefined})}const a=await this.writeFile({path:t.path,directory:(i=t.directory)!==null&&i!==void 0?i:undefined,recursive:(r=t.recursive)!==null&&r!==void 0?r:false,data:n});return{path:a.uri,blob:n}}}async initDb(){if(this._db!==undefined){return this._db}if(!("indexedDB"in window)){throw this.unavailable("This browser doesn't support IndexedDB")}return new Promise(((t,e)=>{const i=indexedDB.open(this.DB_NAME,this.DB_VERSION);i.onupgradeneeded=s.doUpgrade;i.onsuccess=()=>{this._db=i.result;t(i.result)};i.onerror=()=>e(i.error);i.onblocked=()=>{console.warn("db blocked")}}))}static doUpgrade(t){const e=t.target;const i=e.result;switch(t.oldVersion){case 0:case 1:default:{if(i.objectStoreNames.contains("FileStorage")){i.deleteObjectStore("FileStorage")}const t=i.createObjectStore("FileStorage",{keyPath:"path"});t.createIndex("by_folder","folder")}}}async dbRequest(t,e){const i=this._writeCmds.indexOf(t)!==-1?"readwrite":"readonly";return this.initDb().then((r=>new Promise(((o,s)=>{const n=r.transaction(["FileStorage"],i);const a=n.objectStore("FileStorage");const c=a[t](...e);c.onsuccess=()=>o(c.result);c.onerror=()=>s(c.error)}))))}async dbIndexRequest(t,e,i){const r=this._writeCmds.indexOf(e)!==-1?"readwrite":"readonly";return this.initDb().then((o=>new Promise(((s,n)=>{const a=o.transaction(["FileStorage"],r);const c=a.objectStore("FileStorage");const d=c.index(t);const h=d[e](...i);h.onsuccess=()=>s(h.result);h.onerror=()=>n(h.error)}))))}getPath(t,e){const i=e!==undefined?e.replace(/^[/]+|[/]+$/g,""):"";let r="";if(t!==undefined)r+="/"+t;if(e!=="")r+="/"+i;return r}async clear(){const t=await this.initDb();const e=t.transaction(["FileStorage"],"readwrite");const i=e.objectStore("FileStorage");i.clear()}async readFile(t){const e=this.getPath(t.directory,t.path);const i=await this.dbRequest("get",[e]);if(i===undefined)throw Error("File does not exist.");return{data:i.content?i.content:""}}async writeFile(t){const e=this.getPath(t.directory,t.path);let i=t.data;const r=t.encoding;const o=t.recursive;const s=await this.dbRequest("get",[e]);if(s&&s.type==="directory")throw Error("The supplied path is a directory.");const n=e.substr(0,e.lastIndexOf("/"));const a=await this.dbRequest("get",[n]);if(a===undefined){const e=n.indexOf("/",1);if(e!==-1){const i=n.substr(e);await this.mkdir({path:i,directory:t.directory,recursive:o})}}if(!r&&!(i instanceof Blob)){i=i.indexOf(",")>=0?i.split(",")[1]:i;if(!this.isBase64String(i))throw Error("The supplied data is not valid base64 content.")}const c=Date.now();const d={path:e,folder:n,type:"file",size:i instanceof Blob?i.size:i.length,ctime:c,mtime:c,content:i};await this.dbRequest("put",[d]);return{uri:d.path}}async appendFile(t){const e=this.getPath(t.directory,t.path);let i=t.data;const r=t.encoding;const o=e.substr(0,e.lastIndexOf("/"));const s=Date.now();let n=s;const a=await this.dbRequest("get",[e]);if(a&&a.type==="directory")throw Error("The supplied path is a directory.");const c=await this.dbRequest("get",[o]);if(c===undefined){const e=o.indexOf("/",1);if(e!==-1){const i=o.substr(e);await this.mkdir({path:i,directory:t.directory,recursive:true})}}if(!r&&!this.isBase64String(i))throw Error("The supplied data is not valid base64 content.");if(a!==undefined){if(a.content instanceof Blob){throw Error("The occupied entry contains a Blob object which cannot be appended to.")}if(a.content!==undefined&&!r){i=btoa(atob(a.content)+atob(i))}else{i=a.content+i}n=a.ctime}const d={path:e,folder:o,type:"file",size:i.length,ctime:n,mtime:s,content:i};await this.dbRequest("put",[d])}async deleteFile(t){const e=this.getPath(t.directory,t.path);const i=await this.dbRequest("get",[e]);if(i===undefined)throw Error("File does not exist.");const r=await this.dbIndexRequest("by_folder","getAllKeys",[IDBKeyRange.only(e)]);if(r.length!==0)throw Error("Folder is not empty.");await this.dbRequest("delete",[e])}async mkdir(t){const e=this.getPath(t.directory,t.path);const i=t.recursive;const r=e.substr(0,e.lastIndexOf("/"));const o=(e.match(/\//g)||[]).length;const s=await this.dbRequest("get",[r]);const n=await this.dbRequest("get",[e]);if(o===1)throw Error("Cannot create Root directory");if(n!==undefined)throw Error("Current directory does already exist.");if(!i&&o!==2&&s===undefined)throw Error("Parent directory must exist");if(i&&o!==2&&s===undefined){const e=r.substr(r.indexOf("/",1));await this.mkdir({path:e,directory:t.directory,recursive:i})}const a=Date.now();const c={path:e,folder:r,type:"directory",size:0,ctime:a,mtime:a};await this.dbRequest("put",[c])}async rmdir(t){const{path:e,directory:i,recursive:r}=t;const o=this.getPath(i,e);const s=await this.dbRequest("get",[o]);if(s===undefined)throw Error("Folder does not exist.");if(s.type!=="directory")throw Error("Requested path is not a directory");const n=await this.readdir({path:e,directory:i});if(n.files.length!==0&&!r)throw Error("Folder is not empty");for(const t of n.files){const o=`${e}/${t.name}`;const s=await this.stat({path:o,directory:i});if(s.type==="file"){await this.deleteFile({path:o,directory:i})}else{await this.rmdir({path:o,directory:i,recursive:r})}}await this.dbRequest("delete",[o])}async readdir(t){const e=this.getPath(t.directory,t.path);const i=await this.dbRequest("get",[e]);if(t.path!==""&&i===undefined)throw Error("Folder does not exist.");const r=await this.dbIndexRequest("by_folder","getAllKeys",[IDBKeyRange.only(e)]);const o=await Promise.all(r.map((async t=>{let i=await this.dbRequest("get",[t]);if(i===undefined){i=await this.dbRequest("get",[t+"/"])}return{name:t.substring(e.length+1),type:i.type,size:i.size,ctime:i.ctime,mtime:i.mtime,uri:i.path}})));return{files:o}}async getUri(t){const e=this.getPath(t.directory,t.path);let i=await this.dbRequest("get",[e]);if(i===undefined){i=await this.dbRequest("get",[e+"/"])}return{uri:(i===null||i===void 0?void 0:i.path)||e}}async stat(t){const e=this.getPath(t.directory,t.path);let i=await this.dbRequest("get",[e]);if(i===undefined){i=await this.dbRequest("get",[e+"/"])}if(i===undefined)throw Error("Entry does not exist.");return{type:i.type,size:i.size,ctime:i.ctime,mtime:i.mtime,uri:i.path}}async rename(t){await this._copy(t,true);return}async copy(t){return this._copy(t,false)}async requestPermissions(){return{publicStorage:"granted"}}async checkPermissions(){return{publicStorage:"granted"}}async _copy(t,e=false){let{toDirectory:r}=t;const{to:s,from:n,directory:a}=t;if(!s||!n){throw Error("Both to and from must be provided")}if(!r){r=a}const c=this.getPath(a,n);const d=this.getPath(r,s);if(c===d){return{uri:d}}if(o(c,d)){throw Error("To path cannot contain the from path")}let h;try{h=await this.stat({path:s,directory:r})}catch(t){const e=s.split("/");e.pop();const i=e.join("/");if(e.length>0){const t=await this.stat({path:i,directory:r});if(t.type!=="directory"){throw new Error("Parent directory of the to path is a file")}}}if(h&&h.type==="directory"){throw new Error("Cannot overwrite a directory with a file")}const f=await this.stat({path:n,directory:a});const l=async(t,e,i)=>{const o=this.getPath(r,t);const s=await this.dbRequest("get",[o]);s.ctime=e;s.mtime=i;await this.dbRequest("put",[s])};const u=f.ctime?f.ctime:Date.now();switch(f.type){case"file":{const t=await this.readFile({path:n,directory:a});if(e){await this.deleteFile({path:n,directory:a})}let o;if(!(t.data instanceof Blob)&&!this.isBase64String(t.data)){o=i.UTF8}const c=await this.writeFile({path:s,directory:r,data:t.data,encoding:o});if(e){await l(s,u,f.mtime)}return c}case"directory":{if(h){throw Error("Cannot move a directory over an existing object")}try{await this.mkdir({path:s,directory:r,recursive:false});if(e){await l(s,u,f.mtime)}}catch(t){}const t=(await this.readdir({path:n,directory:a})).files;for(const i of t){await this._copy({from:`${n}/${i.name}`,to:`${s}/${i.name}`,directory:a,toDirectory:r},e)}if(e){await this.rmdir({path:n,directory:a})}}}return{uri:d}}isBase64String(t){try{return btoa(atob(t))==t}catch(t){return false}}}s._debug=true;export{s as FilesystemWeb};