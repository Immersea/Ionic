{"version":3,"names":["appHeaderSegmentToolbarCss","AppHeaderSegmentToolbarStyle0","AppHeaderSegmentToolbar","setSwiper","this","swiper","on","ev","slideChanged","slideTo","segment","update","updateView","componentWillLoad","titles","forEach","title","segmentTitles","tag","TranslationService","getTransl","text","updateSwiper","activeIndex","segmentChanged","detail","value","updateAutoHeight","updateSize","renderToolbar","h","mode","color","scrollable","onIonChange","map","index","disabled","layout","slotIcon","icon","name","undefined","badge","noToolbar","class","render","Host","key","noHeader","badgeIosCss","IonBadgeIosStyle0","badgeMdCss","IonBadgeMdStyle0","Badge","constructor","hostRef","getIonMode","createColorClasses","segmentIosCss","IonSegmentIosStyle0","segmentMdCss","IonSegmentMdStyle0","Segment","onClick","current","target","previous","checked","tagName","emitValueChange","swipeGesture","checkButton","setCheckedClasses","onSlottedItemsChange","valueChanged","getSegmentButton","selector","_a","_b","buttons","getButtons","filter","button","currIndex","findIndex","document","activeElement","length","activated","selectOnFocus","colorChanged","oldValue","emitStyle","swipeGestureChanged","gestureChanged","ionSelect","emit","scrollActiveButtonIntoView","disabledChanged","gesture","enable","connectedCallback","componentDidLoad","raf","import","createGesture","el","gestureName","gesturePriority","threshold","passive","onStart","onMove","onEnd","valueBeforeGesture","activate","setNextIndex","setActivated","event","stopImmediatePropagation","ionChange","Array","from","querySelectorAll","find","classList","add","remove","clicked","getIndicator","root","shadowRoot","querySelector","previousIndicator","currentIndicator","previousClientRect","getBoundingClientRect","currentClientRect","widthDelta","width","xPosition","left","transform","writeTask","style","setProperty","next","smoothScroll","activeButton","scrollContainerBox","activeButtonBox","activeButtonLeft","x","centeredX","scrollBy","top","behavior","isEnd","rtl","isRTL","nextIndex","rect","currentX","previousY","height","getRootNode","nextEl","elementFromPoint","decreaseIndex","increaseIndex","newIndex","ionStyle","onKeyDown","keyDownSelectsButton","preventDefault","setFocus","role","hostContext","onSlotchange","segmentButtonIosCss","IonSegmentButtonIosStyle0","segmentButtonMdCss","IonSegmentButtonMdStyle0","ids","SegmentButton","segmentEl","inheritedAttributes","updateStyle","forceUpdate","updateState","type","closest","addEventListener","disconnectedCallback","removeEventListener","Object","assign","inheritAttributes","hasLabel","hasIcon","nativeEl","focus","hasSegmentColor","ref","part"],"sources":["src/components/common/app/common/app-header-segment-toolbar/app-header-segment-toolbar.scss?tag=app-header-segment-toolbar","src/components/common/app/common/app-header-segment-toolbar/app-header-segment-toolbar.tsx","node_modules/@ionic/core/dist/collection/components/badge/badge.ios.css?tag=ion-badge&mode=ios&encapsulation=shadow","node_modules/@ionic/core/dist/collection/components/badge/badge.md.css?tag=ion-badge&mode=md&encapsulation=shadow","node_modules/@ionic/core/dist/collection/components/badge/badge.js","node_modules/@ionic/core/dist/collection/components/segment/segment.ios.css?tag=ion-segment&mode=ios&encapsulation=shadow","node_modules/@ionic/core/dist/collection/components/segment/segment.md.css?tag=ion-segment&mode=md&encapsulation=shadow","node_modules/@ionic/core/dist/collection/components/segment/segment.js","node_modules/@ionic/core/dist/collection/components/segment-button/segment-button.ios.css?tag=ion-segment-button&mode=ios&encapsulation=shadow","node_modules/@ionic/core/dist/collection/components/segment-button/segment-button.md.css?tag=ion-segment-button&mode=md&encapsulation=shadow","node_modules/@ionic/core/dist/collection/components/segment-button/segment-button.js"],"sourcesContent":["app-header-segment-toolbar {\n}\n","import {Component, h, Prop, Host, State, Element, Watch} from \"@stencil/core\";\nimport {TranslationService} from \"../../../../../services/common/translations\";\n\n@Component({\n  tag: \"app-header-segment-toolbar\",\n  styleUrl: \"app-header-segment-toolbar.scss\",\n})\nexport class AppHeaderSegmentToolbar {\n  @Element() el: HTMLElement;\n  @Prop() color: string;\n  @Prop() noHeader = false;\n  @Prop() noToolbar = false;\n  @State() segmentTitles: any = {};\n  @State() updateView = true;\n  @Prop({mutable: true}) segment: number = 0;\n  @Prop({mutable: true}) swiper: any;\n  @Prop() mode: \"ios\" | \"md\" = \"md\";\n  @Prop({mutable: true}) titles: {\n    tag: string;\n    text?: string;\n    appendix?: string;\n    disabled?: boolean;\n    icon?: string;\n    slotIcon?: string;\n    badge?: number;\n  }[];\n  @Prop({mutable: true}) updateBadge = true;\n\n  @Watch(\"swiper\")\n  setSwiper() {\n    if (this.swiper) {\n      this.swiper.on(\"slideChange\", (ev) => this.slideChanged(ev));\n      this.swiper.slideTo(this.segment);\n    }\n  }\n\n  @Watch(\"updateBadge\")\n  update() {\n    this.updateView = !this.updateView;\n  }\n\n  componentWillLoad() {\n    this.titles.forEach((title) => {\n      this.segmentTitles[title.tag] = TranslationService.getTransl(\n        title.tag,\n        title.text\n      );\n    });\n  }\n\n  async slideChanged(swiper) {\n    this.updateSwiper();\n    this.segment = swiper.activeIndex;\n  }\n\n  segmentChanged(ev) {\n    if (ev.detail.value >= 0) {\n      this.segment = ev.detail.value;\n      if (this.swiper) {\n        this.updateSwiper();\n        this.swiper.slideTo(this.segment);\n      }\n    }\n  }\n\n  updateSwiper() {\n    if (this.swiper) {\n      this.swiper.update();\n      this.swiper.updateAutoHeight();\n      this.swiper.updateSize();\n    }\n  }\n\n  renderToolbar() {\n    const segment = (\n      <ion-segment\n        mode={this.mode}\n        color={this.color}\n        scrollable\n        onIonChange={(ev) => this.segmentChanged(ev)}\n        value={this.segment}\n      >\n        {this.titles.map((title, index) => (\n          <ion-segment-button\n            value={index}\n            disabled={title.disabled ? true : false}\n            layout={\n              title.slotIcon && title.slotIcon == \"end\"\n                ? \"icon-end\"\n                : \"icon-start\"\n            }\n          >\n            <ion-label>{this.segmentTitles[title.tag]}</ion-label>\n            {title.icon ? <ion-icon name={title.icon}></ion-icon> : undefined}\n            {title.badge > 0 ? (\n              <ion-badge color={this.color}>{title.badge}</ion-badge>\n            ) : undefined}\n          </ion-segment-button>\n        ))}\n      </ion-segment>\n    );\n    return this.noToolbar ? (\n      segment\n    ) : (\n      <ion-toolbar class=\"no-safe-padding\">{segment}</ion-toolbar>\n    );\n  }\n\n  render() {\n    return (\n      <Host>\n        {!this.noHeader && !this.noToolbar ? (\n          <ion-header>{this.renderToolbar()}</ion-header>\n        ) : (\n          this.renderToolbar()\n        )}\n      </Host>\n    );\n  }\n}\n","/**\n * Convert a font size to a dynamic font size.\n * Fonts that participate in Dynamic Type should use\n * dynamic font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param unit (optional) - The unit to convert to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a maximum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a minimum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * maximum and minimum font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * A heuristic that applies CSS to tablet\n * viewports.\n *\n * Usage:\n * @include tablet-viewport() {\n *   :host {\n *     background-color: green;\n *   }\n * }\n */\n/**\n * A heuristic that applies CSS to mobile\n * viewports (i.e. phones, not tablets).\n *\n * Usage:\n * @include mobile-viewport() {\n *   :host {\n *     background-color: blue;\n *   }\n * }\n */\n:host {\n  /**\n   * @prop --background: Background of the badge\n   * @prop --color: Text color of the badge\n   *\n   * @prop --padding-top: Top padding of the badge\n   * @prop --padding-end: Right padding if direction is left-to-right, and left padding if direction is right-to-left of the badge\n   * @prop --padding-bottom: Bottom padding of the badge\n   * @prop --padding-start: Left padding if direction is left-to-right, and right padding if direction is right-to-left of the badge\n   */\n  --background: var(--ion-color-primary, #0054e9);\n  --color: var(--ion-color-primary-contrast, #fff);\n  --padding-top: 3px;\n  --padding-end: 8px;\n  --padding-bottom: 3px;\n  --padding-start: 8px;\n  -moz-osx-font-smoothing: grayscale;\n  -webkit-font-smoothing: antialiased;\n  -webkit-padding-start: var(--padding-start);\n  padding-inline-start: var(--padding-start);\n  -webkit-padding-end: var(--padding-end);\n  padding-inline-end: var(--padding-end);\n  padding-top: var(--padding-top);\n  padding-bottom: var(--padding-bottom);\n  display: inline-block;\n  min-width: 10px;\n  background: var(--background);\n  color: var(--color);\n  font-family: var(--ion-font-family, inherit);\n  font-size: 0.8125rem;\n  font-weight: bold;\n  line-height: 1;\n  text-align: center;\n  white-space: nowrap;\n  contain: content;\n  vertical-align: baseline;\n}\n\n:host(.ion-color) {\n  background: var(--ion-color-base);\n  color: var(--ion-color-contrast);\n}\n\n:host(:empty) {\n  display: none;\n}\n\n/**\n * Convert a font size to a dynamic font size.\n * Fonts that participate in Dynamic Type should use\n * dynamic font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param unit (optional) - The unit to convert to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a maximum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a minimum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * maximum and minimum font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * A heuristic that applies CSS to tablet\n * viewports.\n *\n * Usage:\n * @include tablet-viewport() {\n *   :host {\n *     background-color: green;\n *   }\n * }\n */\n/**\n * A heuristic that applies CSS to mobile\n * viewports (i.e. phones, not tablets).\n *\n * Usage:\n * @include mobile-viewport() {\n *   :host {\n *     background-color: blue;\n *   }\n * }\n */\n:host {\n  border-radius: 10px;\n  /**\n   * \"-apple-system-body\" on iOS never goes smaller than\n   * 14px according to https://developer.apple.com/design/human-interface-guidelines/typography#Specifications.\n   * However, we still keep the max() usage here for consistency\n   * with other components and in case \"-apple-system-body\" does\n   * go smaller than 14px in the future.\n   */\n  font-size: max(13px, 0.8125rem);\n}","/**\n * Convert a font size to a dynamic font size.\n * Fonts that participate in Dynamic Type should use\n * dynamic font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param unit (optional) - The unit to convert to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a maximum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a minimum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * maximum and minimum font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * A heuristic that applies CSS to tablet\n * viewports.\n *\n * Usage:\n * @include tablet-viewport() {\n *   :host {\n *     background-color: green;\n *   }\n * }\n */\n/**\n * A heuristic that applies CSS to mobile\n * viewports (i.e. phones, not tablets).\n *\n * Usage:\n * @include mobile-viewport() {\n *   :host {\n *     background-color: blue;\n *   }\n * }\n */\n:host {\n  /**\n   * @prop --background: Background of the badge\n   * @prop --color: Text color of the badge\n   *\n   * @prop --padding-top: Top padding of the badge\n   * @prop --padding-end: Right padding if direction is left-to-right, and left padding if direction is right-to-left of the badge\n   * @prop --padding-bottom: Bottom padding of the badge\n   * @prop --padding-start: Left padding if direction is left-to-right, and right padding if direction is right-to-left of the badge\n   */\n  --background: var(--ion-color-primary, #0054e9);\n  --color: var(--ion-color-primary-contrast, #fff);\n  --padding-top: 3px;\n  --padding-end: 8px;\n  --padding-bottom: 3px;\n  --padding-start: 8px;\n  -moz-osx-font-smoothing: grayscale;\n  -webkit-font-smoothing: antialiased;\n  -webkit-padding-start: var(--padding-start);\n  padding-inline-start: var(--padding-start);\n  -webkit-padding-end: var(--padding-end);\n  padding-inline-end: var(--padding-end);\n  padding-top: var(--padding-top);\n  padding-bottom: var(--padding-bottom);\n  display: inline-block;\n  min-width: 10px;\n  background: var(--background);\n  color: var(--color);\n  font-family: var(--ion-font-family, inherit);\n  font-size: 0.8125rem;\n  font-weight: bold;\n  line-height: 1;\n  text-align: center;\n  white-space: nowrap;\n  contain: content;\n  vertical-align: baseline;\n}\n\n:host(.ion-color) {\n  background: var(--ion-color-base);\n  color: var(--ion-color-contrast);\n}\n\n:host(:empty) {\n  display: none;\n}\n\n/**\n * Convert a font size to a dynamic font size.\n * Fonts that participate in Dynamic Type should use\n * dynamic font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param unit (optional) - The unit to convert to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a maximum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a minimum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * maximum and minimum font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * A heuristic that applies CSS to tablet\n * viewports.\n *\n * Usage:\n * @include tablet-viewport() {\n *   :host {\n *     background-color: green;\n *   }\n * }\n */\n/**\n * A heuristic that applies CSS to mobile\n * viewports (i.e. phones, not tablets).\n *\n * Usage:\n * @include mobile-viewport() {\n *   :host {\n *     background-color: blue;\n *   }\n * }\n */\n:host {\n  --padding-top: 3px;\n  --padding-end: 4px;\n  --padding-bottom: 4px;\n  --padding-start: 4px;\n  border-radius: 4px;\n}","/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { Host, h } from \"@stencil/core\";\nimport { createColorClasses } from \"../../utils/theme\";\nimport { getIonMode } from \"../../global/ionic-global\";\n/**\n * @virtualProp {\"ios\" | \"md\"} mode - The mode determines which platform styles to use.\n */\nexport class Badge {\n    constructor() {\n        this.color = undefined;\n    }\n    render() {\n        const mode = getIonMode(this);\n        return (h(Host, { key: '1253618692342bcf9487188402dc3d49ae0de480', class: createColorClasses(this.color, {\n                [mode]: true,\n            }) }, h(\"slot\", { key: '71d65e203965ea37b94504a8a0a96beb52d4e356' })));\n    }\n    static get is() { return \"ion-badge\"; }\n    static get encapsulation() { return \"shadow\"; }\n    static get originalStyleUrls() {\n        return {\n            \"ios\": [\"badge.ios.scss\"],\n            \"md\": [\"badge.md.scss\"]\n        };\n    }\n    static get styleUrls() {\n        return {\n            \"ios\": [\"badge.ios.css\"],\n            \"md\": [\"badge.md.css\"]\n        };\n    }\n    static get properties() {\n        return {\n            \"color\": {\n                \"type\": \"string\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"Color\",\n                    \"resolved\": \"\\\"danger\\\" | \\\"dark\\\" | \\\"light\\\" | \\\"medium\\\" | \\\"primary\\\" | \\\"secondary\\\" | \\\"success\\\" | \\\"tertiary\\\" | \\\"warning\\\" | string & Record<never, never> | undefined\",\n                    \"references\": {\n                        \"Color\": {\n                            \"location\": \"import\",\n                            \"path\": \"../../interface\",\n                            \"id\": \"src/interface.d.ts::Color\"\n                        }\n                    }\n                },\n                \"required\": false,\n                \"optional\": true,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"The color to use from your application's color palette.\\nDefault options are: `\\\"primary\\\"`, `\\\"secondary\\\"`, `\\\"tertiary\\\"`, `\\\"success\\\"`, `\\\"warning\\\"`, `\\\"danger\\\"`, `\\\"light\\\"`, `\\\"medium\\\"`, and `\\\"dark\\\"`.\\nFor more information on colors, see [theming](/docs/theming/basics).\"\n                },\n                \"attribute\": \"color\",\n                \"reflect\": true\n            }\n        };\n    }\n}\n","/**\n * Convert a font size to a dynamic font size.\n * Fonts that participate in Dynamic Type should use\n * dynamic font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param unit (optional) - The unit to convert to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a maximum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a minimum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * maximum and minimum font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * A heuristic that applies CSS to tablet\n * viewports.\n *\n * Usage:\n * @include tablet-viewport() {\n *   :host {\n *     background-color: green;\n *   }\n * }\n */\n/**\n * A heuristic that applies CSS to mobile\n * viewports (i.e. phones, not tablets).\n *\n * Usage:\n * @include mobile-viewport() {\n *   :host {\n *     background-color: blue;\n *   }\n * }\n */\n:host {\n  /**\n   * @prop --background: Background of the segment button\n   */\n  --ripple-color: currentColor;\n  -moz-osx-font-smoothing: grayscale;\n  -webkit-font-smoothing: antialiased;\n  display: grid;\n  grid-auto-columns: 1fr;\n  position: relative;\n  align-items: stretch;\n  justify-content: center;\n  width: 100%;\n  background: var(--background);\n  font-family: var(--ion-font-family, inherit);\n  text-align: center;\n  contain: paint;\n  user-select: none;\n}\n\n:host(.segment-scrollable) {\n  justify-content: start;\n  width: auto;\n  overflow-x: auto;\n  grid-auto-columns: minmax(min-content, 1fr);\n}\n\n:host(.segment-scrollable::-webkit-scrollbar) {\n  display: none;\n}\n\n/**\n * Convert a font size to a dynamic font size.\n * Fonts that participate in Dynamic Type should use\n * dynamic font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param unit (optional) - The unit to convert to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a maximum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a minimum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * maximum and minimum font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * A heuristic that applies CSS to tablet\n * viewports.\n *\n * Usage:\n * @include tablet-viewport() {\n *   :host {\n *     background-color: green;\n *   }\n * }\n */\n/**\n * A heuristic that applies CSS to mobile\n * viewports (i.e. phones, not tablets).\n *\n * Usage:\n * @include mobile-viewport() {\n *   :host {\n *     background-color: blue;\n *   }\n * }\n */\n/**\n * Convert a font size to a dynamic font size.\n * Fonts that participate in Dynamic Type should use\n * dynamic font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param unit (optional) - The unit to convert to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a maximum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a minimum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * maximum and minimum font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * A heuristic that applies CSS to tablet\n * viewports.\n *\n * Usage:\n * @include tablet-viewport() {\n *   :host {\n *     background-color: green;\n *   }\n * }\n */\n/**\n * A heuristic that applies CSS to mobile\n * viewports (i.e. phones, not tablets).\n *\n * Usage:\n * @include mobile-viewport() {\n *   :host {\n *     background-color: blue;\n *   }\n * }\n */\n:host {\n  --background: rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.065);\n  border-radius: 8px;\n  overflow: hidden;\n  z-index: 0;\n}\n\n:host(.ion-color) {\n  background: rgba(var(--ion-color-base-rgb), 0.065);\n}\n\n:host(.in-toolbar) {\n  -webkit-margin-start: auto;\n  margin-inline-start: auto;\n  -webkit-margin-end: auto;\n  margin-inline-end: auto;\n  margin-top: 0;\n  margin-bottom: 0;\n  width: auto;\n}\n\n:host(.in-toolbar:not(.ion-color)) {\n  background: var(--ion-toolbar-segment-background, var(--background));\n}\n\n:host(.in-toolbar-color:not(.ion-color)) {\n  background: rgba(var(--ion-color-contrast-rgb), 0.11);\n}","/**\n * Convert a font size to a dynamic font size.\n * Fonts that participate in Dynamic Type should use\n * dynamic font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param unit (optional) - The unit to convert to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a maximum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a minimum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * maximum and minimum font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * A heuristic that applies CSS to tablet\n * viewports.\n *\n * Usage:\n * @include tablet-viewport() {\n *   :host {\n *     background-color: green;\n *   }\n * }\n */\n/**\n * A heuristic that applies CSS to mobile\n * viewports (i.e. phones, not tablets).\n *\n * Usage:\n * @include mobile-viewport() {\n *   :host {\n *     background-color: blue;\n *   }\n * }\n */\n:host {\n  /**\n   * @prop --background: Background of the segment button\n   */\n  --ripple-color: currentColor;\n  -moz-osx-font-smoothing: grayscale;\n  -webkit-font-smoothing: antialiased;\n  display: grid;\n  grid-auto-columns: 1fr;\n  position: relative;\n  align-items: stretch;\n  justify-content: center;\n  width: 100%;\n  background: var(--background);\n  font-family: var(--ion-font-family, inherit);\n  text-align: center;\n  contain: paint;\n  user-select: none;\n}\n\n:host(.segment-scrollable) {\n  justify-content: start;\n  width: auto;\n  overflow-x: auto;\n  grid-auto-columns: minmax(min-content, 1fr);\n}\n\n:host(.segment-scrollable::-webkit-scrollbar) {\n  display: none;\n}\n\n/**\n * Convert a font size to a dynamic font size.\n * Fonts that participate in Dynamic Type should use\n * dynamic font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param unit (optional) - The unit to convert to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a maximum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a minimum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * maximum and minimum font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * A heuristic that applies CSS to tablet\n * viewports.\n *\n * Usage:\n * @include tablet-viewport() {\n *   :host {\n *     background-color: green;\n *   }\n * }\n */\n/**\n * A heuristic that applies CSS to mobile\n * viewports (i.e. phones, not tablets).\n *\n * Usage:\n * @include mobile-viewport() {\n *   :host {\n *     background-color: blue;\n *   }\n * }\n */\n/**\n * Convert a font size to a dynamic font size.\n * Fonts that participate in Dynamic Type should use\n * dynamic font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param unit (optional) - The unit to convert to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a maximum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a minimum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * maximum and minimum font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * A heuristic that applies CSS to tablet\n * viewports.\n *\n * Usage:\n * @include tablet-viewport() {\n *   :host {\n *     background-color: green;\n *   }\n * }\n */\n/**\n * A heuristic that applies CSS to mobile\n * viewports (i.e. phones, not tablets).\n *\n * Usage:\n * @include mobile-viewport() {\n *   :host {\n *     background-color: blue;\n *   }\n * }\n */\n:host {\n  --background: transparent;\n  grid-auto-columns: minmax(auto, 360px);\n}\n\n:host(.in-toolbar) {\n  /**\n   * Segment should inherit the\n   * height of the toolbar.\n   * Note: --min-height is initially\n   * set on ion-toolbar, not ion-segment\n   */\n  min-height: var(--min-height);\n}\n\n:host(.segment-scrollable) ::slotted(ion-segment-button) {\n  min-width: auto;\n}","/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { Host, h, writeTask } from \"@stencil/core\";\nimport { raf } from \"../../utils/helpers\";\nimport { isRTL } from \"../../utils/rtl/index\";\nimport { createColorClasses, hostContext } from \"../../utils/theme\";\nimport { getIonMode } from \"../../global/ionic-global\";\n/**\n * @virtualProp {\"ios\" | \"md\"} mode - The mode determines which platform styles to use.\n */\nexport class Segment {\n    constructor() {\n        this.onClick = (ev) => {\n            const current = ev.target;\n            const previous = this.checked;\n            // If the current element is a segment then that means\n            // the user tried to swipe to a segment button and\n            // click a segment button at the same time so we should\n            // not update the checked segment button\n            if (current.tagName === 'ION-SEGMENT') {\n                return;\n            }\n            this.value = current.value;\n            if (current !== previous) {\n                this.emitValueChange();\n            }\n            if (this.scrollable || !this.swipeGesture) {\n                if (previous) {\n                    this.checkButton(previous, current);\n                }\n                else {\n                    this.setCheckedClasses();\n                }\n            }\n        };\n        this.onSlottedItemsChange = () => {\n            /**\n             * When the slotted segment buttons change we need to\n             * ensure that the new segment buttons are checked if\n             * the value matches the segment button value.\n             */\n            this.valueChanged(this.value);\n        };\n        this.getSegmentButton = (selector) => {\n            var _a, _b;\n            const buttons = this.getButtons().filter((button) => !button.disabled);\n            const currIndex = buttons.findIndex((button) => button === document.activeElement);\n            switch (selector) {\n                case 'first':\n                    return buttons[0];\n                case 'last':\n                    return buttons[buttons.length - 1];\n                case 'next':\n                    return (_a = buttons[currIndex + 1]) !== null && _a !== void 0 ? _a : buttons[0];\n                case 'previous':\n                    return (_b = buttons[currIndex - 1]) !== null && _b !== void 0 ? _b : buttons[buttons.length - 1];\n                default:\n                    return null;\n            }\n        };\n        this.activated = false;\n        this.color = undefined;\n        this.disabled = false;\n        this.scrollable = false;\n        this.swipeGesture = true;\n        this.value = undefined;\n        this.selectOnFocus = false;\n    }\n    colorChanged(value, oldValue) {\n        /**\n         * If color is set after not having\n         * previously been set (or vice versa),\n         * we need to emit style so the segment-buttons\n         * can apply their color classes properly.\n         */\n        if ((oldValue === undefined && value !== undefined) || (oldValue !== undefined && value === undefined)) {\n            this.emitStyle();\n        }\n    }\n    swipeGestureChanged() {\n        this.gestureChanged();\n    }\n    valueChanged(value) {\n        /**\n         * `ionSelect` is emitted every time the value changes (internal or external changes).\n         * Used by `ion-segment-button` to determine if the button should be checked.\n         */\n        this.ionSelect.emit({ value });\n        this.scrollActiveButtonIntoView();\n    }\n    disabledChanged() {\n        this.gestureChanged();\n        const buttons = this.getButtons();\n        for (const button of buttons) {\n            button.disabled = this.disabled;\n        }\n    }\n    gestureChanged() {\n        if (this.gesture) {\n            this.gesture.enable(!this.scrollable && !this.disabled && this.swipeGesture);\n        }\n    }\n    connectedCallback() {\n        this.emitStyle();\n    }\n    componentWillLoad() {\n        this.emitStyle();\n    }\n    async componentDidLoad() {\n        this.setCheckedClasses();\n        /**\n         * We need to wait for the buttons to all be rendered\n         * before we can scroll.\n         */\n        raf(() => {\n            /**\n             * When the segment loads for the first\n             * time we just want to snap the active button into\n             * place instead of scroll. Smooth scrolling should only\n             * happen when the user interacts with the segment.\n             */\n            this.scrollActiveButtonIntoView(false);\n        });\n        this.gesture = (await import('../../utils/gesture')).createGesture({\n            el: this.el,\n            gestureName: 'segment',\n            gesturePriority: 100,\n            threshold: 0,\n            passive: false,\n            onStart: (ev) => this.onStart(ev),\n            onMove: (ev) => this.onMove(ev),\n            onEnd: (ev) => this.onEnd(ev),\n        });\n        this.gestureChanged();\n        if (this.disabled) {\n            this.disabledChanged();\n        }\n    }\n    onStart(detail) {\n        this.valueBeforeGesture = this.value;\n        this.activate(detail);\n    }\n    onMove(detail) {\n        this.setNextIndex(detail);\n    }\n    onEnd(detail) {\n        this.setActivated(false);\n        this.setNextIndex(detail, true);\n        detail.event.stopImmediatePropagation();\n        const value = this.value;\n        if (value !== undefined) {\n            if (this.valueBeforeGesture !== value) {\n                this.emitValueChange();\n            }\n        }\n        this.valueBeforeGesture = undefined;\n    }\n    /**\n     * Emits an `ionChange` event.\n     *\n     * This API should be called for user committed changes.\n     * This API should not be used for external value changes.\n     */\n    emitValueChange() {\n        const { value } = this;\n        this.ionChange.emit({ value });\n    }\n    getButtons() {\n        return Array.from(this.el.querySelectorAll('ion-segment-button'));\n    }\n    get checked() {\n        return this.getButtons().find((button) => button.value === this.value);\n    }\n    /*\n     * Activate both the segment and the buttons\n     * due to a bug with ::slotted in Safari\n     */\n    setActivated(activated) {\n        const buttons = this.getButtons();\n        buttons.forEach((button) => {\n            if (activated) {\n                button.classList.add('segment-button-activated');\n            }\n            else {\n                button.classList.remove('segment-button-activated');\n            }\n        });\n        this.activated = activated;\n    }\n    activate(detail) {\n        const clicked = detail.event.target;\n        const buttons = this.getButtons();\n        const checked = buttons.find((button) => button.value === this.value);\n        // Make sure we are only checking for activation on a segment button\n        // since disabled buttons will get the click on the segment\n        if (clicked.tagName !== 'ION-SEGMENT-BUTTON') {\n            return;\n        }\n        // If there are no checked buttons, set the current button to checked\n        if (!checked) {\n            this.value = clicked.value;\n            this.setCheckedClasses();\n        }\n        // If the gesture began on the clicked button with the indicator\n        // then we should activate the indicator\n        if (this.value === clicked.value) {\n            this.setActivated(true);\n        }\n    }\n    getIndicator(button) {\n        const root = button.shadowRoot || button;\n        return root.querySelector('.segment-button-indicator');\n    }\n    checkButton(previous, current) {\n        const previousIndicator = this.getIndicator(previous);\n        const currentIndicator = this.getIndicator(current);\n        if (previousIndicator === null || currentIndicator === null) {\n            return;\n        }\n        const previousClientRect = previousIndicator.getBoundingClientRect();\n        const currentClientRect = currentIndicator.getBoundingClientRect();\n        const widthDelta = previousClientRect.width / currentClientRect.width;\n        const xPosition = previousClientRect.left - currentClientRect.left;\n        // Scale the indicator width to match the previous indicator width\n        // and translate it on top of the previous indicator\n        const transform = `translate3d(${xPosition}px, 0, 0) scaleX(${widthDelta})`;\n        writeTask(() => {\n            // Remove the transition before positioning on top of the previous indicator\n            currentIndicator.classList.remove('segment-button-indicator-animated');\n            currentIndicator.style.setProperty('transform', transform);\n            // Force a repaint to ensure the transform happens\n            currentIndicator.getBoundingClientRect();\n            // Add the transition to move the indicator into place\n            currentIndicator.classList.add('segment-button-indicator-animated');\n            // Remove the transform to slide the indicator back to the button clicked\n            currentIndicator.style.setProperty('transform', '');\n        });\n        this.value = current.value;\n        this.setCheckedClasses();\n    }\n    setCheckedClasses() {\n        const buttons = this.getButtons();\n        const index = buttons.findIndex((button) => button.value === this.value);\n        const next = index + 1;\n        for (const button of buttons) {\n            button.classList.remove('segment-button-after-checked');\n        }\n        if (next < buttons.length) {\n            buttons[next].classList.add('segment-button-after-checked');\n        }\n    }\n    scrollActiveButtonIntoView(smoothScroll = true) {\n        const { scrollable, value, el } = this;\n        if (scrollable) {\n            const buttons = this.getButtons();\n            const activeButton = buttons.find((button) => button.value === value);\n            if (activeButton !== undefined) {\n                const scrollContainerBox = el.getBoundingClientRect();\n                const activeButtonBox = activeButton.getBoundingClientRect();\n                /**\n                 * Subtract the active button x position from the scroll\n                 * container x position. This will give us the x position\n                 * of the active button within the scroll container.\n                 */\n                const activeButtonLeft = activeButtonBox.x - scrollContainerBox.x;\n                /**\n                 * If we just used activeButtonLeft, then the active button\n                 * would be aligned with the left edge of the scroll container.\n                 * Instead, we want the segment button to be centered. As a result,\n                 * we subtract half of the scroll container width. This will position\n                 * the left edge of the active button at the midpoint of the scroll container.\n                 * We then add half of the active button width. This will position the active\n                 * button such that the midpoint of the active button is at the midpoint of the\n                 * scroll container.\n                 */\n                const centeredX = activeButtonLeft - scrollContainerBox.width / 2 + activeButtonBox.width / 2;\n                /**\n                 * We intentionally use scrollBy here instead of scrollIntoView\n                 * to avoid a WebKit bug where accelerated animations break\n                 * when using scrollIntoView. Using scrollIntoView will cause the\n                 * segment container to jump during the transition and then snap into place.\n                 * This is because scrollIntoView can potentially cause parent element\n                 * containers to also scroll. scrollBy does not have this same behavior, so\n                 * we use this API instead.\n                 *\n                 * Note that if there is not enough scrolling space to center the element\n                 * within the scroll container, the browser will attempt\n                 * to center by as much as it can.\n                 */\n                el.scrollBy({\n                    top: 0,\n                    left: centeredX,\n                    behavior: smoothScroll ? 'smooth' : 'instant',\n                });\n            }\n        }\n    }\n    setNextIndex(detail, isEnd = false) {\n        const rtl = isRTL(this.el);\n        const activated = this.activated;\n        const buttons = this.getButtons();\n        const index = buttons.findIndex((button) => button.value === this.value);\n        const previous = buttons[index];\n        let current;\n        let nextIndex;\n        if (index === -1) {\n            return;\n        }\n        // Get the element that the touch event started on in case\n        // it was the checked button, then we will move the indicator\n        const rect = previous.getBoundingClientRect();\n        const left = rect.left;\n        const width = rect.width;\n        // Get the element that the gesture is on top of based on the currentX of the\n        // gesture event and the Y coordinate of the starting element, since the gesture\n        // can move up and down off of the segment\n        const currentX = detail.currentX;\n        const previousY = rect.top + rect.height / 2;\n        /**\n         * Segment can be used inside the shadow dom\n         * so doing document.elementFromPoint would never\n         * return a segment button in that instance.\n         * We use getRootNode to which will return the parent\n         * shadow root if used inside a shadow component and\n         * returns document otherwise.\n         */\n        const root = this.el.getRootNode();\n        const nextEl = root.elementFromPoint(currentX, previousY);\n        const decreaseIndex = rtl ? currentX > left + width : currentX < left;\n        const increaseIndex = rtl ? currentX < left : currentX > left + width;\n        // If the indicator is currently activated then we have started the gesture\n        // on top of the checked button so we need to slide the indicator\n        // by checking the button next to it as we move\n        if (activated && !isEnd) {\n            // Decrease index, move left in LTR & right in RTL\n            if (decreaseIndex) {\n                const newIndex = index - 1;\n                if (newIndex >= 0) {\n                    nextIndex = newIndex;\n                }\n                // Increase index, moves right in LTR & left in RTL\n            }\n            else if (increaseIndex) {\n                if (activated && !isEnd) {\n                    const newIndex = index + 1;\n                    if (newIndex < buttons.length) {\n                        nextIndex = newIndex;\n                    }\n                }\n            }\n            if (nextIndex !== undefined && !buttons[nextIndex].disabled) {\n                current = buttons[nextIndex];\n            }\n        }\n        // If the indicator is not activated then we will just set the indicator\n        // to the element where the gesture ended\n        if (!activated && isEnd) {\n            current = nextEl;\n        }\n        if (current != null) {\n            /**\n             * If current element is ion-segment then that means\n             * user tried to select a disabled ion-segment-button,\n             * and we should not update the ripple.\n             */\n            if (current.tagName === 'ION-SEGMENT') {\n                return false;\n            }\n            if (previous !== current) {\n                this.checkButton(previous, current);\n            }\n        }\n        return true;\n    }\n    emitStyle() {\n        this.ionStyle.emit({\n            segment: true,\n        });\n    }\n    onKeyDown(ev) {\n        const rtl = isRTL(this.el);\n        let keyDownSelectsButton = this.selectOnFocus;\n        let current;\n        switch (ev.key) {\n            case 'ArrowRight':\n                ev.preventDefault();\n                current = rtl ? this.getSegmentButton('previous') : this.getSegmentButton('next');\n                break;\n            case 'ArrowLeft':\n                ev.preventDefault();\n                current = rtl ? this.getSegmentButton('next') : this.getSegmentButton('previous');\n                break;\n            case 'Home':\n                ev.preventDefault();\n                current = this.getSegmentButton('first');\n                break;\n            case 'End':\n                ev.preventDefault();\n                current = this.getSegmentButton('last');\n                break;\n            case ' ':\n            case 'Enter':\n                ev.preventDefault();\n                current = document.activeElement;\n                keyDownSelectsButton = true;\n            default:\n                break;\n        }\n        if (!current) {\n            return;\n        }\n        if (keyDownSelectsButton) {\n            const previous = this.checked;\n            this.checkButton(previous || current, current);\n            if (current !== previous) {\n                this.emitValueChange();\n            }\n        }\n        current.setFocus();\n    }\n    render() {\n        const mode = getIonMode(this);\n        return (h(Host, { key: 'ad0946134c8d465b760ad792655f1cb9922db520', role: \"tablist\", onClick: this.onClick, class: createColorClasses(this.color, {\n                [mode]: true,\n                'in-toolbar': hostContext('ion-toolbar', this.el),\n                'in-toolbar-color': hostContext('ion-toolbar[color]', this.el),\n                'segment-activated': this.activated,\n                'segment-disabled': this.disabled,\n                'segment-scrollable': this.scrollable,\n            }) }, h(\"slot\", { key: 'dcdb425bcda0d60acb7c317e5e671ed462715b4a', onSlotchange: this.onSlottedItemsChange })));\n    }\n    static get is() { return \"ion-segment\"; }\n    static get encapsulation() { return \"shadow\"; }\n    static get originalStyleUrls() {\n        return {\n            \"ios\": [\"segment.ios.scss\"],\n            \"md\": [\"segment.md.scss\"]\n        };\n    }\n    static get styleUrls() {\n        return {\n            \"ios\": [\"segment.ios.css\"],\n            \"md\": [\"segment.md.css\"]\n        };\n    }\n    static get properties() {\n        return {\n            \"color\": {\n                \"type\": \"string\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"Color\",\n                    \"resolved\": \"\\\"danger\\\" | \\\"dark\\\" | \\\"light\\\" | \\\"medium\\\" | \\\"primary\\\" | \\\"secondary\\\" | \\\"success\\\" | \\\"tertiary\\\" | \\\"warning\\\" | string & Record<never, never> | undefined\",\n                    \"references\": {\n                        \"Color\": {\n                            \"location\": \"import\",\n                            \"path\": \"../../interface\",\n                            \"id\": \"src/interface.d.ts::Color\"\n                        }\n                    }\n                },\n                \"required\": false,\n                \"optional\": true,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"The color to use from your application's color palette.\\nDefault options are: `\\\"primary\\\"`, `\\\"secondary\\\"`, `\\\"tertiary\\\"`, `\\\"success\\\"`, `\\\"warning\\\"`, `\\\"danger\\\"`, `\\\"light\\\"`, `\\\"medium\\\"`, and `\\\"dark\\\"`.\\nFor more information on colors, see [theming](/docs/theming/basics).\"\n                },\n                \"attribute\": \"color\",\n                \"reflect\": true\n            },\n            \"disabled\": {\n                \"type\": \"boolean\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"boolean\",\n                    \"resolved\": \"boolean\",\n                    \"references\": {}\n                },\n                \"required\": false,\n                \"optional\": false,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"If `true`, the user cannot interact with the segment.\"\n                },\n                \"attribute\": \"disabled\",\n                \"reflect\": false,\n                \"defaultValue\": \"false\"\n            },\n            \"scrollable\": {\n                \"type\": \"boolean\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"boolean\",\n                    \"resolved\": \"boolean\",\n                    \"references\": {}\n                },\n                \"required\": false,\n                \"optional\": false,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"If `true`, the segment buttons will overflow and the user can swipe to see them.\\nIn addition, this will disable the gesture to drag the indicator between the buttons\\nin order to swipe to see hidden buttons.\"\n                },\n                \"attribute\": \"scrollable\",\n                \"reflect\": false,\n                \"defaultValue\": \"false\"\n            },\n            \"swipeGesture\": {\n                \"type\": \"boolean\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"boolean\",\n                    \"resolved\": \"boolean\",\n                    \"references\": {}\n                },\n                \"required\": false,\n                \"optional\": false,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"If `true`, users will be able to swipe between segment buttons to activate them.\"\n                },\n                \"attribute\": \"swipe-gesture\",\n                \"reflect\": false,\n                \"defaultValue\": \"true\"\n            },\n            \"value\": {\n                \"type\": \"any\",\n                \"mutable\": true,\n                \"complexType\": {\n                    \"original\": \"SegmentValue\",\n                    \"resolved\": \"number | string | undefined\",\n                    \"references\": {\n                        \"SegmentValue\": {\n                            \"location\": \"import\",\n                            \"path\": \"./segment-interface\",\n                            \"id\": \"src/components/segment/segment-interface.ts::SegmentValue\"\n                        }\n                    }\n                },\n                \"required\": false,\n                \"optional\": true,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"the value of the segment.\"\n                },\n                \"attribute\": \"value\",\n                \"reflect\": false\n            },\n            \"selectOnFocus\": {\n                \"type\": \"boolean\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"boolean\",\n                    \"resolved\": \"boolean\",\n                    \"references\": {}\n                },\n                \"required\": false,\n                \"optional\": false,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"If `true`, navigating to an `ion-segment-button` with the keyboard will focus and select the element.\\nIf `false`, keyboard navigation will only focus the `ion-segment-button` element.\"\n                },\n                \"attribute\": \"select-on-focus\",\n                \"reflect\": false,\n                \"defaultValue\": \"false\"\n            }\n        };\n    }\n    static get states() {\n        return {\n            \"activated\": {}\n        };\n    }\n    static get events() {\n        return [{\n                \"method\": \"ionChange\",\n                \"name\": \"ionChange\",\n                \"bubbles\": true,\n                \"cancelable\": true,\n                \"composed\": true,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"Emitted when the value property has changed and any dragging pointer has been released from `ion-segment`.\\n\\nThis event will not emit when programmatically setting the `value` property.\"\n                },\n                \"complexType\": {\n                    \"original\": \"SegmentChangeEventDetail\",\n                    \"resolved\": \"SegmentChangeEventDetail\",\n                    \"references\": {\n                        \"SegmentChangeEventDetail\": {\n                            \"location\": \"import\",\n                            \"path\": \"./segment-interface\",\n                            \"id\": \"src/components/segment/segment-interface.ts::SegmentChangeEventDetail\"\n                        }\n                    }\n                }\n            }, {\n                \"method\": \"ionSelect\",\n                \"name\": \"ionSelect\",\n                \"bubbles\": true,\n                \"cancelable\": true,\n                \"composed\": true,\n                \"docs\": {\n                    \"tags\": [{\n                            \"name\": \"internal\",\n                            \"text\": undefined\n                        }],\n                    \"text\": \"Emitted when the value of the segment changes from user committed actions\\nor from externally assigning a value.\"\n                },\n                \"complexType\": {\n                    \"original\": \"SegmentChangeEventDetail\",\n                    \"resolved\": \"SegmentChangeEventDetail\",\n                    \"references\": {\n                        \"SegmentChangeEventDetail\": {\n                            \"location\": \"import\",\n                            \"path\": \"./segment-interface\",\n                            \"id\": \"src/components/segment/segment-interface.ts::SegmentChangeEventDetail\"\n                        }\n                    }\n                }\n            }, {\n                \"method\": \"ionStyle\",\n                \"name\": \"ionStyle\",\n                \"bubbles\": true,\n                \"cancelable\": true,\n                \"composed\": true,\n                \"docs\": {\n                    \"tags\": [{\n                            \"name\": \"internal\",\n                            \"text\": undefined\n                        }],\n                    \"text\": \"Emitted when the styles change.\"\n                },\n                \"complexType\": {\n                    \"original\": \"StyleEventDetail\",\n                    \"resolved\": \"StyleEventDetail\",\n                    \"references\": {\n                        \"StyleEventDetail\": {\n                            \"location\": \"import\",\n                            \"path\": \"../../interface\",\n                            \"id\": \"src/interface.d.ts::StyleEventDetail\"\n                        }\n                    }\n                }\n            }];\n    }\n    static get elementRef() { return \"el\"; }\n    static get watchers() {\n        return [{\n                \"propName\": \"color\",\n                \"methodName\": \"colorChanged\"\n            }, {\n                \"propName\": \"swipeGesture\",\n                \"methodName\": \"swipeGestureChanged\"\n            }, {\n                \"propName\": \"value\",\n                \"methodName\": \"valueChanged\"\n            }, {\n                \"propName\": \"disabled\",\n                \"methodName\": \"disabledChanged\"\n            }];\n    }\n    static get listeners() {\n        return [{\n                \"name\": \"keydown\",\n                \"method\": \"onKeyDown\",\n                \"target\": undefined,\n                \"capture\": false,\n                \"passive\": false\n            }];\n    }\n}\n","/**\n * Convert a font size to a dynamic font size.\n * Fonts that participate in Dynamic Type should use\n * dynamic font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param unit (optional) - The unit to convert to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a maximum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a minimum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * maximum and minimum font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * A heuristic that applies CSS to tablet\n * viewports.\n *\n * Usage:\n * @include tablet-viewport() {\n *   :host {\n *     background-color: green;\n *   }\n * }\n */\n/**\n * A heuristic that applies CSS to mobile\n * viewports (i.e. phones, not tablets).\n *\n * Usage:\n * @include mobile-viewport() {\n *   :host {\n *     background-color: blue;\n *   }\n * }\n */\n:host {\n  /**\n   * @prop --background: Background of the segment button\n   * @prop --background-checked: Background of the checked segment button\n   *\n   * @prop --background-hover: Background of the segment button on hover\n   * @prop --background-focused: Background of the segment button when focused with the tab key\n   *\n   * @prop --background-hover-opacity: Opacity of the segment button background on hover\n   * @prop --background-focused-opacity: Opacity of the segment button background when focused with the tab key\n   *\n   * @prop --color: Color of the segment button\n   * @prop --color-checked: Color of the checked segment button\n   * @prop --color-hover: Color of the segment button on hover\n   * @prop --color-focused: Color of the segment button when focused with the tab key\n   *\n   * @prop --border-radius: Radius of the segment button border\n   * @prop --border-color: Color of the segment button border\n   * @prop --border-style: Style of the segment button border\n   * @prop --border-width: Width of the segment button border\n   *\n   * @prop --margin-top: Top margin of the segment button\n   * @prop --margin-end: Right margin if direction is left-to-right, and left margin if direction is right-to-left of the segment button\n   * @prop --margin-bottom: Bottom margin of the segment button\n   * @prop --margin-start: Left margin if direction is left-to-right, and right margin if direction is right-to-left of the segment button\n   *\n   * @prop --padding-top: Top padding of the segment button\n   * @prop --padding-end: Right padding if direction is left-to-right, and left padding if direction is right-to-left of the segment button\n   * @prop --padding-bottom: Bottom padding of the segment button\n   * @prop --padding-start: Left padding if direction is left-to-right, and right padding if direction is right-to-left of the segment button\n   *\n   * @prop --transition: Transition of the segment button\n   *\n   * @prop --indicator-height: Height of the indicator for the checked segment button\n   * @prop --indicator-box-shadow: Box shadow on the indicator for the checked segment button\n   * @prop --indicator-color: Color of the indicator for the checked segment button\n   * @prop --indicator-transition: Transition of the indicator for the checked segment button\n   * @prop --indicator-transform: Transform of the indicator for the checked segment button\n   */\n  --color: initial;\n  --color-hover: var(--color);\n  --color-checked: var(--color);\n  --color-disabled: var(--color);\n  --padding-start: 0;\n  --padding-end: 0;\n  --padding-top: 0;\n  --padding-bottom: 0;\n  border-radius: var(--border-radius);\n  display: flex;\n  position: relative;\n  flex-direction: column;\n  height: auto;\n  background: var(--background);\n  color: var(--color);\n  text-decoration: none;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n  cursor: pointer;\n  grid-row: 1;\n  font-kerning: none;\n}\n\n.button-native {\n  border-radius: 0;\n  font-family: inherit;\n  font-size: inherit;\n  font-style: inherit;\n  font-weight: inherit;\n  letter-spacing: inherit;\n  text-decoration: inherit;\n  text-indent: inherit;\n  text-overflow: inherit;\n  text-transform: inherit;\n  text-align: inherit;\n  white-space: inherit;\n  color: inherit;\n  -webkit-margin-start: var(--margin-start);\n  margin-inline-start: var(--margin-start);\n  -webkit-margin-end: var(--margin-end);\n  margin-inline-end: var(--margin-end);\n  margin-top: var(--margin-top);\n  margin-bottom: var(--margin-bottom);\n  -webkit-padding-start: var(--padding-start);\n  padding-inline-start: var(--padding-start);\n  -webkit-padding-end: var(--padding-end);\n  padding-inline-end: var(--padding-end);\n  padding-top: var(--padding-top);\n  padding-bottom: var(--padding-bottom);\n  transform: translate3d(0,  0,  0);\n  display: flex;\n  position: relative;\n  flex-direction: inherit;\n  flex-grow: 1;\n  align-items: center;\n  justify-content: center;\n  width: 100%;\n  min-width: inherit;\n  max-width: inherit;\n  height: auto;\n  min-height: inherit;\n  max-height: inherit;\n  transition: var(--transition);\n  border: none;\n  outline: none;\n  background: transparent;\n  contain: content;\n  pointer-events: none;\n  overflow: hidden;\n  z-index: 2;\n}\n\n.button-native::after {\n  left: 0;\n  right: 0;\n  top: 0;\n  bottom: 0;\n  position: absolute;\n  content: \"\";\n  opacity: 0;\n}\n\n.button-inner {\n  display: flex;\n  position: relative;\n  flex-flow: inherit;\n  align-items: center;\n  justify-content: center;\n  width: 100%;\n  height: 100%;\n  z-index: 1;\n}\n\n:host(.segment-button-checked) {\n  background: var(--background-checked);\n  color: var(--color-checked);\n}\n\n:host(.segment-button-disabled) {\n  cursor: default;\n  pointer-events: none;\n}\n\n:host(.ion-focused) .button-native {\n  color: var(--color-focused);\n}\n:host(.ion-focused) .button-native::after {\n  background: var(--background-focused);\n  opacity: var(--background-focused-opacity);\n}\n\n:host(:focus) {\n  outline: none;\n}\n\n@media (any-hover: hover) {\n  :host(:hover) .button-native {\n    color: var(--color-hover);\n  }\n  :host(:hover) .button-native::after {\n    background: var(--background-hover);\n    opacity: var(--background-hover-opacity);\n  }\n  :host(.segment-button-checked:hover) .button-native {\n    color: var(--color-checked);\n  }\n}\n::slotted(ion-icon) {\n  flex-shrink: 0;\n  order: -1;\n  pointer-events: none;\n}\n\n::slotted(ion-label) {\n  display: block;\n  align-self: center;\n  max-width: 100%;\n  line-height: 22px;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n  overflow: hidden;\n  box-sizing: border-box;\n  pointer-events: none;\n}\n\n:host(.segment-button-layout-icon-top) .button-native {\n  flex-direction: column;\n}\n\n:host(.segment-button-layout-icon-start) .button-native {\n  flex-direction: row;\n}\n\n:host(.segment-button-layout-icon-end) .button-native {\n  flex-direction: row-reverse;\n}\n\n:host(.segment-button-layout-icon-bottom) .button-native {\n  flex-direction: column-reverse;\n}\n\n:host(.segment-button-layout-icon-hide) ::slotted(ion-icon) {\n  display: none;\n}\n\n:host(.segment-button-layout-label-hide) ::slotted(ion-label) {\n  display: none;\n}\n\nion-ripple-effect {\n  color: var(--ripple-color, var(--color-checked));\n}\n\n.segment-button-indicator {\n  transform-origin: left;\n  position: absolute;\n  opacity: 0;\n  box-sizing: border-box;\n  will-change: transform, opacity;\n  pointer-events: none;\n}\n\n.segment-button-indicator-background {\n  width: 100%;\n  height: var(--indicator-height);\n  transform: var(--indicator-transform);\n  box-shadow: var(--indicator-box-shadow);\n  pointer-events: none;\n}\n\n.segment-button-indicator-animated {\n  transition: var(--indicator-transition);\n}\n\n:host(.segment-button-checked) .segment-button-indicator {\n  opacity: 1;\n}\n\n@media (prefers-reduced-motion: reduce) {\n  .segment-button-indicator-background {\n    transform: none;\n  }\n  .segment-button-indicator-animated {\n    transition: none;\n  }\n}\n/**\n * Convert a font size to a dynamic font size.\n * Fonts that participate in Dynamic Type should use\n * dynamic font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param unit (optional) - The unit to convert to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a maximum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a minimum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * maximum and minimum font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * A heuristic that applies CSS to tablet\n * viewports.\n *\n * Usage:\n * @include tablet-viewport() {\n *   :host {\n *     background-color: green;\n *   }\n * }\n */\n/**\n * A heuristic that applies CSS to mobile\n * viewports (i.e. phones, not tablets).\n *\n * Usage:\n * @include mobile-viewport() {\n *   :host {\n *     background-color: blue;\n *   }\n * }\n */\n:host {\n  --background: none;\n  --background-checked: none;\n  --background-hover: none;\n  --background-hover-opacity: 0;\n  --background-focused: none;\n  --background-focused-opacity: 0;\n  --border-radius: 7px;\n  --border-width: 1px;\n  --border-color: rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.12);\n  --border-style: solid;\n  --indicator-box-shadow: 0 0 5px rgba(0, 0, 0, 0.16);\n  --indicator-color: var(--ion-color-step-350, var(--ion-background-color-step-350, var(--ion-background-color, #fff)));\n  --indicator-height: 100%;\n  --indicator-transition: transform 260ms cubic-bezier(0.4, 0, 0.2, 1);\n  --indicator-transform: none;\n  --transition: 100ms all linear;\n  --padding-top: 0;\n  --padding-end: 13px;\n  --padding-bottom: 0;\n  --padding-start: 13px;\n  margin-top: 2px;\n  margin-bottom: 2px;\n  position: relative;\n  flex-direction: row;\n  min-width: 70px;\n  min-height: 28px;\n  transform: translate3d(0, 0, 0);\n  font-size: 13px;\n  font-weight: 450;\n  line-height: 37px;\n}\n\n:host::before {\n  margin-left: 0;\n  margin-right: 0;\n  margin-top: 5px;\n  margin-bottom: 5px;\n  transition: 160ms opacity ease-in-out;\n  transition-delay: 100ms;\n  border-left: var(--border-width) var(--border-style) var(--border-color);\n  content: \"\";\n  opacity: 1;\n  will-change: opacity;\n}\n\n:host(:first-of-type)::before {\n  border-left-color: transparent;\n}\n\n:host(.segment-button-disabled) {\n  opacity: 0.3;\n}\n\n::slotted(ion-icon) {\n  font-size: 24px;\n}\n\n:host(.segment-button-layout-icon-start) ::slotted(ion-label) {\n  -webkit-margin-start: 2px;\n  margin-inline-start: 2px;\n  -webkit-margin-end: 0;\n  margin-inline-end: 0;\n}\n\n:host(.segment-button-layout-icon-end) ::slotted(ion-label) {\n  -webkit-margin-start: 0;\n  margin-inline-start: 0;\n  -webkit-margin-end: 2px;\n  margin-inline-end: 2px;\n}\n\n.segment-button-indicator {\n  -webkit-padding-start: 2px;\n  padding-inline-start: 2px;\n  -webkit-padding-end: 2px;\n  padding-inline-end: 2px;\n  left: 0;\n  right: 0;\n  top: 0;\n  bottom: 0;\n}\n\n.segment-button-indicator-background {\n  border-radius: var(--border-radius);\n  background: var(--indicator-color);\n}\n\n.segment-button-indicator-background {\n  transition: var(--indicator-transition);\n}\n\n:host(.segment-button-checked)::before,\n:host(.segment-button-after-checked)::before {\n  opacity: 0;\n}\n\n:host(.segment-button-checked) {\n  z-index: -1;\n}\n\n:host(.segment-button-activated) {\n  --indicator-transform: scale(0.95);\n}\n\n:host(.ion-focused) .button-native {\n  opacity: 0.7;\n}\n\n@media (any-hover: hover) {\n  :host(:hover) .button-native {\n    opacity: 0.5;\n  }\n  :host(.segment-button-checked:hover) .button-native {\n    opacity: 1;\n  }\n}\n:host(.in-segment-color) {\n  background: none;\n  color: var(--ion-text-color, #000);\n}\n\n:host(.in-segment-color) .segment-button-indicator-background {\n  background: var(--ion-color-step-350, var(--ion-background-color-step-350, var(--ion-background-color, #fff)));\n}\n\n@media (any-hover: hover) {\n  :host(.in-segment-color:hover) .button-native,\n  :host(.in-segment-color.segment-button-checked:hover) .button-native {\n    color: var(--ion-text-color, #000);\n  }\n}\n:host(.in-toolbar:not(.in-segment-color)) {\n  --background-checked: var(--ion-toolbar-segment-background-checked, none);\n  --color: var(--ion-toolbar-segment-color, var(--ion-toolbar-color), initial);\n  --color-checked: var(--ion-toolbar-segment-color-checked, var(--ion-toolbar-color), initial);\n  --indicator-color: var(--ion-toolbar-segment-indicator-color, var(--ion-color-step-350, var(--ion-background-color-step-350, var(--ion-background-color, #fff))));\n}\n\n/**\n * Use the contrast color as background since\n * since the text color is the base color. Otherwise\n * we will have contrast issues when using light/medium/dark\n * palettes across light and dark mode.\n */\n:host(.in-toolbar-color) .segment-button-indicator-background {\n  background: var(--ion-color-contrast);\n}\n\n:host(.in-toolbar-color:not(.in-segment-color)) .button-native {\n  color: var(--ion-color-contrast);\n}\n\n:host(.in-toolbar-color.segment-button-checked:not(.in-segment-color)) .button-native {\n  color: var(--ion-color-base);\n}\n\n@media (any-hover: hover) {\n  :host(.in-toolbar-color:not(.in-segment-color):hover) .button-native {\n    color: var(--ion-color-contrast);\n  }\n  :host(.in-toolbar-color.segment-button-checked:not(.in-segment-color):hover) .button-native {\n    color: var(--ion-color-base);\n  }\n}","/**\n * Convert a font size to a dynamic font size.\n * Fonts that participate in Dynamic Type should use\n * dynamic font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param unit (optional) - The unit to convert to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a maximum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a minimum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * maximum and minimum font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * A heuristic that applies CSS to tablet\n * viewports.\n *\n * Usage:\n * @include tablet-viewport() {\n *   :host {\n *     background-color: green;\n *   }\n * }\n */\n/**\n * A heuristic that applies CSS to mobile\n * viewports (i.e. phones, not tablets).\n *\n * Usage:\n * @include mobile-viewport() {\n *   :host {\n *     background-color: blue;\n *   }\n * }\n */\n:host {\n  /**\n   * @prop --background: Background of the segment button\n   * @prop --background-checked: Background of the checked segment button\n   *\n   * @prop --background-hover: Background of the segment button on hover\n   * @prop --background-focused: Background of the segment button when focused with the tab key\n   *\n   * @prop --background-hover-opacity: Opacity of the segment button background on hover\n   * @prop --background-focused-opacity: Opacity of the segment button background when focused with the tab key\n   *\n   * @prop --color: Color of the segment button\n   * @prop --color-checked: Color of the checked segment button\n   * @prop --color-hover: Color of the segment button on hover\n   * @prop --color-focused: Color of the segment button when focused with the tab key\n   *\n   * @prop --border-radius: Radius of the segment button border\n   * @prop --border-color: Color of the segment button border\n   * @prop --border-style: Style of the segment button border\n   * @prop --border-width: Width of the segment button border\n   *\n   * @prop --margin-top: Top margin of the segment button\n   * @prop --margin-end: Right margin if direction is left-to-right, and left margin if direction is right-to-left of the segment button\n   * @prop --margin-bottom: Bottom margin of the segment button\n   * @prop --margin-start: Left margin if direction is left-to-right, and right margin if direction is right-to-left of the segment button\n   *\n   * @prop --padding-top: Top padding of the segment button\n   * @prop --padding-end: Right padding if direction is left-to-right, and left padding if direction is right-to-left of the segment button\n   * @prop --padding-bottom: Bottom padding of the segment button\n   * @prop --padding-start: Left padding if direction is left-to-right, and right padding if direction is right-to-left of the segment button\n   *\n   * @prop --transition: Transition of the segment button\n   *\n   * @prop --indicator-height: Height of the indicator for the checked segment button\n   * @prop --indicator-box-shadow: Box shadow on the indicator for the checked segment button\n   * @prop --indicator-color: Color of the indicator for the checked segment button\n   * @prop --indicator-transition: Transition of the indicator for the checked segment button\n   * @prop --indicator-transform: Transform of the indicator for the checked segment button\n   */\n  --color: initial;\n  --color-hover: var(--color);\n  --color-checked: var(--color);\n  --color-disabled: var(--color);\n  --padding-start: 0;\n  --padding-end: 0;\n  --padding-top: 0;\n  --padding-bottom: 0;\n  border-radius: var(--border-radius);\n  display: flex;\n  position: relative;\n  flex-direction: column;\n  height: auto;\n  background: var(--background);\n  color: var(--color);\n  text-decoration: none;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n  cursor: pointer;\n  grid-row: 1;\n  font-kerning: none;\n}\n\n.button-native {\n  border-radius: 0;\n  font-family: inherit;\n  font-size: inherit;\n  font-style: inherit;\n  font-weight: inherit;\n  letter-spacing: inherit;\n  text-decoration: inherit;\n  text-indent: inherit;\n  text-overflow: inherit;\n  text-transform: inherit;\n  text-align: inherit;\n  white-space: inherit;\n  color: inherit;\n  -webkit-margin-start: var(--margin-start);\n  margin-inline-start: var(--margin-start);\n  -webkit-margin-end: var(--margin-end);\n  margin-inline-end: var(--margin-end);\n  margin-top: var(--margin-top);\n  margin-bottom: var(--margin-bottom);\n  -webkit-padding-start: var(--padding-start);\n  padding-inline-start: var(--padding-start);\n  -webkit-padding-end: var(--padding-end);\n  padding-inline-end: var(--padding-end);\n  padding-top: var(--padding-top);\n  padding-bottom: var(--padding-bottom);\n  transform: translate3d(0,  0,  0);\n  display: flex;\n  position: relative;\n  flex-direction: inherit;\n  flex-grow: 1;\n  align-items: center;\n  justify-content: center;\n  width: 100%;\n  min-width: inherit;\n  max-width: inherit;\n  height: auto;\n  min-height: inherit;\n  max-height: inherit;\n  transition: var(--transition);\n  border: none;\n  outline: none;\n  background: transparent;\n  contain: content;\n  pointer-events: none;\n  overflow: hidden;\n  z-index: 2;\n}\n\n.button-native::after {\n  left: 0;\n  right: 0;\n  top: 0;\n  bottom: 0;\n  position: absolute;\n  content: \"\";\n  opacity: 0;\n}\n\n.button-inner {\n  display: flex;\n  position: relative;\n  flex-flow: inherit;\n  align-items: center;\n  justify-content: center;\n  width: 100%;\n  height: 100%;\n  z-index: 1;\n}\n\n:host(.segment-button-checked) {\n  background: var(--background-checked);\n  color: var(--color-checked);\n}\n\n:host(.segment-button-disabled) {\n  cursor: default;\n  pointer-events: none;\n}\n\n:host(.ion-focused) .button-native {\n  color: var(--color-focused);\n}\n:host(.ion-focused) .button-native::after {\n  background: var(--background-focused);\n  opacity: var(--background-focused-opacity);\n}\n\n:host(:focus) {\n  outline: none;\n}\n\n@media (any-hover: hover) {\n  :host(:hover) .button-native {\n    color: var(--color-hover);\n  }\n  :host(:hover) .button-native::after {\n    background: var(--background-hover);\n    opacity: var(--background-hover-opacity);\n  }\n  :host(.segment-button-checked:hover) .button-native {\n    color: var(--color-checked);\n  }\n}\n::slotted(ion-icon) {\n  flex-shrink: 0;\n  order: -1;\n  pointer-events: none;\n}\n\n::slotted(ion-label) {\n  display: block;\n  align-self: center;\n  max-width: 100%;\n  line-height: 22px;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n  overflow: hidden;\n  box-sizing: border-box;\n  pointer-events: none;\n}\n\n:host(.segment-button-layout-icon-top) .button-native {\n  flex-direction: column;\n}\n\n:host(.segment-button-layout-icon-start) .button-native {\n  flex-direction: row;\n}\n\n:host(.segment-button-layout-icon-end) .button-native {\n  flex-direction: row-reverse;\n}\n\n:host(.segment-button-layout-icon-bottom) .button-native {\n  flex-direction: column-reverse;\n}\n\n:host(.segment-button-layout-icon-hide) ::slotted(ion-icon) {\n  display: none;\n}\n\n:host(.segment-button-layout-label-hide) ::slotted(ion-label) {\n  display: none;\n}\n\nion-ripple-effect {\n  color: var(--ripple-color, var(--color-checked));\n}\n\n.segment-button-indicator {\n  transform-origin: left;\n  position: absolute;\n  opacity: 0;\n  box-sizing: border-box;\n  will-change: transform, opacity;\n  pointer-events: none;\n}\n\n.segment-button-indicator-background {\n  width: 100%;\n  height: var(--indicator-height);\n  transform: var(--indicator-transform);\n  box-shadow: var(--indicator-box-shadow);\n  pointer-events: none;\n}\n\n.segment-button-indicator-animated {\n  transition: var(--indicator-transition);\n}\n\n:host(.segment-button-checked) .segment-button-indicator {\n  opacity: 1;\n}\n\n@media (prefers-reduced-motion: reduce) {\n  .segment-button-indicator-background {\n    transform: none;\n  }\n  .segment-button-indicator-animated {\n    transition: none;\n  }\n}\n/**\n * Convert a font size to a dynamic font size.\n * Fonts that participate in Dynamic Type should use\n * dynamic font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param unit (optional) - The unit to convert to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a maximum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * a minimum font size.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * Convert a font size to a dynamic font size but impose\n * maximum and minimum font sizes.\n * @param size - The initial font size including the unit (i.e. px or pt)\n * @param minScale - The minimum scale of the font (i.e. 0.8 for a minimum 80% scale).\n * @param maxScale - The maximum scale of the font (i.e. 2.5 for a maximum 250% scale).\n * @param unit (optional) - The unit to convert the initial font size to. Use this if you want to\n * convert to a unit other than $baselineUnit.\n */\n/**\n * A heuristic that applies CSS to tablet\n * viewports.\n *\n * Usage:\n * @include tablet-viewport() {\n *   :host {\n *     background-color: green;\n *   }\n * }\n */\n/**\n * A heuristic that applies CSS to mobile\n * viewports (i.e. phones, not tablets).\n *\n * Usage:\n * @include mobile-viewport() {\n *   :host {\n *     background-color: blue;\n *   }\n * }\n */\n:host {\n  --background: none;\n  --background-checked: none;\n  --background-hover: var(--color-checked);\n  --background-focused: var(--color-checked);\n  --background-activated-opacity: 0;\n  --background-focused-opacity: .12;\n  --background-hover-opacity: .04;\n  --color: rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.6);\n  --color-checked: var(--ion-color-primary, #0054e9);\n  --indicator-box-shadow: none;\n  --indicator-color: var(--color-checked);\n  --indicator-height: 2px;\n  --indicator-transition: transform 250ms cubic-bezier(0.4, 0, 0.2, 1);\n  --indicator-transform: none;\n  --padding-top: 0;\n  --padding-end: 16px;\n  --padding-bottom: 0;\n  --padding-start: 16px;\n  --transition: color 0.15s linear 0s, opacity 0.15s linear 0s;\n  min-width: 90px;\n  min-height: 48px;\n  border-width: var(--border-width);\n  border-style: var(--border-style);\n  border-color: var(--border-color);\n  font-size: 14px;\n  font-weight: 500;\n  letter-spacing: 0.06em;\n  line-height: 40px;\n  text-transform: uppercase;\n}\n\n:host(.segment-button-disabled) {\n  opacity: 0.3;\n}\n\n:host(.in-segment-color) {\n  background: none;\n  color: rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.6);\n}\n\n:host(.in-segment-color) ion-ripple-effect {\n  color: var(--ion-color-base);\n}\n\n:host(.in-segment-color) .segment-button-indicator-background {\n  background: var(--ion-color-base);\n}\n\n:host(.in-segment-color.segment-button-checked) .button-native {\n  color: var(--ion-color-base);\n}\n\n:host(.in-segment-color.ion-focused) .button-native::after {\n  background: var(--ion-color-base);\n}\n\n@media (any-hover: hover) {\n  :host(.in-segment-color:hover) .button-native {\n    color: rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.6);\n  }\n  :host(.in-segment-color:hover) .button-native::after {\n    background: var(--ion-color-base);\n  }\n  :host(.in-segment-color.segment-button-checked:hover) .button-native {\n    color: var(--ion-color-base);\n  }\n}\n:host(.in-toolbar:not(.in-segment-color)) {\n  --background: var(--ion-toolbar-segment-background, none);\n  --background-checked: var(--ion-toolbar-segment-background-checked, none);\n  --color: var(--ion-toolbar-segment-color, rgba(var(--ion-text-color-rgb, 0, 0, 0), 0.6));\n  --color-checked: var(--ion-toolbar-segment-color-checked, var(--ion-color-primary, #0054e9));\n  --indicator-color: var(--ion-toolbar-segment-color-checked, var(--color-checked));\n}\n\n:host(.in-toolbar-color:not(.in-segment-color)) .button-native {\n  color: rgba(var(--ion-color-contrast-rgb), 0.6);\n}\n\n:host(.in-toolbar-color.segment-button-checked:not(.in-segment-color)) .button-native {\n  color: var(--ion-color-contrast);\n}\n\n@media (any-hover: hover) {\n  :host(.in-toolbar-color:not(.in-segment-color)) .button-native::after {\n    background: var(--ion-color-contrast);\n  }\n}\n::slotted(ion-icon) {\n  margin-top: 12px;\n  margin-bottom: 12px;\n  font-size: 24px;\n}\n\n::slotted(ion-label) {\n  margin-top: 12px;\n  margin-bottom: 12px;\n}\n\n:host(.segment-button-layout-icon-top) ::slotted(ion-label),\n:host(.segment-button-layout-icon-bottom) ::slotted(ion-icon) {\n  margin-top: 0;\n}\n\n:host(.segment-button-layout-icon-top) ::slotted(ion-icon),\n:host(.segment-button-layout-icon-bottom) ::slotted(ion-label) {\n  margin-bottom: 0;\n}\n\n:host(.segment-button-layout-icon-start) ::slotted(ion-label) {\n  -webkit-margin-start: 8px;\n  margin-inline-start: 8px;\n  -webkit-margin-end: 0;\n  margin-inline-end: 0;\n}\n\n:host(.segment-button-layout-icon-end) ::slotted(ion-label) {\n  -webkit-margin-start: 0;\n  margin-inline-start: 0;\n  -webkit-margin-end: 8px;\n  margin-inline-end: 8px;\n}\n\n:host(.segment-button-has-icon-only) ::slotted(ion-icon) {\n  margin-top: 12px;\n  margin-bottom: 12px;\n}\n\n:host(.segment-button-has-label-only) ::slotted(ion-label) {\n  margin-top: 12px;\n  margin-bottom: 12px;\n}\n\n.segment-button-indicator {\n  left: 0;\n  right: 0;\n  bottom: 0;\n}\n\n.segment-button-indicator-background {\n  background: var(--indicator-color);\n}\n\n:host(.in-toolbar:not(.in-segment-color)) .segment-button-indicator-background {\n  background: var(--ion-toolbar-segment-indicator-color, var(--indicator-color));\n}\n\n:host(.in-toolbar-color:not(.in-segment-color)) .segment-button-indicator-background {\n  background: var(--ion-color-contrast);\n}","/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { Host, forceUpdate, h } from \"@stencil/core\";\nimport { addEventListener, removeEventListener, inheritAttributes } from \"../../utils/helpers\";\nimport { hostContext } from \"../../utils/theme\";\nimport { getIonMode } from \"../../global/ionic-global\";\nlet ids = 0;\n/**\n * @virtualProp {\"ios\" | \"md\"} mode - The mode determines which platform styles to use.\n *\n * @part native - The native HTML button element that wraps all child elements.\n * @part indicator - The indicator displayed on the checked segment button.\n * @part indicator-background - The background element for the indicator displayed on the checked segment button.\n */\nexport class SegmentButton {\n    constructor() {\n        this.segmentEl = null;\n        this.inheritedAttributes = {};\n        this.updateStyle = () => {\n            forceUpdate(this);\n        };\n        this.updateState = () => {\n            const { segmentEl } = this;\n            if (segmentEl) {\n                this.checked = segmentEl.value === this.value;\n                if (segmentEl.disabled) {\n                    this.disabled = true;\n                }\n            }\n        };\n        this.checked = false;\n        this.disabled = false;\n        this.layout = 'icon-top';\n        this.type = 'button';\n        this.value = 'ion-sb-' + ids++;\n    }\n    valueChanged() {\n        this.updateState();\n    }\n    connectedCallback() {\n        const segmentEl = (this.segmentEl = this.el.closest('ion-segment'));\n        if (segmentEl) {\n            this.updateState();\n            addEventListener(segmentEl, 'ionSelect', this.updateState);\n            addEventListener(segmentEl, 'ionStyle', this.updateStyle);\n        }\n    }\n    disconnectedCallback() {\n        const segmentEl = this.segmentEl;\n        if (segmentEl) {\n            removeEventListener(segmentEl, 'ionSelect', this.updateState);\n            removeEventListener(segmentEl, 'ionStyle', this.updateStyle);\n            this.segmentEl = null;\n        }\n    }\n    componentWillLoad() {\n        this.inheritedAttributes = Object.assign({}, inheritAttributes(this.el, ['aria-label']));\n    }\n    get hasLabel() {\n        return !!this.el.querySelector('ion-label');\n    }\n    get hasIcon() {\n        return !!this.el.querySelector('ion-icon');\n    }\n    /**\n     * @internal\n     * Focuses the native <button> element\n     * inside of ion-segment-button.\n     */\n    async setFocus() {\n        const { nativeEl } = this;\n        if (nativeEl !== undefined) {\n            nativeEl.focus();\n        }\n    }\n    render() {\n        const { checked, type, disabled, hasIcon, hasLabel, layout, segmentEl } = this;\n        const mode = getIonMode(this);\n        const hasSegmentColor = () => (segmentEl === null || segmentEl === void 0 ? void 0 : segmentEl.color) !== undefined;\n        return (h(Host, { key: '70cf5c7a3ae2620222c5250c644faf3cfc3b3e4e', class: {\n                [mode]: true,\n                'in-toolbar': hostContext('ion-toolbar', this.el),\n                'in-toolbar-color': hostContext('ion-toolbar[color]', this.el),\n                'in-segment': hostContext('ion-segment', this.el),\n                'in-segment-color': hasSegmentColor(),\n                'segment-button-has-label': hasLabel,\n                'segment-button-has-icon': hasIcon,\n                'segment-button-has-label-only': hasLabel && !hasIcon,\n                'segment-button-has-icon-only': hasIcon && !hasLabel,\n                'segment-button-disabled': disabled,\n                'segment-button-checked': checked,\n                [`segment-button-layout-${layout}`]: true,\n                'ion-activatable': true,\n                'ion-activatable-instant': true,\n                'ion-focusable': true,\n            } }, h(\"button\", Object.assign({ key: 'a53c9f1e360934e8d2e90476642ba4507fc38ebd', \"aria-selected\": checked ? 'true' : 'false', role: \"tab\", ref: (el) => (this.nativeEl = el), type: type, class: \"button-native\", part: \"native\", disabled: disabled }, this.inheritedAttributes), h(\"span\", { key: '7d8feda840d389941cc693f500b5eba0b39b41da', class: \"button-inner\" }, h(\"slot\", { key: 'd9ae1eec45db253cbf573d29cd545658dd595d87' })), mode === 'md' && h(\"ion-ripple-effect\", { key: '49e6a16968709dc9b3fc77bc9fb99acb42fda88c' })), h(\"div\", { key: '4e3ea0989ed5205dbb03586e4facb439b05a92de', part: \"indicator\", class: {\n                'segment-button-indicator': true,\n                'segment-button-indicator-animated': true,\n            } }, h(\"div\", { key: '65c72a151080998c1e548c87d4d4ebd5c7dda72f', part: \"indicator-background\", class: \"segment-button-indicator-background\" }))));\n    }\n    static get is() { return \"ion-segment-button\"; }\n    static get encapsulation() { return \"shadow\"; }\n    static get originalStyleUrls() {\n        return {\n            \"ios\": [\"segment-button.ios.scss\"],\n            \"md\": [\"segment-button.md.scss\"]\n        };\n    }\n    static get styleUrls() {\n        return {\n            \"ios\": [\"segment-button.ios.css\"],\n            \"md\": [\"segment-button.md.css\"]\n        };\n    }\n    static get properties() {\n        return {\n            \"disabled\": {\n                \"type\": \"boolean\",\n                \"mutable\": true,\n                \"complexType\": {\n                    \"original\": \"boolean\",\n                    \"resolved\": \"boolean\",\n                    \"references\": {}\n                },\n                \"required\": false,\n                \"optional\": false,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"If `true`, the user cannot interact with the segment button.\"\n                },\n                \"attribute\": \"disabled\",\n                \"reflect\": false,\n                \"defaultValue\": \"false\"\n            },\n            \"layout\": {\n                \"type\": \"string\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"SegmentButtonLayout\",\n                    \"resolved\": \"\\\"icon-bottom\\\" | \\\"icon-end\\\" | \\\"icon-hide\\\" | \\\"icon-start\\\" | \\\"icon-top\\\" | \\\"label-hide\\\" | undefined\",\n                    \"references\": {\n                        \"SegmentButtonLayout\": {\n                            \"location\": \"import\",\n                            \"path\": \"./segment-button-interface\",\n                            \"id\": \"src/components/segment-button/segment-button-interface.ts::SegmentButtonLayout\"\n                        }\n                    }\n                },\n                \"required\": false,\n                \"optional\": true,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"Set the layout of the text and icon in the segment.\"\n                },\n                \"attribute\": \"layout\",\n                \"reflect\": false,\n                \"defaultValue\": \"'icon-top'\"\n            },\n            \"type\": {\n                \"type\": \"string\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"'submit' | 'reset' | 'button'\",\n                    \"resolved\": \"\\\"button\\\" | \\\"reset\\\" | \\\"submit\\\"\",\n                    \"references\": {}\n                },\n                \"required\": false,\n                \"optional\": false,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"The type of the button.\"\n                },\n                \"attribute\": \"type\",\n                \"reflect\": false,\n                \"defaultValue\": \"'button'\"\n            },\n            \"value\": {\n                \"type\": \"any\",\n                \"mutable\": false,\n                \"complexType\": {\n                    \"original\": \"SegmentValue\",\n                    \"resolved\": \"number | string\",\n                    \"references\": {\n                        \"SegmentValue\": {\n                            \"location\": \"import\",\n                            \"path\": \"../segment/segment-interface\",\n                            \"id\": \"src/components/segment/segment-interface.ts::SegmentValue\"\n                        }\n                    }\n                },\n                \"required\": false,\n                \"optional\": false,\n                \"docs\": {\n                    \"tags\": [],\n                    \"text\": \"The value of the segment button.\"\n                },\n                \"attribute\": \"value\",\n                \"reflect\": false,\n                \"defaultValue\": \"'ion-sb-' + ids++\"\n            }\n        };\n    }\n    static get states() {\n        return {\n            \"checked\": {}\n        };\n    }\n    static get methods() {\n        return {\n            \"setFocus\": {\n                \"complexType\": {\n                    \"signature\": \"() => Promise<void>\",\n                    \"parameters\": [],\n                    \"references\": {\n                        \"Promise\": {\n                            \"location\": \"global\",\n                            \"id\": \"global::Promise\"\n                        }\n                    },\n                    \"return\": \"Promise<void>\"\n                },\n                \"docs\": {\n                    \"text\": \"\",\n                    \"tags\": [{\n                            \"name\": \"internal\",\n                            \"text\": \"Focuses the native <button> element\\ninside of ion-segment-button.\"\n                        }]\n                }\n            }\n        };\n    }\n    static get elementRef() { return \"el\"; }\n    static get watchers() {\n        return [{\n                \"propName\": \"value\",\n                \"methodName\": \"valueChanged\"\n            }];\n    }\n}\n"],"mappings":"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","ignoreList":[]}