{"version":3,"names":["tzTokenizeDate","date","timeZone","dtf","getDateTimeFormat","partsOffset","hackyOffset","typeToPos","year","month","day","hour","minute","second","formatted","formatToParts","filled","i","length","pos","type","undefined","parseInt","value","error","RangeError","NaN","format","parsed","exec","dtfCache","testDateFormatted","Intl","DateTimeFormat","hourCycle","Date","hourCycleSupported","hour12","newDateUTC","fullYear","millisecond","utcDate","setUTCFullYear","setUTCHours","MILLISECONDS_IN_HOUR","MILLISECONDS_IN_MINUTE","patterns","timezone","timezoneZ","timezoneHH","timezoneHHMM","tzParseTimezone","timezoneString","isUtcDate","token","hours","absoluteOffset","validateTimezone","minutes","Math","abs","isValidTimezoneIANAString","now","toUtcDate","offset","calcOffset","fixedOffset","fixOffset","getFullYear","getMonth","getDate","getHours","getMinutes","getSeconds","getMilliseconds","tokens","asUTC","getTime","asTS","over","localTS","utcGuess","o2","o3","max","validIANATimezoneCache","timeZoneString","getTimezoneOffsetInMilliseconds","UTC","tzPattern","DEFAULT_ADDITIONAL_DIGITS","dateTimePattern","datePattern","plainTime","YY","YYY","YYYY","YYYYY","MM","DDD","MMDD","Www","WwwD","HH","HHMM","HHMMSS","toDate","argument","options","arguments","TypeError","additionalDigits","Number","Object","prototype","toString","call","dateStrings","splitDateString","restDateString","parseYear","parseDate","isNaN","timestamp","time","parseTime","dateString","parts","timeString","replace","trim","patternYYY","patternYYYYY","yearString","slice","centuryString","week","validateDate","dayOfYear","validateDayOfYearDate","validateWeekDate","dayOfISOWeekYear","dayOfWeek","parseFloat","validateTime","seconds","isoWeekYear","fourthOfJanuaryDay","getUTCDay","diff","setUTCDate","getUTCDate","DAYS_IN_MONTH","DAYS_IN_MONTH_LEAP_YEAR","isLeapYearIndex","isLeapYear","toZonedTime","offsetMilliseconds","d","resultDate","setFullYear","getUTCFullYear","getUTCMonth","setHours","getUTCHours","getUTCMinutes","getUTCSeconds","getUTCMilliseconds","MASKITO_DEFAULT_OPTIONS","mask","preprocessors","postprocessors","plugins","overwriteMode","MaskHistory","constructor","this","past","future","undo","state","pop","push","updateElement","redo","updateHistory","isValueChanged","isSelectionChanged","selection","some","item","index","inputType","updateElementState","data","areElementValuesEqual","sampleState","states","every","areElementStatesEqual","applyOverwriteMode","newCharacters","mode","from","to","computedMode","isFixedCharacter","char","getLeadingFixedCharacters","validatedValuePart","newCharacter","initialElementState","leadingFixedCharacters","charConstraint","isInitiallyExisted","validateValueWithMask","maskExpression","Array","isArray","match","test","guessValidValueByPattern","elementState","maskedFrom","maskedTo","maskedValue","reduce","validatedCharacters","charIndex","leadingCharacters","newValidatedChars","trailingFixedCharacters","guessValidValueByRegExp","maskRegExp","newFrom","newTo","validatedValue","newPossibleValue","calibrateValueByMask","removeFixedMaskCharacters","unmaskedValue","rawValue","fill","MaskModel","maskOptions","getMaskExpression","addCharacters","unmaskedElementState","unmaskedFrom","unmaskedTo","newUnmaskedLeadingValuePart","newCaretIndex","maskedElementState","isInvalidCharsInsertion","Error","deleteCharacters","newUnmaskedValue","EventListener","element","listeners","listen","eventType","fn","untypedFn","addEventListener","removeEventListener","destroy","forEach","stopListen","HotkeyModifier","CTRL","ALT","SHIFT","META","HotkeyCode","Y","Z","isHotkey","event","modifiers","hotkeyCode","ctrlKey","altKey","shiftKey","metaKey","keyCode","isRedo","isUndo","maskitoUpdateElement","valueOrElementState","_a","initialValue","matches","setSelectionRange","dispatchEvent","Event","bubbles","getLineSelection","isForward","nearestBreak","indexOf","lastIndexOf","selectFrom","selectTo","getNotEmptySelection","notEmptySelection","map","x","min","TRAILING_SPACES_REG","LEADING_SPACES_REG","SPACE_REG","getWordSelection","valueAfterSelectionStart","leadingSpaces","nearestWordEndIndex","trimStart","search","valueBeforeSelectionEnd","trailingSpaces","selectedWordLength","trimEnd","split","reverse","findIndex","maskitoPipe","processors","initialData","readonlyArgs","assign","maskitoTransform","valueOrState","maskitoOptions","preprocessor","postprocessor","maskModel","Maskito","super","isTextArea","nodeName","eventListener","teardowns","plugin","preventDefault","includes","handleDelete","force","handleEnter","handleInsert","dataTransfer","getData","ensureValueFitsMask","selectionStart","selectionEnd","maxLength","Infinity","teardown","eventInit","updateValue","updateSelectionRange","dispatchInputEvent","globalThis","InputEvent","cancelable","initialState","initialFrom","initialTo","newElementState","isContentEditable","insertedText","clamp","clampedValue","countDigits","str","replaceAll","getDateSegmentValueLength","_b","_c","dateToSegments","String","padStart","milliseconds","getFirstCompleteDate","dateModeTemplate","digitsInDate","completeDate","RegExp","isDateStringComplete","segment","parseDateRangeString","dateRange","rangeSeparator","parseDateString","fullMode","cleanMode","onlyDigitsDate","dateSegments","fromEntries","entries","filter","_","Boolean","sort","a","b","toLowerCase","segmentsToDate","parsedDate","parsedTime","_d","_e","_f","_g","DATE_TIME_SEPARATOR","toDateString","dateMode","dateTimeSeparator","timeMode","safeYear","DATE_SEGMENTS_MAX_VALUES","DEFAULT_MIN_DATE","DEFAULT_MAX_DATE","DEFAULT_TIME_SEGMENT_MAX_VALUES","TIME_FIXED_CHARACTERS","TIME_SEGMENT_VALUE_LENGTHS","CHAR_COLON","CHAR_JP_COLON","validateDateString","dateSegmentsSeparator","validatedDateSegments","segmentName","segmentValue","validatedDate","maxSegmentValue","fantomSeparator","lastSegmentDigitIndex","isLastSegmentDigitAdded","validatedDateString","updatedSelection","addedDateSegmentSeparators","reRegExpChar","reHasRegExpChar","source","escapeRegExp","raw","ALL_ZEROES_RE","padWithZeroesUntilValid","paddedMaxValue","prefixedZeroesCount","paddedSegmentValue","padEnd","validatedSegmentValue","endsWith","valueWithoutLastChar","toHalfWidthColon","fullWidthColon","toHalfWidthNumber","fullWidthNumber","s","fromCharCode","charCodeAt","createColonConvertPreprocessor","createDateSegmentsZeroPaddingPostprocessor","dateSegmentSeparator","splitFn","uniteFn","restPart","validatedDateStrings","caretShift","acc","createFirstDateEndSeparatorPreprocessor","firstDateEndSeparator","pseudoFirstDateEndSeparators","firstCompleteDate","pseudoSeparators","pseudoSeparatorsRE","join","createFullWidthToHalfWidthPreprocessor","raiseSegmentValueToMin","segments","segmentsLength","key","segmentLength","createMinMaxDatePostprocessor","endsWithRangeSeparator","fixedDate","fixedValue","tail","clampedDate","normalizeDatePreprocessor","separator","possibleDates","dates","newData","normalizeDateString","template","templateSegments","normalizedSegments","createValidDatePreprocessor","rawTo","hasRangeSeparator","repeat","noop","createTimeSegmentsSteppingPlugin","step","timeSegmentMaxValues","segmentsIndexes","createTimeSegmentsIndexes","listener","activeSegment","getActiveSegment","updatedValue","updateSegmentValue","get","toAdd","Map","getSegmentRange","segmentRange","newSegmentValue","mod","floor","createZeroPlaceholdersPreprocessor","actionType","isLastChar","zeroes","newValue","maskitoDateOptionsGenerator","padTimeSegments","timeSegments","pad","padStartTimeSegments","SEGMENT_FULL_NAME","SS","MSS","parseTimeString","onlyDigits","segmentAbbr","LEADING_NON_DIGITS","TRAILING_NON_DIGITS","toTimeString","TRAILING_TIME_SEGMENT_SEPARATOR_REG","validateTimeString","paddedMaxValues","possibleTimeSegments","validatedTimeSegments","paddedZeroes","validatedTime","validatedTimeString","updatedTimeSelection","trailingSegmentSeparator","isDateTimeStringComplete","dateTimeString","parseDateTimeString","dateTime","hasSeparator","createMinMaxDateTimePostprocessor","createValidDateTimePreprocessor","invalidCharsRegExp","hasDateTimeSeparator","maskitoDateTimeOptionsGenerator","dateSeparator","timeStep","popoverSelectDateCss","PopoverSelectDateStyle0","PopoverSelectDate","componentWillLoad","targetTimeZone","resolvedOptions","setLocalTime","popover","el","closest","componentDidLoad","initializeMask","disconnectedCallback","maskedInput","localTime","inputValue","showDate","formatISO","datePresentation","updateView","optionsDate","optionsDateTime","ionInput","document","querySelector","nativeEl","getInputElement","handleChange","ev","detail","handleInputChange","inputDate","target","parse","isValid","close","dismiss","save","formatDate","render","h","Host","color","Environment","getAppColor","presentation","preferWheel","showDateTitle","onIonChange","maxDate","slot","labelTag","tag","text","labelText","labelReplace","appendText","id","debounce","inputmode","onIonInput","onCancelEmit","onSaveEmit"],"sources":["node_modules/date-fns-tz/dist/esm/_lib/tzTokenizeDate/index.js","node_modules/date-fns-tz/dist/esm/_lib/newDateUTC/index.js","node_modules/date-fns-tz/dist/esm/_lib/tzParseTimezone/index.js","node_modules/date-fns-tz/dist/esm/_lib/getTimezoneOffsetInMilliseconds/index.js","node_modules/date-fns-tz/dist/esm/_lib/tzPattern/index.js","node_modules/date-fns-tz/dist/esm/toDate/index.js","node_modules/date-fns-tz/dist/esm/toZonedTime/index.js","node_modules/@maskito/core/index.esm.js","node_modules/@maskito/kit/index.esm.js","src/components/common/popovers/popover-select-date/popover-select-date.scss?tag=popover-select-date","src/components/common/popovers/popover-select-date/popover-select-date.tsx"],"sourcesContent":["/**\n * Returns the [year, month, day, hour, minute, seconds] tokens of the provided\n * `date` as it will be rendered in the `timeZone`.\n */\nexport function tzTokenizeDate(date, timeZone) {\n    const dtf = getDateTimeFormat(timeZone);\n    return 'formatToParts' in dtf ? partsOffset(dtf, date) : hackyOffset(dtf, date);\n}\nconst typeToPos = {\n    year: 0,\n    month: 1,\n    day: 2,\n    hour: 3,\n    minute: 4,\n    second: 5,\n};\nfunction partsOffset(dtf, date) {\n    try {\n        const formatted = dtf.formatToParts(date);\n        const filled = [];\n        for (let i = 0; i < formatted.length; i++) {\n            const pos = typeToPos[formatted[i].type];\n            if (pos !== undefined) {\n                filled[pos] = parseInt(formatted[i].value, 10);\n            }\n        }\n        return filled;\n    }\n    catch (error) {\n        if (error instanceof RangeError) {\n            return [NaN];\n        }\n        throw error;\n    }\n}\nfunction hackyOffset(dtf, date) {\n    const formatted = dtf.format(date);\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const parsed = /(\\d+)\\/(\\d+)\\/(\\d+),? (\\d+):(\\d+):(\\d+)/.exec(formatted);\n    // const [, fMonth, fDay, fYear, fHour, fMinute, fSecond] = parsed\n    // return [fYear, fMonth, fDay, fHour, fMinute, fSecond]\n    return [\n        parseInt(parsed[3], 10),\n        parseInt(parsed[1], 10),\n        parseInt(parsed[2], 10),\n        parseInt(parsed[4], 10),\n        parseInt(parsed[5], 10),\n        parseInt(parsed[6], 10),\n    ];\n}\n// Get a cached Intl.DateTimeFormat instance for the IANA `timeZone`. This can be used\n// to get deterministic local date/time output according to the `en-US` locale which\n// can be used to extract local time parts as necessary.\nconst dtfCache = {};\nfunction getDateTimeFormat(timeZone) {\n    if (!dtfCache[timeZone]) {\n        // New browsers use `hourCycle`, IE and Chrome <73 does not support it and uses `hour12`\n        const testDateFormatted = new Intl.DateTimeFormat('en-US', {\n            hourCycle: 'h23',\n            timeZone: 'America/New_York',\n            year: 'numeric',\n            month: '2-digit',\n            day: '2-digit',\n            hour: '2-digit',\n            minute: '2-digit',\n            second: '2-digit',\n        }).format(new Date('2014-06-25T04:00:00.123Z'));\n        const hourCycleSupported = testDateFormatted === '06/25/2014, 00:00:00' ||\n            testDateFormatted === '‎06‎/‎25‎/‎2014‎ ‎00‎:‎00‎:‎00';\n        dtfCache[timeZone] = hourCycleSupported\n            ? new Intl.DateTimeFormat('en-US', {\n                hourCycle: 'h23',\n                timeZone: timeZone,\n                year: 'numeric',\n                month: 'numeric',\n                day: '2-digit',\n                hour: '2-digit',\n                minute: '2-digit',\n                second: '2-digit',\n            })\n            : new Intl.DateTimeFormat('en-US', {\n                hour12: false,\n                timeZone: timeZone,\n                year: 'numeric',\n                month: 'numeric',\n                day: '2-digit',\n                hour: '2-digit',\n                minute: '2-digit',\n                second: '2-digit',\n            });\n    }\n    return dtfCache[timeZone];\n}\n","/**\n * Use instead of `new Date(Date.UTC(...))` to support years below 100 which doesn't work\n * otherwise due to the nature of the\n * [`Date` constructor](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date#interpretation_of_two-digit_years.\n *\n * For `Date.UTC(...)`, use `newDateUTC(...).getTime()`.\n */\nexport function newDateUTC(fullYear, month, day, hour, minute, second, millisecond) {\n    const utcDate = new Date(0);\n    utcDate.setUTCFullYear(fullYear, month, day);\n    utcDate.setUTCHours(hour, minute, second, millisecond);\n    return utcDate;\n}\n","import { tzTokenizeDate } from '../tzTokenizeDate/index.js';\nimport { newDateUTC } from '../newDateUTC/index.js';\nconst MILLISECONDS_IN_HOUR = 3600000;\nconst MILLISECONDS_IN_MINUTE = 60000;\nconst patterns = {\n    timezone: /([Z+-].*)$/,\n    timezoneZ: /^(Z)$/,\n    timezoneHH: /^([+-]\\d{2})$/,\n    timezoneHHMM: /^([+-])(\\d{2}):?(\\d{2})$/,\n};\n// Parse constious time zone offset formats to an offset in milliseconds\nexport function tzParseTimezone(timezoneString, date, isUtcDate) {\n    // Empty string\n    if (!timezoneString) {\n        return 0;\n    }\n    // Z\n    let token = patterns.timezoneZ.exec(timezoneString);\n    if (token) {\n        return 0;\n    }\n    let hours;\n    let absoluteOffset;\n    // ±hh\n    token = patterns.timezoneHH.exec(timezoneString);\n    if (token) {\n        hours = parseInt(token[1], 10);\n        if (!validateTimezone(hours)) {\n            return NaN;\n        }\n        return -(hours * MILLISECONDS_IN_HOUR);\n    }\n    // ±hh:mm or ±hhmm\n    token = patterns.timezoneHHMM.exec(timezoneString);\n    if (token) {\n        hours = parseInt(token[2], 10);\n        const minutes = parseInt(token[3], 10);\n        if (!validateTimezone(hours, minutes)) {\n            return NaN;\n        }\n        absoluteOffset = Math.abs(hours) * MILLISECONDS_IN_HOUR + minutes * MILLISECONDS_IN_MINUTE;\n        return token[1] === '+' ? -absoluteOffset : absoluteOffset;\n    }\n    // IANA time zone\n    if (isValidTimezoneIANAString(timezoneString)) {\n        date = new Date(date || Date.now());\n        const utcDate = isUtcDate ? date : toUtcDate(date);\n        const offset = calcOffset(utcDate, timezoneString);\n        const fixedOffset = isUtcDate ? offset : fixOffset(date, offset, timezoneString);\n        return -fixedOffset;\n    }\n    return NaN;\n}\nfunction toUtcDate(date) {\n    return newDateUTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());\n}\nfunction calcOffset(date, timezoneString) {\n    const tokens = tzTokenizeDate(date, timezoneString);\n    // ms dropped because it's not provided by tzTokenizeDate\n    const asUTC = newDateUTC(tokens[0], tokens[1] - 1, tokens[2], tokens[3] % 24, tokens[4], tokens[5], 0).getTime();\n    let asTS = date.getTime();\n    const over = asTS % 1000;\n    asTS -= over >= 0 ? over : 1000 + over;\n    return asUTC - asTS;\n}\nfunction fixOffset(date, offset, timezoneString) {\n    const localTS = date.getTime();\n    // Our UTC time is just a guess because our offset is just a guess\n    let utcGuess = localTS - offset;\n    // Test whether the zone matches the offset for this ts\n    const o2 = calcOffset(new Date(utcGuess), timezoneString);\n    // If so, offset didn't change, and we're done\n    if (offset === o2) {\n        return offset;\n    }\n    // If not, change the ts by the difference in the offset\n    utcGuess -= o2 - offset;\n    // If that gives us the local time we want, we're done\n    const o3 = calcOffset(new Date(utcGuess), timezoneString);\n    if (o2 === o3) {\n        return o2;\n    }\n    // If it's different, we're in a hole time. The offset has changed, but we don't adjust the time\n    return Math.max(o2, o3);\n}\nfunction validateTimezone(hours, minutes) {\n    return -23 <= hours && hours <= 23 && (minutes == null || (0 <= minutes && minutes <= 59));\n}\nconst validIANATimezoneCache = {};\nfunction isValidTimezoneIANAString(timeZoneString) {\n    if (validIANATimezoneCache[timeZoneString])\n        return true;\n    try {\n        new Intl.DateTimeFormat(undefined, { timeZone: timeZoneString });\n        validIANATimezoneCache[timeZoneString] = true;\n        return true;\n    }\n    catch (error) {\n        return false;\n    }\n}\n","/**\n * Google Chrome as of 67.0.3396.87 introduced timezones with offset that includes seconds.\n * They usually appear for dates that denote time before the timezones were introduced\n * (e.g. for 'Europe/Prague' timezone the offset is GMT+00:57:44 before 1 October 1891\n * and GMT+01:00:00 after that date)\n *\n * Date#getTimezoneOffset returns the offset in minutes and would return 57 for the example above,\n * which would lead to incorrect calculations.\n *\n * This function returns the timezone offset in milliseconds that takes seconds in account.\n */\nexport function getTimezoneOffsetInMilliseconds(date) {\n    const utcDate = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));\n    utcDate.setUTCFullYear(date.getFullYear());\n    return +date - +utcDate;\n}\n","/** Regex to identify the presence of a time zone specifier in a date string */\nexport const tzPattern = /(Z|[+-]\\d{2}(?::?\\d{2})?| UTC| [a-zA-Z]+\\/[a-zA-Z_]+(?:\\/[a-zA-Z_]+)?)$/;\n","import { getTimezoneOffsetInMilliseconds } from '../_lib/getTimezoneOffsetInMilliseconds/index.js';\nimport { tzParseTimezone } from '../_lib/tzParseTimezone/index.js';\nimport { tzPattern } from '../_lib/tzPattern/index.js';\nconst MILLISECONDS_IN_HOUR = 3600000;\nconst MILLISECONDS_IN_MINUTE = 60000;\nconst DEFAULT_ADDITIONAL_DIGITS = 2;\nconst patterns = {\n    dateTimePattern: /^([0-9W+-]+)(T| )(.*)/,\n    datePattern: /^([0-9W+-]+)(.*)/,\n    plainTime: /:/,\n    // year tokens\n    YY: /^(\\d{2})$/,\n    YYY: [\n        /^([+-]\\d{2})$/, // 0 additional digits\n        /^([+-]\\d{3})$/, // 1 additional digit\n        /^([+-]\\d{4})$/, // 2 additional digits\n    ],\n    YYYY: /^(\\d{4})/,\n    YYYYY: [\n        /^([+-]\\d{4})/, // 0 additional digits\n        /^([+-]\\d{5})/, // 1 additional digit\n        /^([+-]\\d{6})/, // 2 additional digits\n    ],\n    // date tokens\n    MM: /^-(\\d{2})$/,\n    DDD: /^-?(\\d{3})$/,\n    MMDD: /^-?(\\d{2})-?(\\d{2})$/,\n    Www: /^-?W(\\d{2})$/,\n    WwwD: /^-?W(\\d{2})-?(\\d{1})$/,\n    HH: /^(\\d{2}([.,]\\d*)?)$/,\n    HHMM: /^(\\d{2}):?(\\d{2}([.,]\\d*)?)$/,\n    HHMMSS: /^(\\d{2}):?(\\d{2}):?(\\d{2}([.,]\\d*)?)$/,\n    // time zone tokens (to identify the presence of a tz)\n    timeZone: tzPattern,\n};\n/**\n * @name toDate\n * @category Common Helpers\n * @summary Convert the given argument to an instance of Date.\n *\n * @description\n * Convert the given argument to an instance of Date.\n *\n * If the argument is an instance of Date, the function returns its clone.\n *\n * If the argument is a number, it is treated as a timestamp.\n *\n * If an argument is a string, the function tries to parse it.\n * Function accepts complete ISO 8601 formats as well as partial implementations.\n * ISO 8601: http://en.wikipedia.org/wiki/ISO_8601\n * If the function cannot parse the string or the values are invalid, it returns Invalid Date.\n *\n * If the argument is none of the above, the function returns Invalid Date.\n *\n * **Note**: *all* Date arguments passed to any *date-fns* function is processed by `toDate`.\n * All *date-fns* functions will throw `RangeError` if `options.additionalDigits` is not 0, 1, 2 or undefined.\n *\n * @param argument the value to convert\n * @param options the object with options. See [Options]{@link https://date-fns.org/docs/Options}\n * @param {0|1|2} [options.additionalDigits=2] - the additional number of digits in the extended year format\n * @param {string} [options.timeZone=''] - used to specify the IANA time zone offset of a date String.\n *\n * @returns the parsed date in the local time zone\n * @throws {TypeError} 1 argument required\n * @throws {RangeError} `options.additionalDigits` must be 0, 1 or 2\n *\n * @example\n * // Convert string '2014-02-11T11:30:30' to date:\n * const result = toDate('2014-02-11T11:30:30')\n * //=> Tue Feb 11 2014 11:30:30\n *\n * @example\n * // Convert string '+02014101' to date,\n * // if the additional number of digits in the extended year format is 1:\n * const result = toDate('+02014101', {additionalDigits: 1})\n * //=> Fri Apr 11 2014 00:00:00\n */\nexport function toDate(argument, options = {}) {\n    if (arguments.length < 1) {\n        throw new TypeError('1 argument required, but only ' + arguments.length + ' present');\n    }\n    if (argument === null) {\n        return new Date(NaN);\n    }\n    const additionalDigits = options.additionalDigits == null ? DEFAULT_ADDITIONAL_DIGITS : Number(options.additionalDigits);\n    if (additionalDigits !== 2 && additionalDigits !== 1 && additionalDigits !== 0) {\n        throw new RangeError('additionalDigits must be 0, 1 or 2');\n    }\n    // Clone the date\n    if (argument instanceof Date ||\n        (typeof argument === 'object' && Object.prototype.toString.call(argument) === '[object Date]')) {\n        // Prevent the date to lose the milliseconds when passed to new Date() in IE10\n        return new Date(argument.getTime());\n    }\n    else if (typeof argument === 'number' ||\n        Object.prototype.toString.call(argument) === '[object Number]') {\n        return new Date(argument);\n    }\n    else if (!(Object.prototype.toString.call(argument) === '[object String]')) {\n        return new Date(NaN);\n    }\n    const dateStrings = splitDateString(argument);\n    const { year, restDateString } = parseYear(dateStrings.date, additionalDigits);\n    const date = parseDate(restDateString, year);\n    if (date === null || isNaN(date.getTime())) {\n        return new Date(NaN);\n    }\n    if (date) {\n        const timestamp = date.getTime();\n        let time = 0;\n        let offset;\n        if (dateStrings.time) {\n            time = parseTime(dateStrings.time);\n            if (time === null || isNaN(time)) {\n                return new Date(NaN);\n            }\n        }\n        if (dateStrings.timeZone || options.timeZone) {\n            offset = tzParseTimezone(dateStrings.timeZone || options.timeZone, new Date(timestamp + time));\n            if (isNaN(offset)) {\n                return new Date(NaN);\n            }\n        }\n        else {\n            // get offset accurate to hour in time zones that change offset\n            offset = getTimezoneOffsetInMilliseconds(new Date(timestamp + time));\n            offset = getTimezoneOffsetInMilliseconds(new Date(timestamp + time + offset));\n        }\n        return new Date(timestamp + time + offset);\n    }\n    else {\n        return new Date(NaN);\n    }\n}\nfunction splitDateString(dateString) {\n    const dateStrings = {};\n    let parts = patterns.dateTimePattern.exec(dateString);\n    let timeString;\n    if (!parts) {\n        parts = patterns.datePattern.exec(dateString);\n        if (parts) {\n            dateStrings.date = parts[1];\n            timeString = parts[2];\n        }\n        else {\n            dateStrings.date = null;\n            timeString = dateString;\n        }\n    }\n    else {\n        dateStrings.date = parts[1];\n        timeString = parts[3];\n    }\n    if (timeString) {\n        const token = patterns.timeZone.exec(timeString);\n        if (token) {\n            dateStrings.time = timeString.replace(token[1], '');\n            dateStrings.timeZone = token[1].trim();\n        }\n        else {\n            dateStrings.time = timeString;\n        }\n    }\n    return dateStrings;\n}\nfunction parseYear(dateString, additionalDigits) {\n    if (dateString) {\n        const patternYYY = patterns.YYY[additionalDigits];\n        const patternYYYYY = patterns.YYYYY[additionalDigits];\n        // YYYY or ±YYYYY\n        let token = patterns.YYYY.exec(dateString) || patternYYYYY.exec(dateString);\n        if (token) {\n            const yearString = token[1];\n            return {\n                year: parseInt(yearString, 10),\n                restDateString: dateString.slice(yearString.length),\n            };\n        }\n        // YY or ±YYY\n        token = patterns.YY.exec(dateString) || patternYYY.exec(dateString);\n        if (token) {\n            const centuryString = token[1];\n            return {\n                year: parseInt(centuryString, 10) * 100,\n                restDateString: dateString.slice(centuryString.length),\n            };\n        }\n    }\n    // Invalid ISO-formatted year\n    return {\n        year: null,\n    };\n}\nfunction parseDate(dateString, year) {\n    // Invalid ISO-formatted year\n    if (year === null) {\n        return null;\n    }\n    let date;\n    let month;\n    let week;\n    // YYYY\n    if (!dateString || !dateString.length) {\n        date = new Date(0);\n        date.setUTCFullYear(year);\n        return date;\n    }\n    // YYYY-MM\n    let token = patterns.MM.exec(dateString);\n    if (token) {\n        date = new Date(0);\n        month = parseInt(token[1], 10) - 1;\n        if (!validateDate(year, month)) {\n            return new Date(NaN);\n        }\n        date.setUTCFullYear(year, month);\n        return date;\n    }\n    // YYYY-DDD or YYYYDDD\n    token = patterns.DDD.exec(dateString);\n    if (token) {\n        date = new Date(0);\n        const dayOfYear = parseInt(token[1], 10);\n        if (!validateDayOfYearDate(year, dayOfYear)) {\n            return new Date(NaN);\n        }\n        date.setUTCFullYear(year, 0, dayOfYear);\n        return date;\n    }\n    // yyyy-MM-dd or YYYYMMDD\n    token = patterns.MMDD.exec(dateString);\n    if (token) {\n        date = new Date(0);\n        month = parseInt(token[1], 10) - 1;\n        const day = parseInt(token[2], 10);\n        if (!validateDate(year, month, day)) {\n            return new Date(NaN);\n        }\n        date.setUTCFullYear(year, month, day);\n        return date;\n    }\n    // YYYY-Www or YYYYWww\n    token = patterns.Www.exec(dateString);\n    if (token) {\n        week = parseInt(token[1], 10) - 1;\n        if (!validateWeekDate(week)) {\n            return new Date(NaN);\n        }\n        return dayOfISOWeekYear(year, week);\n    }\n    // YYYY-Www-D or YYYYWwwD\n    token = patterns.WwwD.exec(dateString);\n    if (token) {\n        week = parseInt(token[1], 10) - 1;\n        const dayOfWeek = parseInt(token[2], 10) - 1;\n        if (!validateWeekDate(week, dayOfWeek)) {\n            return new Date(NaN);\n        }\n        return dayOfISOWeekYear(year, week, dayOfWeek);\n    }\n    // Invalid ISO-formatted date\n    return null;\n}\nfunction parseTime(timeString) {\n    let hours;\n    let minutes;\n    // hh\n    let token = patterns.HH.exec(timeString);\n    if (token) {\n        hours = parseFloat(token[1].replace(',', '.'));\n        if (!validateTime(hours)) {\n            return NaN;\n        }\n        return (hours % 24) * MILLISECONDS_IN_HOUR;\n    }\n    // hh:mm or hhmm\n    token = patterns.HHMM.exec(timeString);\n    if (token) {\n        hours = parseInt(token[1], 10);\n        minutes = parseFloat(token[2].replace(',', '.'));\n        if (!validateTime(hours, minutes)) {\n            return NaN;\n        }\n        return (hours % 24) * MILLISECONDS_IN_HOUR + minutes * MILLISECONDS_IN_MINUTE;\n    }\n    // hh:mm:ss or hhmmss\n    token = patterns.HHMMSS.exec(timeString);\n    if (token) {\n        hours = parseInt(token[1], 10);\n        minutes = parseInt(token[2], 10);\n        const seconds = parseFloat(token[3].replace(',', '.'));\n        if (!validateTime(hours, minutes, seconds)) {\n            return NaN;\n        }\n        return (hours % 24) * MILLISECONDS_IN_HOUR + minutes * MILLISECONDS_IN_MINUTE + seconds * 1000;\n    }\n    // Invalid ISO-formatted time\n    return null;\n}\nfunction dayOfISOWeekYear(isoWeekYear, week, day) {\n    week = week || 0;\n    day = day || 0;\n    const date = new Date(0);\n    date.setUTCFullYear(isoWeekYear, 0, 4);\n    const fourthOfJanuaryDay = date.getUTCDay() || 7;\n    const diff = week * 7 + day + 1 - fourthOfJanuaryDay;\n    date.setUTCDate(date.getUTCDate() + diff);\n    return date;\n}\n// Validation functions\nconst DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\nconst DAYS_IN_MONTH_LEAP_YEAR = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\nfunction isLeapYearIndex(year) {\n    return year % 400 === 0 || (year % 4 === 0 && year % 100 !== 0);\n}\nfunction validateDate(year, month, date) {\n    if (month < 0 || month > 11) {\n        return false;\n    }\n    if (date != null) {\n        if (date < 1) {\n            return false;\n        }\n        const isLeapYear = isLeapYearIndex(year);\n        if (isLeapYear && date > DAYS_IN_MONTH_LEAP_YEAR[month]) {\n            return false;\n        }\n        if (!isLeapYear && date > DAYS_IN_MONTH[month]) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction validateDayOfYearDate(year, dayOfYear) {\n    if (dayOfYear < 1) {\n        return false;\n    }\n    const isLeapYear = isLeapYearIndex(year);\n    if (isLeapYear && dayOfYear > 366) {\n        return false;\n    }\n    if (!isLeapYear && dayOfYear > 365) {\n        return false;\n    }\n    return true;\n}\nfunction validateWeekDate(week, day) {\n    if (week < 0 || week > 52) {\n        return false;\n    }\n    if (day != null && (day < 0 || day > 6)) {\n        return false;\n    }\n    return true;\n}\nfunction validateTime(hours, minutes, seconds) {\n    if (hours < 0 || hours >= 25) {\n        return false;\n    }\n    if (minutes != null && (minutes < 0 || minutes >= 60)) {\n        return false;\n    }\n    if (seconds != null && (seconds < 0 || seconds >= 60)) {\n        return false;\n    }\n    return true;\n}\n","import { tzParseTimezone } from '../_lib/tzParseTimezone/index.js';\nimport { toDate } from '../toDate/index.js';\n/**\n * @name toZonedTime\n * @category Time Zone Helpers\n * @summary Get a date/time representing local time in a given time zone from the UTC date\n *\n * @description\n * Returns a date instance with values representing the local time in the time zone\n * specified of the UTC time from the date provided. In other words, when the new date\n * is formatted it will show the equivalent hours in the target time zone regardless\n * of the current system time zone.\n *\n * @param date the date with the relevant UTC time\n * @param timeZone the time zone to get local time for, can be an offset or IANA time zone\n * @param options the object with options. See [Options]{@link https://date-fns.org/docs/Options}\n * @param {0|1|2} [options.additionalDigits=2] - passed to `toDate`. See [toDate]{@link https://date-fns.org/docs/toDate}\n *\n * @throws {TypeError} 2 arguments required\n * @throws {RangeError} `options.additionalDigits` must be 0, 1 or 2\n *\n * @example\n * // In June 10am UTC is 6am in New York (-04:00)\n * const result = toZonedTime('2014-06-25T10:00:00.000Z', 'America/New_York')\n * //=> Jun 25 2014 06:00:00\n */\nexport function toZonedTime(date, timeZone, options) {\n    date = toDate(date, options);\n    const offsetMilliseconds = tzParseTimezone(timeZone, date, true);\n    const d = new Date(date.getTime() - offsetMilliseconds);\n    const resultDate = new Date(0);\n    resultDate.setFullYear(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate());\n    resultDate.setHours(d.getUTCHours(), d.getUTCMinutes(), d.getUTCSeconds(), d.getUTCMilliseconds());\n    return resultDate;\n}\n","function getContentEditableSelection(element) {\n    const { anchorOffset = 0, focusOffset = 0 } = element.ownerDocument.getSelection() || {};\n    const from = Math.min(anchorOffset, focusOffset);\n    const to = Math.max(anchorOffset, focusOffset);\n    return [from, to];\n}\n\nfunction setContentEditableSelection(element, [from, to]) {\n    var _a, _b;\n    const document = element.ownerDocument;\n    const range = document.createRange();\n    range.setStart(element.firstChild || element, Math.min(from, ((_a = element.textContent) === null || _a === void 0 ? void 0 : _a.length) || 0));\n    range.setEnd(element.lastChild || element, Math.min(to, ((_b = element.textContent) === null || _b === void 0 ? void 0 : _b.length) || 0));\n    const selection = document.getSelection();\n    if (selection) {\n        selection.removeAllRanges();\n        selection.addRange(range);\n    }\n}\n\nclass ContentEditableAdapter {\n    constructor(element) {\n        this.element = element;\n        this.maxLength = Infinity;\n    }\n    get value() {\n        return this.element.innerText.replace(/\\n\\n$/, '\\n');\n    }\n    set value(value) {\n        // Setting into innerHTML of element with `white-space: pre;` style\n        this.element.innerHTML = value.replace(/\\n$/, '\\n\\n');\n    }\n    get selectionStart() {\n        return getContentEditableSelection(this.element)[0];\n    }\n    get selectionEnd() {\n        return getContentEditableSelection(this.element)[1];\n    }\n    setSelectionRange(from, to) {\n        setContentEditableSelection(this.element, [from || 0, to || 0]);\n    }\n    select() {\n        this.setSelectionRange(0, this.value.length);\n    }\n}\nfunction maskitoAdaptContentEditable(element) {\n    const adapter = new ContentEditableAdapter(element);\n    return new Proxy(element, {\n        get(target, prop) {\n            if (prop in adapter) {\n                return adapter[prop];\n            }\n            const nativeProperty = target[prop];\n            return typeof nativeProperty === 'function'\n                ? nativeProperty.bind(target)\n                : nativeProperty;\n        },\n        set(target, prop, val, receiver) {\n            return Reflect.set(prop in adapter ? adapter : target, prop, val, receiver);\n        },\n    });\n}\n\nconst MASKITO_DEFAULT_ELEMENT_PREDICATE = (e) => e.isContentEditable\n    ? maskitoAdaptContentEditable(e)\n    : e.querySelector('input,textarea') ||\n        e;\n\nconst MASKITO_DEFAULT_OPTIONS = {\n    mask: /^.*$/,\n    preprocessors: [],\n    postprocessors: [],\n    plugins: [],\n    overwriteMode: 'shift',\n};\n\nclass MaskHistory {\n    constructor() {\n        this.now = null;\n        this.past = [];\n        this.future = [];\n    }\n    undo() {\n        const state = this.past.pop();\n        if (state && this.now) {\n            this.future.push(this.now);\n            this.updateElement(state, 'historyUndo');\n        }\n    }\n    redo() {\n        const state = this.future.pop();\n        if (state && this.now) {\n            this.past.push(this.now);\n            this.updateElement(state, 'historyRedo');\n        }\n    }\n    updateHistory(state) {\n        if (!this.now) {\n            this.now = state;\n            return;\n        }\n        const isValueChanged = this.now.value !== state.value;\n        const isSelectionChanged = this.now.selection.some((item, index) => item !== state.selection[index]);\n        if (!isValueChanged && !isSelectionChanged) {\n            return;\n        }\n        if (isValueChanged) {\n            this.past.push(this.now);\n            this.future = [];\n        }\n        this.now = state;\n    }\n    updateElement(state, inputType) {\n        this.now = state;\n        this.updateElementState(state, { inputType, data: null });\n    }\n}\n\nfunction areElementValuesEqual(sampleState, ...states) {\n    return states.every(({ value }) => value === sampleState.value);\n}\nfunction areElementStatesEqual(sampleState, ...states) {\n    return states.every(({ value, selection }) => value === sampleState.value &&\n        selection[0] === sampleState.selection[0] &&\n        selection[1] === sampleState.selection[1]);\n}\n\nfunction applyOverwriteMode({ value, selection }, newCharacters, mode) {\n    const [from, to] = selection;\n    const computedMode = typeof mode === 'function' ? mode({ value, selection }) : mode;\n    return {\n        value,\n        selection: computedMode === 'replace' ? [from, from + newCharacters.length] : [from, to],\n    };\n}\n\nfunction isFixedCharacter(char) {\n    return typeof char === 'string';\n}\n\nfunction getLeadingFixedCharacters(mask, validatedValuePart, newCharacter, initialElementState) {\n    let leadingFixedCharacters = '';\n    for (let i = validatedValuePart.length; i < mask.length; i++) {\n        const charConstraint = mask[i] || '';\n        const isInitiallyExisted = (initialElementState === null || initialElementState === void 0 ? void 0 : initialElementState.value[i]) === charConstraint;\n        if (!isFixedCharacter(charConstraint) ||\n            (charConstraint === newCharacter && !isInitiallyExisted)) {\n            return leadingFixedCharacters;\n        }\n        leadingFixedCharacters += charConstraint;\n    }\n    return leadingFixedCharacters;\n}\n\nfunction validateValueWithMask(value, maskExpression) {\n    if (Array.isArray(maskExpression)) {\n        return (value.length === maskExpression.length &&\n            Array.from(value).every((char, i) => {\n                const charConstraint = maskExpression[i] || '';\n                return isFixedCharacter(charConstraint)\n                    ? char === charConstraint\n                    : char.match(charConstraint);\n            }));\n    }\n    return maskExpression.test(value);\n}\n\nfunction guessValidValueByPattern(elementState, mask, initialElementState) {\n    let maskedFrom = null;\n    let maskedTo = null;\n    const maskedValue = Array.from(elementState.value).reduce((validatedCharacters, char, charIndex) => {\n        const leadingCharacters = getLeadingFixedCharacters(mask, validatedCharacters, char, initialElementState);\n        const newValidatedChars = validatedCharacters + leadingCharacters;\n        const charConstraint = mask[newValidatedChars.length] || '';\n        if (isFixedCharacter(charConstraint)) {\n            return newValidatedChars + charConstraint;\n        }\n        if (!char.match(charConstraint)) {\n            return newValidatedChars;\n        }\n        if (maskedFrom === null && charIndex >= elementState.selection[0]) {\n            maskedFrom = newValidatedChars.length;\n        }\n        if (maskedTo === null && charIndex >= elementState.selection[1]) {\n            maskedTo = newValidatedChars.length;\n        }\n        return newValidatedChars + char;\n    }, '');\n    const trailingFixedCharacters = getLeadingFixedCharacters(mask, maskedValue, '', initialElementState);\n    return {\n        value: validateValueWithMask(maskedValue + trailingFixedCharacters, mask)\n            ? maskedValue + trailingFixedCharacters\n            : maskedValue,\n        selection: [maskedFrom !== null && maskedFrom !== void 0 ? maskedFrom : maskedValue.length, maskedTo !== null && maskedTo !== void 0 ? maskedTo : maskedValue.length],\n    };\n}\n\nfunction guessValidValueByRegExp({ value, selection }, maskRegExp) {\n    const [from, to] = selection;\n    let newFrom = from;\n    let newTo = to;\n    const validatedValue = Array.from(value).reduce((validatedValuePart, char, i) => {\n        const newPossibleValue = validatedValuePart + char;\n        if (from === i) {\n            newFrom = validatedValuePart.length;\n        }\n        if (to === i) {\n            newTo = validatedValuePart.length;\n        }\n        return newPossibleValue.match(maskRegExp) ? newPossibleValue : validatedValuePart;\n    }, '');\n    return { value: validatedValue, selection: [newFrom, newTo] };\n}\n\nfunction calibrateValueByMask(elementState, mask, initialElementState = null) {\n    if (validateValueWithMask(elementState.value, mask)) {\n        return elementState;\n    }\n    const { value, selection } = Array.isArray(mask)\n        ? guessValidValueByPattern(elementState, mask, initialElementState)\n        : guessValidValueByRegExp(elementState, mask);\n    return {\n        selection,\n        value: Array.isArray(mask) ? value.slice(0, mask.length) : value,\n    };\n}\n\nfunction removeFixedMaskCharacters(initialElementState, mask) {\n    if (!Array.isArray(mask)) {\n        return initialElementState;\n    }\n    const [from, to] = initialElementState.selection;\n    const selection = [];\n    const unmaskedValue = Array.from(initialElementState.value).reduce((rawValue, char, i) => {\n        const charConstraint = mask[i] || '';\n        if (i === from) {\n            selection.push(rawValue.length);\n        }\n        if (i === to) {\n            selection.push(rawValue.length);\n        }\n        return isFixedCharacter(charConstraint) && charConstraint === char\n            ? rawValue\n            : rawValue + char;\n    }, '');\n    if (selection.length < 2) {\n        selection.push(...new Array(2 - selection.length).fill(unmaskedValue.length));\n    }\n    return {\n        value: unmaskedValue,\n        selection: [selection[0], selection[1]],\n    };\n}\n\nclass MaskModel {\n    constructor(initialElementState, maskOptions) {\n        this.initialElementState = initialElementState;\n        this.maskOptions = maskOptions;\n        this.value = '';\n        this.selection = [0, 0];\n        const { value, selection } = calibrateValueByMask(this.initialElementState, this.getMaskExpression(this.initialElementState));\n        this.value = value;\n        this.selection = selection;\n    }\n    addCharacters([from, to], newCharacters) {\n        const { value, maskOptions } = this;\n        const maskExpression = this.getMaskExpression({\n            value: value.slice(0, from) + newCharacters + value.slice(to),\n            selection: [from + newCharacters.length, from + newCharacters.length],\n        });\n        const initialElementState = { value, selection: [from, to] };\n        const unmaskedElementState = removeFixedMaskCharacters(initialElementState, maskExpression);\n        const [unmaskedFrom, unmaskedTo] = applyOverwriteMode(unmaskedElementState, newCharacters, maskOptions.overwriteMode).selection;\n        const newUnmaskedLeadingValuePart = unmaskedElementState.value.slice(0, unmaskedFrom) + newCharacters;\n        const newCaretIndex = newUnmaskedLeadingValuePart.length;\n        const maskedElementState = calibrateValueByMask({\n            value: newUnmaskedLeadingValuePart +\n                unmaskedElementState.value.slice(unmaskedTo),\n            selection: [newCaretIndex, newCaretIndex],\n        }, maskExpression, initialElementState);\n        const isInvalidCharsInsertion = \n        // eslint-disable-next-line @typescript-eslint/prefer-string-starts-ends-with\n        value.slice(0, unmaskedFrom) ===\n            calibrateValueByMask({\n                value: newUnmaskedLeadingValuePart,\n                selection: [newCaretIndex, newCaretIndex],\n            }, maskExpression, initialElementState).value;\n        if (isInvalidCharsInsertion ||\n            areElementStatesEqual(this, maskedElementState) // If typing new characters does not change value\n        ) {\n            throw new Error('Invalid mask value');\n        }\n        this.value = maskedElementState.value;\n        this.selection = maskedElementState.selection;\n    }\n    deleteCharacters([from, to]) {\n        if (from === to || !to) {\n            return;\n        }\n        const { value } = this;\n        const maskExpression = this.getMaskExpression({\n            value: value.slice(0, from) + value.slice(to),\n            selection: [from, from],\n        });\n        const initialElementState = { value, selection: [from, to] };\n        const unmaskedElementState = removeFixedMaskCharacters(initialElementState, maskExpression);\n        const [unmaskedFrom, unmaskedTo] = unmaskedElementState.selection;\n        const newUnmaskedValue = unmaskedElementState.value.slice(0, unmaskedFrom) +\n            unmaskedElementState.value.slice(unmaskedTo);\n        const maskedElementState = calibrateValueByMask({ value: newUnmaskedValue, selection: [unmaskedFrom, unmaskedFrom] }, maskExpression, initialElementState);\n        this.value = maskedElementState.value;\n        this.selection = maskedElementState.selection;\n    }\n    getMaskExpression(elementState) {\n        const { mask } = this.maskOptions;\n        return typeof mask === 'function' ? mask(elementState) : mask;\n    }\n}\n\nclass EventListener {\n    constructor(element) {\n        this.element = element;\n        this.listeners = [];\n    }\n    listen(eventType, fn, options) {\n        const untypedFn = fn;\n        this.element.addEventListener(eventType, untypedFn, options);\n        this.listeners.push(() => this.element.removeEventListener(eventType, untypedFn));\n    }\n    destroy() {\n        this.listeners.forEach((stopListen) => stopListen());\n    }\n}\n\nconst HotkeyModifier = {\n    CTRL: 1 << 0,\n    ALT: 1 << 1,\n    SHIFT: 1 << 2,\n    META: 1 << 3,\n};\n// TODO add variants that can be processed correctly\nconst HotkeyCode = {\n    Y: 89,\n    Z: 90,\n};\n/**\n * Checks if the passed keyboard event match the required hotkey.\n *\n * @example\n * input.addEventListener('keydown', (event) => {\n *     if (isHotkey(event, HotkeyModifier.CTRL | HotkeyModifier.SHIFT, HotkeyCode.Z)) {\n *         // redo hotkey pressed\n *     }\n * })\n *\n * @return will return `true` only if the {@link HotkeyCode} matches and only the necessary\n * {@link HotkeyModifier modifiers} have been pressed\n */\nfunction isHotkey(event, modifiers, hotkeyCode) {\n    return (event.ctrlKey === !!(modifiers & HotkeyModifier.CTRL) &&\n        event.altKey === !!(modifiers & HotkeyModifier.ALT) &&\n        event.shiftKey === !!(modifiers & HotkeyModifier.SHIFT) &&\n        event.metaKey === !!(modifiers & HotkeyModifier.META) &&\n        /**\n         * We intentionally use legacy {@link KeyboardEvent#keyCode `keyCode`} property. It is more\n         * \"keyboard-layout\"-independent than {@link KeyboardEvent#key `key`} or {@link KeyboardEvent#code `code`} properties.\n         * @see {@link https://github.com/taiga-family/maskito/issues/315 `KeyboardEvent#code` issue}\n         */\n        event.keyCode === hotkeyCode);\n}\n\nfunction isRedo(event) {\n    return (isHotkey(event, HotkeyModifier.CTRL, HotkeyCode.Y) || // Windows\n        isHotkey(event, HotkeyModifier.CTRL | HotkeyModifier.SHIFT, HotkeyCode.Z) || // Windows & Android\n        isHotkey(event, HotkeyModifier.META | HotkeyModifier.SHIFT, HotkeyCode.Z) // macOS & iOS\n    );\n}\nfunction isUndo(event) {\n    return (isHotkey(event, HotkeyModifier.CTRL, HotkeyCode.Z) || // Windows & Android\n        isHotkey(event, HotkeyModifier.META, HotkeyCode.Z) // macOS & iOS\n    );\n}\n\n/**\n * Sets value to element, and dispatches input event\n * if you passed ELementState, it also sets selection range\n *\n * @example\n * maskitoUpdateElement(input, newValue);\n * maskitoUpdateElement(input, elementState);\n *\n * @see {@link https://github.com/taiga-family/maskito/issues/804 issue}\n *\n * @return void\n */\nfunction maskitoUpdateElement(element, valueOrElementState) {\n    var _a;\n    const initialValue = element.value;\n    if (typeof valueOrElementState === 'string') {\n        element.value = valueOrElementState;\n    }\n    else {\n        const [from, to] = valueOrElementState.selection;\n        element.value = valueOrElementState.value;\n        if (element.matches(':focus')) {\n            (_a = element.setSelectionRange) === null || _a === void 0 ? void 0 : _a.call(element, from, to);\n        }\n    }\n    if (element.value !== initialValue) {\n        element.dispatchEvent(new Event('input', \n        /**\n         * React handles this event only on bubbling phase\n         *\n         * here is the list of events that are processed in the capture stage, others are processed in the bubbling stage\n         * https://github.com/facebook/react/blob/cb2439624f43c510007f65aea5c50a8bb97917e4/packages/react-dom-bindings/src/events/DOMPluginEventSystem.js#L222\n         */\n        { bubbles: true }));\n    }\n}\n\nfunction getLineSelection({ value, selection }, isForward) {\n    const [from, to] = selection;\n    if (from !== to) {\n        return [from, to];\n    }\n    const nearestBreak = isForward\n        ? value.slice(from).indexOf('\\n') + 1 || value.length\n        : value.slice(0, to).lastIndexOf('\\n') + 1;\n    const selectFrom = isForward ? from : nearestBreak;\n    const selectTo = isForward ? nearestBreak : to;\n    return [selectFrom, selectTo];\n}\n\nfunction getNotEmptySelection({ value, selection }, isForward) {\n    const [from, to] = selection;\n    if (from !== to) {\n        return [from, to];\n    }\n    const notEmptySelection = isForward ? [from, to + 1] : [from - 1, to];\n    return notEmptySelection.map((x) => Math.min(Math.max(x, 0), value.length));\n}\n\nconst TRAILING_SPACES_REG = /\\s+$/g;\nconst LEADING_SPACES_REG = /^\\s+/g;\nconst SPACE_REG = /\\s/;\nfunction getWordSelection({ value, selection }, isForward) {\n    const [from, to] = selection;\n    if (from !== to) {\n        return [from, to];\n    }\n    if (isForward) {\n        const valueAfterSelectionStart = value.slice(from);\n        const [leadingSpaces] = valueAfterSelectionStart.match(LEADING_SPACES_REG) || [\n            '',\n        ];\n        const nearestWordEndIndex = valueAfterSelectionStart\n            .trimStart()\n            .search(SPACE_REG);\n        return [\n            from,\n            nearestWordEndIndex !== -1\n                ? from + leadingSpaces.length + nearestWordEndIndex\n                : value.length,\n        ];\n    }\n    const valueBeforeSelectionEnd = value.slice(0, to);\n    const [trailingSpaces] = valueBeforeSelectionEnd.match(TRAILING_SPACES_REG) || [''];\n    const selectedWordLength = valueBeforeSelectionEnd\n        .trimEnd()\n        .split('')\n        .reverse()\n        .findIndex((char) => char.match(SPACE_REG));\n    return [\n        selectedWordLength !== -1 ? to - trailingSpaces.length - selectedWordLength : 0,\n        to,\n    ];\n}\n\n/* eslint-disable @typescript-eslint/ban-types */\n/**\n * @internal\n */\nfunction maskitoPipe(processors = []) {\n    return (initialData, ...readonlyArgs) => processors.reduce((data, fn) => (Object.assign(Object.assign({}, data), fn(data, ...readonlyArgs))), initialData);\n}\n\nfunction maskitoTransform(valueOrState, maskitoOptions) {\n    const options = Object.assign(Object.assign({}, MASKITO_DEFAULT_OPTIONS), maskitoOptions);\n    const preprocessor = maskitoPipe(options.preprocessors);\n    const postprocessor = maskitoPipe(options.postprocessors);\n    const initialElementState = typeof valueOrState === 'string'\n        ? { value: valueOrState, selection: [0, 0] }\n        : valueOrState;\n    const { elementState } = preprocessor({ elementState: initialElementState, data: '' }, 'validation');\n    const maskModel = new MaskModel(elementState, options);\n    const { value, selection } = postprocessor(maskModel, initialElementState);\n    return typeof valueOrState === 'string' ? value : { value, selection };\n}\n\nclass Maskito extends MaskHistory {\n    constructor(element, maskitoOptions) {\n        super();\n        this.element = element;\n        this.maskitoOptions = maskitoOptions;\n        this.isTextArea = this.element.nodeName === 'TEXTAREA';\n        this.eventListener = new EventListener(this.element);\n        this.options = Object.assign(Object.assign({}, MASKITO_DEFAULT_OPTIONS), this.maskitoOptions);\n        this.preprocessor = maskitoPipe(this.options.preprocessors);\n        this.postprocessor = maskitoPipe(this.options.postprocessors);\n        this.teardowns = this.options.plugins.map((plugin) => plugin(this.element, this.options));\n        this.updateHistory(this.elementState);\n        this.eventListener.listen('keydown', (event) => {\n            if (isRedo(event)) {\n                event.preventDefault();\n                return this.redo();\n            }\n            if (isUndo(event)) {\n                event.preventDefault();\n                return this.undo();\n            }\n        });\n        this.eventListener.listen('beforeinput', (event) => {\n            var _a;\n            const isForward = event.inputType.includes('Forward');\n            this.updateHistory(this.elementState);\n            switch (event.inputType) {\n                // historyUndo/historyRedo will not be triggered if value was modified programmatically\n                case 'historyUndo':\n                    event.preventDefault();\n                    return this.undo();\n                case 'historyRedo':\n                    event.preventDefault();\n                    return this.redo();\n                case 'deleteByCut':\n                case 'deleteContentBackward':\n                case 'deleteContentForward':\n                    return this.handleDelete({\n                        event,\n                        isForward,\n                        selection: getNotEmptySelection(this.elementState, isForward),\n                    });\n                case 'deleteWordForward':\n                case 'deleteWordBackward':\n                    return this.handleDelete({\n                        event,\n                        isForward,\n                        selection: getWordSelection(this.elementState, isForward),\n                        force: true,\n                    });\n                case 'deleteSoftLineBackward':\n                case 'deleteSoftLineForward':\n                case 'deleteHardLineBackward':\n                case 'deleteHardLineForward':\n                    return this.handleDelete({\n                        event,\n                        isForward,\n                        selection: getLineSelection(this.elementState, isForward),\n                        force: true,\n                    });\n                case 'insertCompositionText':\n                    return; // will be handled inside `compositionend` event\n                case 'insertReplacementText':\n                    /**\n                     * According {@link https://www.w3.org/TR/input-events-2 W3C specification}:\n                     * > `insertReplacementText` – insert or replace existing text by means of a spell checker,\n                     * > auto-correct, writing suggestions or similar.\n                     * ___\n                     * Firefox emits `insertReplacementText` event for its suggestion/autofill and for spell checker.\n                     * However, it is impossible to detect which part of the textfield value is going to be replaced\n                     * (`selectionStart` and `selectionEnd` just equal to the last caret position).\n                     * ___\n                     * Chrome does not fire `beforeinput` event for its suggestion/autofill.\n                     * It emits only `input` event with `inputType` and `data` set to `undefined`.\n                     * ___\n                     * All these browser limitations make us to validate the result value later in `input` event.\n                     */\n                    return;\n                case 'insertLineBreak':\n                case 'insertParagraph':\n                    return this.handleEnter(event);\n                case 'insertFromPaste':\n                case 'insertText':\n                case 'insertFromDrop':\n                default:\n                    return this.handleInsert(event, event.data ||\n                        (\n                        // `event.data` for `contentEditable` is always `null` for paste/drop events\n                        (_a = event.dataTransfer) === null || _a === void 0 ? void 0 : _a.getData('text/plain')) ||\n                        '');\n            }\n        });\n        this.eventListener.listen('input', ({ inputType }) => {\n            if (inputType === 'insertCompositionText') {\n                return; // will be handled inside `compositionend` event\n            }\n            this.ensureValueFitsMask();\n            this.updateHistory(this.elementState);\n        });\n        this.eventListener.listen('compositionend', () => {\n            this.ensureValueFitsMask();\n            this.updateHistory(this.elementState);\n        });\n    }\n    get elementState() {\n        const { value, selectionStart, selectionEnd } = this.element;\n        return {\n            value,\n            selection: [selectionStart || 0, selectionEnd || 0],\n        };\n    }\n    get maxLength() {\n        const { maxLength } = this.element;\n        return maxLength === -1 ? Infinity : maxLength;\n    }\n    destroy() {\n        this.eventListener.destroy();\n        this.teardowns.forEach((teardown) => teardown === null || teardown === void 0 ? void 0 : teardown());\n    }\n    updateElementState({ value, selection }, eventInit = {\n        inputType: 'insertText',\n        data: null,\n    }) {\n        const initialValue = this.elementState.value;\n        this.updateValue(value);\n        this.updateSelectionRange(selection);\n        if (initialValue !== value) {\n            this.dispatchInputEvent(eventInit);\n        }\n    }\n    updateSelectionRange([from, to]) {\n        var _a;\n        const { element } = this;\n        if (element.matches(':focus') &&\n            (element.selectionStart !== from || element.selectionEnd !== to)) {\n            (_a = element.setSelectionRange) === null || _a === void 0 ? void 0 : _a.call(element, from, to);\n        }\n    }\n    updateValue(value) {\n        this.element.value = value;\n    }\n    ensureValueFitsMask() {\n        this.updateElementState(maskitoTransform(this.elementState, this.options));\n    }\n    dispatchInputEvent(eventInit = {\n        inputType: 'insertText',\n        data: null,\n    }) {\n        if (globalThis.InputEvent) {\n            this.element.dispatchEvent(new InputEvent('input', Object.assign(Object.assign({}, eventInit), { bubbles: true, cancelable: false })));\n        }\n    }\n    handleDelete({ event, selection, isForward, force = false, }) {\n        const initialState = {\n            value: this.elementState.value,\n            selection,\n        };\n        const [initialFrom, initialTo] = initialState.selection;\n        const { elementState } = this.preprocessor({\n            elementState: initialState,\n            data: '',\n        }, isForward ? 'deleteForward' : 'deleteBackward');\n        const maskModel = new MaskModel(elementState, this.options);\n        const [from, to] = elementState.selection;\n        maskModel.deleteCharacters([from, to]);\n        const newElementState = this.postprocessor(maskModel, initialState);\n        const newPossibleValue = initialState.value.slice(0, initialFrom) +\n            initialState.value.slice(initialTo);\n        if (newPossibleValue === newElementState.value &&\n            !force &&\n            !this.element.isContentEditable) {\n            return;\n        }\n        event.preventDefault();\n        if (areElementValuesEqual(initialState, elementState, maskModel, newElementState)) {\n            // User presses Backspace/Delete for the fixed value\n            return this.updateSelectionRange(isForward ? [to, to] : [from, from]);\n        }\n        this.updateElementState(newElementState, {\n            inputType: event.inputType,\n            data: null,\n        });\n        this.updateHistory(newElementState);\n    }\n    handleInsert(event, data) {\n        const initialElementState = this.elementState;\n        const { elementState, data: insertedText = data } = this.preprocessor({\n            data,\n            elementState: initialElementState,\n        }, 'insert');\n        const maskModel = new MaskModel(elementState, this.options);\n        try {\n            maskModel.addCharacters(elementState.selection, insertedText);\n        }\n        catch (_a) {\n            return event.preventDefault();\n        }\n        const [from, to] = elementState.selection;\n        const newPossibleValue = initialElementState.value.slice(0, from) +\n            data +\n            initialElementState.value.slice(to);\n        const newElementState = this.postprocessor(maskModel, initialElementState);\n        if (newElementState.value.length > this.maxLength) {\n            return event.preventDefault();\n        }\n        if (newPossibleValue !== newElementState.value ||\n            this.element.isContentEditable) {\n            event.preventDefault();\n            this.updateElementState(newElementState, {\n                data,\n                inputType: event.inputType,\n            });\n            this.updateHistory(newElementState);\n        }\n    }\n    handleEnter(event) {\n        if (this.isTextArea || this.element.isContentEditable) {\n            this.handleInsert(event, '\\n');\n        }\n    }\n}\n\nfunction maskitoChangeEventPlugin() {\n    return (element) => {\n        if (element.isContentEditable) {\n            return;\n        }\n        let value = element.value;\n        const valueListener = () => {\n            value = element.value;\n        };\n        const blurListener = () => {\n            if (element.value !== value) {\n                element.dispatchEvent(new Event('change', { bubbles: true }));\n            }\n        };\n        element.addEventListener('focus', valueListener);\n        element.addEventListener('change', valueListener);\n        element.addEventListener('blur', blurListener);\n        return () => {\n            element.removeEventListener('focus', valueListener);\n            element.removeEventListener('change', valueListener);\n            element.removeEventListener('blur', blurListener);\n        };\n    };\n}\n\nfunction maskitoInitialCalibrationPlugin(customOptions) {\n    return (element, options) => {\n        const from = element.selectionStart || 0;\n        const to = element.selectionEnd || 0;\n        maskitoUpdateElement(element, {\n            value: maskitoTransform(element.value, customOptions || options),\n            selection: [from, to],\n        });\n    };\n}\n\nfunction maskitoStrictCompositionPlugin() {\n    return (element, maskitoOptions) => {\n        const listener = (event) => {\n            if (event.inputType !== 'insertCompositionText') {\n                return;\n            }\n            const selection = [\n                element.selectionStart || 0,\n                element.selectionEnd || 0,\n            ];\n            const elementState = {\n                selection,\n                value: element.value,\n            };\n            const validatedState = maskitoTransform(elementState, maskitoOptions);\n            if (!areElementStatesEqual(elementState, validatedState)) {\n                event.preventDefault();\n                maskitoUpdateElement(element, validatedState);\n            }\n        };\n        element.addEventListener('input', listener);\n        return () => element.removeEventListener('input', listener);\n    };\n}\n\nexport { MASKITO_DEFAULT_ELEMENT_PREDICATE, MASKITO_DEFAULT_OPTIONS, Maskito, maskitoAdaptContentEditable, maskitoChangeEventPlugin, maskitoInitialCalibrationPlugin, maskitoPipe, maskitoStrictCompositionPlugin, maskitoTransform, maskitoUpdateElement };\n","import { maskitoUpdateElement, MASKITO_DEFAULT_OPTIONS, maskitoTransform } from '@maskito/core';\n\n/**\n * Clamps a value between two inclusive limits\n *\n * @param value\n * @param min lower limit\n * @param max upper limit\n */\nfunction clamp(value, min, max) {\n    const clampedValue = Math.min(Number(max), Math.max(Number(min), Number(value)));\n    return (value instanceof Date ? new Date(clampedValue) : clampedValue);\n}\n\nfunction countDigits(str) {\n    return str.replaceAll(/\\W/g, '').length;\n}\n\nfunction appendDate(initialDate, { day, month, year } = {}) {\n    const date = new Date(initialDate);\n    if (day) {\n        date.setDate(date.getDate() + day);\n    }\n    if (month) {\n        date.setMonth(date.getMonth() + month);\n    }\n    if (year) {\n        date.setFullYear(date.getFullYear() + year);\n    }\n    return date;\n}\n\nconst getDateSegmentValueLength = (dateString) => {\n    var _a, _b, _c;\n    return ({\n        day: ((_a = dateString.match(/d/g)) === null || _a === void 0 ? void 0 : _a.length) || 0,\n        month: ((_b = dateString.match(/m/g)) === null || _b === void 0 ? void 0 : _b.length) || 0,\n        year: ((_c = dateString.match(/y/g)) === null || _c === void 0 ? void 0 : _c.length) || 0,\n    });\n};\n\nfunction dateToSegments(date) {\n    return {\n        day: String(date.getDate()).padStart(2, '0'),\n        month: String(date.getMonth() + 1).padStart(2, '0'),\n        year: String(date.getFullYear()).padStart(4, '0'),\n        hours: String(date.getHours()).padStart(2, '0'),\n        minutes: String(date.getMinutes()).padStart(2, '0'),\n        seconds: String(date.getSeconds()).padStart(2, '0'),\n        milliseconds: String(date.getMilliseconds()).padStart(3, '0'),\n    };\n}\n\nfunction getFirstCompleteDate(dateString, dateModeTemplate) {\n    const digitsInDate = countDigits(dateModeTemplate);\n    const [completeDate = ''] = dateString.match(new RegExp(`(\\\\D*\\\\d){${digitsInDate}}`)) || [];\n    return completeDate;\n}\n\nfunction isDateStringComplete(dateString, dateModeTemplate) {\n    if (dateString.length < dateModeTemplate.length) {\n        return false;\n    }\n    return dateString.split(/\\D/).every((segment) => !segment.match(/^0+$/));\n}\n\nfunction parseDateRangeString(dateRange, dateModeTemplate, rangeSeparator) {\n    const digitsInDate = countDigits(dateModeTemplate);\n    return (dateRange\n        .replace(rangeSeparator, '')\n        .match(new RegExp(`(\\\\D*\\\\d[^\\\\d\\\\s]*){1,${digitsInDate}}`, 'g')) || []);\n}\n\nfunction parseDateString(dateString, fullMode) {\n    const cleanMode = fullMode.replaceAll(/[^dmy]/g, '');\n    const onlyDigitsDate = dateString.replaceAll(/\\D+/g, '');\n    const dateSegments = {\n        day: onlyDigitsDate.slice(cleanMode.indexOf('d'), cleanMode.lastIndexOf('d') + 1),\n        month: onlyDigitsDate.slice(cleanMode.indexOf('m'), cleanMode.lastIndexOf('m') + 1),\n        year: onlyDigitsDate.slice(cleanMode.indexOf('y'), cleanMode.lastIndexOf('y') + 1),\n    };\n    return Object.fromEntries(Object.entries(dateSegments)\n        .filter(([_, value]) => Boolean(value))\n        .sort(([a], [b]) => fullMode.toLowerCase().indexOf(a.slice(0, 1)) >\n        fullMode.toLowerCase().indexOf(b.slice(0, 1))\n        ? 1\n        : -1));\n}\n\nfunction segmentsToDate(parsedDate, parsedTime) {\n    var _a, _b, _c, _d, _e, _f, _g;\n    const year = ((_a = parsedDate.year) === null || _a === void 0 ? void 0 : _a.length) === 2 ? `20${parsedDate.year}` : parsedDate.year;\n    const date = new Date(Number(year !== null && year !== void 0 ? year : '0'), Number((_b = parsedDate.month) !== null && _b !== void 0 ? _b : '1') - 1, Number((_c = parsedDate.day) !== null && _c !== void 0 ? _c : '1'), Number((_d = parsedTime === null || parsedTime === void 0 ? void 0 : parsedTime.hours) !== null && _d !== void 0 ? _d : '0'), Number((_e = parsedTime === null || parsedTime === void 0 ? void 0 : parsedTime.minutes) !== null && _e !== void 0 ? _e : '0'), Number((_f = parsedTime === null || parsedTime === void 0 ? void 0 : parsedTime.seconds) !== null && _f !== void 0 ? _f : '0'), Number((_g = parsedTime === null || parsedTime === void 0 ? void 0 : parsedTime.milliseconds) !== null && _g !== void 0 ? _g : '0'));\n    // needed for years less than 1900\n    date.setFullYear(Number(year !== null && year !== void 0 ? year : '0'));\n    return date;\n}\n\nconst DATE_TIME_SEPARATOR = ', ';\n\nfunction toDateString({ day, month, year, hours, minutes, seconds, milliseconds, }, { dateMode, dateTimeSeparator = DATE_TIME_SEPARATOR, timeMode, }) {\n    var _a;\n    const safeYear = ((_a = dateMode.match(/y/g)) === null || _a === void 0 ? void 0 : _a.length) === 2 ? year === null || year === void 0 ? void 0 : year.slice(-2) : year;\n    const fullMode = dateMode + (timeMode ? dateTimeSeparator + timeMode : '');\n    return fullMode\n        .replaceAll(/d+/g, day !== null && day !== void 0 ? day : '')\n        .replaceAll(/m+/g, month !== null && month !== void 0 ? month : '')\n        .replaceAll(/y+/g, safeYear !== null && safeYear !== void 0 ? safeYear : '')\n        .replaceAll(/H+/g, hours !== null && hours !== void 0 ? hours : '')\n        .replaceAll('MSS', milliseconds !== null && milliseconds !== void 0 ? milliseconds : '')\n        .replaceAll(/M+/g, minutes !== null && minutes !== void 0 ? minutes : '')\n        .replaceAll(/S+/g, seconds !== null && seconds !== void 0 ? seconds : '')\n        .replaceAll(/^\\D+/g, '')\n        .replaceAll(/\\D+$/g, '');\n}\n\nconst DATE_SEGMENTS_MAX_VALUES = {\n    day: 31,\n    month: 12,\n    year: 9999,\n};\n\nconst DEFAULT_DECIMAL_PSEUDO_SEPARATORS = ['.', ',', 'б', 'ю'];\n\nconst DEFAULT_MIN_DATE = new Date('0001-01-01');\nconst DEFAULT_MAX_DATE = new Date('9999-12-31');\n\nconst DEFAULT_TIME_SEGMENT_MAX_VALUES = {\n    hours: 23,\n    minutes: 59,\n    seconds: 59,\n    milliseconds: 999,\n};\n\nconst TIME_FIXED_CHARACTERS = [':', '.'];\n\nconst TIME_SEGMENT_VALUE_LENGTHS = {\n    hours: 2,\n    minutes: 2,\n    seconds: 2,\n    milliseconds: 3,\n};\n\n/**\n * {@link https://unicode-table.com/en/00A0/ Non-breaking space}.\n */\nconst CHAR_NO_BREAK_SPACE = '\\u00A0';\n/**\n * {@link https://symbl.cc/en/200B/ Zero width space}.\n */\nconst CHAR_ZERO_WIDTH_SPACE = '\\u200B';\n/**\n * {@link https://unicode-table.com/en/2013/ EN dash}\n * is used to indicate a range of numbers or a span of time.\n * @example 2006–2022\n */\nconst CHAR_EN_DASH = '\\u2013';\n/**\n * {@link https://unicode-table.com/en/2014/ EM dash}\n * is used to mark a break in a sentence.\n * @example Taiga UI — powerful set of open source components for Angular\n * ___\n * Don't confuse with {@link CHAR_EN_DASH} or {@link CHAR_HYPHEN}!\n */\nconst CHAR_EM_DASH = '\\u2014';\n/**\n * {@link https://unicode-table.com/en/002D/ Hyphen (minus sign)}\n * is used to combine words.\n * @example well-behaved\n * ___\n * Don't confuse with {@link CHAR_EN_DASH} or {@link CHAR_EM_DASH}!\n */\nconst CHAR_HYPHEN = '\\u002D';\n/**\n * {@link https://unicode-table.com/en/2212/ Minus}\n * is used as math operator symbol or before negative digits.\n * ---\n * Can be used as `&minus;`. Don't confuse with {@link CHAR_HYPHEN}\n */\nconst CHAR_MINUS = '\\u2212';\n/**\n * {@link https://symbl.cc/en/30FC/ Katakana-Hiragana Prolonged Sound Mark}\n * is used as prolonged sounds in Japanese.\n */\nconst CHAR_JP_HYPHEN = '\\u30FC';\n/**\n * {@link https://symbl.cc/en/003A/ Colon}\n * is a punctuation mark that connects parts of a text logically.\n * ---\n * is also used as separator in time.\n */\nconst CHAR_COLON = '\\u003A';\n/**\n * {@link https://symbl.cc/en/FF1A/ Full-width colon}\n * is a full-width punctuation mark used to separate parts of a text commonly in Japanese.\n */\nconst CHAR_JP_COLON = '\\uFF1A';\n\nfunction validateDateString({ dateString, dateModeTemplate, dateSegmentsSeparator, offset, selection: [from, to], }) {\n    const parsedDate = parseDateString(dateString, dateModeTemplate);\n    const dateSegments = Object.entries(parsedDate);\n    const validatedDateSegments = {};\n    for (const [segmentName, segmentValue] of dateSegments) {\n        const validatedDate = toDateString(validatedDateSegments, {\n            dateMode: dateModeTemplate,\n        });\n        const maxSegmentValue = DATE_SEGMENTS_MAX_VALUES[segmentName];\n        const fantomSeparator = validatedDate.length && dateSegmentsSeparator.length;\n        const lastSegmentDigitIndex = offset +\n            validatedDate.length +\n            fantomSeparator +\n            getDateSegmentValueLength(dateModeTemplate)[segmentName];\n        const isLastSegmentDigitAdded = lastSegmentDigitIndex >= from && lastSegmentDigitIndex === to;\n        if (isLastSegmentDigitAdded && Number(segmentValue) > Number(maxSegmentValue)) {\n            // 3|1.10.2010 => Type 9 => 3|1.10.2010\n            return { validatedDateString: '', updatedSelection: [from, to] }; // prevent changes\n        }\n        if (isLastSegmentDigitAdded && Number(segmentValue) < 1) {\n            // 31.0|1.2010 => Type 0 => 31.0|1.2010\n            return { validatedDateString: '', updatedSelection: [from, to] }; // prevent changes\n        }\n        validatedDateSegments[segmentName] = segmentValue;\n    }\n    const validatedDateString = toDateString(validatedDateSegments, {\n        dateMode: dateModeTemplate,\n    });\n    const addedDateSegmentSeparators = validatedDateString.length - dateString.length;\n    return {\n        validatedDateString,\n        updatedSelection: [\n            from + addedDateSegmentSeparators,\n            to + addedDateSegmentSeparators,\n        ],\n    };\n}\n\n/**\n * Copy-pasted solution from lodash\n * @see https://lodash.com/docs/4.17.15#escapeRegExp\n */\nconst reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\nconst reHasRegExpChar = new RegExp(reRegExpChar.source);\nfunction escapeRegExp(str) {\n    return str && reHasRegExpChar.test(str)\n        ? str.replaceAll(reRegExpChar, String.raw `\\$&`)\n        : str;\n}\n\nfunction extractAffixes(value, { prefix, postfix }) {\n    var _a, _b;\n    const prefixRegExp = new RegExp(`^${escapeRegExp(prefix)}`);\n    const postfixRegExp = new RegExp(`${escapeRegExp(postfix)}$`);\n    const [extractedPrefix = ''] = (_a = value.match(prefixRegExp)) !== null && _a !== void 0 ? _a : [];\n    const [extractedPostfix = ''] = (_b = value.match(postfixRegExp)) !== null && _b !== void 0 ? _b : [];\n    const cleanValue = value.replace(prefixRegExp, '').replace(postfixRegExp, '');\n    return { extractedPrefix, extractedPostfix, cleanValue };\n}\n\nfunction findCommonBeginningSubstr(a, b) {\n    let res = '';\n    for (let i = 0; i < a.length; i++) {\n        if (a[i] !== b[i]) {\n            return res;\n        }\n        res += a[i];\n    }\n    return res;\n}\n\nfunction identity(x) {\n    return x;\n}\n\nfunction isEmpty(entity) {\n    return !entity || (typeof entity === 'object' && Object.keys(entity).length === 0);\n}\n\nconst ALL_ZEROES_RE = /^0+$/;\nfunction padWithZeroesUntilValid(segmentValue, paddedMaxValue, prefixedZeroesCount = 0) {\n    const paddedSegmentValue = segmentValue.padEnd(paddedMaxValue.length, '0');\n    if (Number(paddedSegmentValue) <= Number(paddedMaxValue)) {\n        return { validatedSegmentValue: segmentValue, prefixedZeroesCount };\n    }\n    if (paddedSegmentValue.endsWith('0')) {\n        // 00:|00 => Type 9 => 00:09|\n        return padWithZeroesUntilValid(`0${segmentValue.slice(0, paddedMaxValue.length - 1)}`, paddedMaxValue, prefixedZeroesCount + 1);\n    }\n    const valueWithoutLastChar = segmentValue.slice(0, paddedMaxValue.length - 1);\n    if (valueWithoutLastChar.match(ALL_ZEROES_RE)) {\n        return { validatedSegmentValue: '', prefixedZeroesCount };\n    }\n    // |19:00 => Type 2 => 2|0:00\n    return padWithZeroesUntilValid(`${valueWithoutLastChar}0`, paddedMaxValue, prefixedZeroesCount);\n}\n\n/**\n * Replace fullwidth colon with half width colon\n * @param fullWidthColon full width colon\n * @returns processed half width colon\n */\nfunction toHalfWidthColon(fullWidthColon) {\n    return fullWidthColon.replaceAll(new RegExp(CHAR_JP_COLON, 'g'), CHAR_COLON);\n}\n\n/**\n * Replace fullwidth numbers with half width number\n * @param fullWidthNumber full width number\n * @returns processed half width number\n */\nfunction toHalfWidthNumber(fullWidthNumber) {\n    return fullWidthNumber.replaceAll(/[０-９]/g, (s) => String.fromCharCode(s.charCodeAt(0) - 0xfee0));\n}\n\n/**\n * Convert full width colon (：) to half width one (:)\n */\nfunction createColonConvertPreprocessor() {\n    return ({ elementState, data }) => {\n        const { value, selection } = elementState;\n        return {\n            elementState: {\n                selection,\n                value: toHalfWidthColon(value),\n            },\n            data: toHalfWidthColon(data),\n        };\n    };\n}\n\nfunction createDateSegmentsZeroPaddingPostprocessor({ dateModeTemplate, dateSegmentSeparator, splitFn, uniteFn, }) {\n    return ({ value, selection }) => {\n        var _a;\n        const [from, to] = selection;\n        const { dateStrings, restPart = '' } = splitFn(value);\n        const validatedDateStrings = [];\n        let caretShift = 0;\n        dateStrings.forEach((dateString) => {\n            const parsedDate = parseDateString(dateString, dateModeTemplate);\n            const dateSegments = Object.entries(parsedDate);\n            const validatedDateSegments = dateSegments.reduce((acc, [segmentName, segmentValue]) => {\n                const { validatedSegmentValue, prefixedZeroesCount } = padWithZeroesUntilValid(segmentValue, `${DATE_SEGMENTS_MAX_VALUES[segmentName]}`);\n                caretShift += prefixedZeroesCount;\n                return Object.assign(Object.assign({}, acc), { [segmentName]: validatedSegmentValue });\n            }, {});\n            validatedDateStrings.push(toDateString(validatedDateSegments, { dateMode: dateModeTemplate }));\n        });\n        const validatedValue = uniteFn(validatedDateStrings, value) +\n            (((_a = dateStrings[dateStrings.length - 1]) === null || _a === void 0 ? void 0 : _a.endsWith(dateSegmentSeparator))\n                ? dateSegmentSeparator\n                : '') +\n            restPart;\n        if (caretShift &&\n            validatedValue.slice(to + caretShift, to + caretShift + dateSegmentSeparator.length) === dateSegmentSeparator) {\n            /**\n             * If `caretShift` > 0, it means that time segment was padded with zero.\n             * It is only possible if any character insertion happens.\n             * If caret is before `dateSegmentSeparator` => it should be moved after `dateSegmentSeparator`.\n             */\n            caretShift += dateSegmentSeparator.length;\n        }\n        return {\n            selection: [from + caretShift, to + caretShift],\n            value: validatedValue,\n        };\n    };\n}\n\n/**\n * It replaces pseudo range separators with valid one.\n * @example '01.01.2000_11.11.2000' -> '01.01.2000 - 01.01.2000'\n * @example '01.01.2000_23:59' -> '01.01.2000, 23:59'\n */\nfunction createFirstDateEndSeparatorPreprocessor({ dateModeTemplate, firstDateEndSeparator, dateSegmentSeparator, pseudoFirstDateEndSeparators, }) {\n    return ({ elementState, data }) => {\n        const { value, selection } = elementState;\n        const firstCompleteDate = getFirstCompleteDate(value, dateModeTemplate);\n        const pseudoSeparators = pseudoFirstDateEndSeparators.filter((x) => !firstDateEndSeparator.includes(x) && x !== dateSegmentSeparator);\n        const pseudoSeparatorsRE = new RegExp(`[${pseudoSeparators.join('')}]`, 'gi');\n        return {\n            elementState: {\n                selection,\n                value: firstCompleteDate && value.length > firstCompleteDate.length\n                    ? firstCompleteDate +\n                        value\n                            .slice(firstCompleteDate.length)\n                            .replace(/^[\\D\\s]*/, firstDateEndSeparator)\n                    : value,\n            },\n            data: data.replace(pseudoSeparatorsRE, firstDateEndSeparator),\n        };\n    };\n}\n\n/**\n * Convert full width numbers like １, ２ to half width numbers 1, 2\n */\nfunction createFullWidthToHalfWidthPreprocessor() {\n    return ({ elementState, data }) => {\n        const { value, selection } = elementState;\n        return {\n            elementState: {\n                selection,\n                value: toHalfWidthNumber(value),\n            },\n            data: toHalfWidthNumber(data),\n        };\n    };\n}\n\nfunction raiseSegmentValueToMin(segments, fullMode) {\n    const segmentsLength = getDateSegmentValueLength(fullMode);\n    return Object.fromEntries(Object.entries(segments).map(([key, value]) => {\n        const segmentLength = segmentsLength[key];\n        return [\n            key,\n            value.length === segmentLength && value.match(/^0+$/)\n                ? '1'.padStart(segmentLength, '0')\n                : value,\n        ];\n    }));\n}\n\nfunction createMinMaxDatePostprocessor({ dateModeTemplate, min = DEFAULT_MIN_DATE, max = DEFAULT_MAX_DATE, rangeSeparator = '', dateSegmentSeparator = '.', }) {\n    return ({ value, selection }) => {\n        const endsWithRangeSeparator = rangeSeparator && value.endsWith(rangeSeparator);\n        const dateStrings = parseDateRangeString(value, dateModeTemplate, rangeSeparator);\n        let validatedValue = '';\n        for (const dateString of dateStrings) {\n            validatedValue += validatedValue ? rangeSeparator : '';\n            const parsedDate = parseDateString(dateString, dateModeTemplate);\n            if (!isDateStringComplete(dateString, dateModeTemplate)) {\n                const fixedDate = raiseSegmentValueToMin(parsedDate, dateModeTemplate);\n                const fixedValue = toDateString(fixedDate, { dateMode: dateModeTemplate });\n                const tail = dateString.endsWith(dateSegmentSeparator)\n                    ? dateSegmentSeparator\n                    : '';\n                validatedValue += fixedValue + tail;\n                continue;\n            }\n            const date = segmentsToDate(parsedDate);\n            const clampedDate = clamp(date, min, max);\n            validatedValue += toDateString(dateToSegments(clampedDate), {\n                dateMode: dateModeTemplate,\n            });\n        }\n        return {\n            selection,\n            value: validatedValue + (endsWithRangeSeparator ? rangeSeparator : ''),\n        };\n    };\n}\n\nfunction normalizeDatePreprocessor({ dateModeTemplate, dateSegmentsSeparator, rangeSeparator = '', dateTimeSeparator = DATE_TIME_SEPARATOR, }) {\n    return ({ elementState, data }) => {\n        const separator = rangeSeparator\n            ? new RegExp(`${rangeSeparator}|-`)\n            : dateTimeSeparator;\n        const possibleDates = data.split(separator);\n        const dates = data.includes(dateTimeSeparator)\n            ? [possibleDates[0] || '']\n            : possibleDates;\n        if (dates.every((date) => date.trim().split(/\\D/).filter(Boolean).length ===\n            dateModeTemplate.split(dateSegmentsSeparator).length)) {\n            const newData = dates\n                .map((date) => normalizeDateString(date, dateModeTemplate, dateSegmentsSeparator))\n                .join(rangeSeparator);\n            return {\n                elementState,\n                data: `${newData}${data.includes(dateTimeSeparator)\n                    ? dateTimeSeparator + possibleDates[1] || ''\n                    : ''}`,\n            };\n        }\n        return { elementState, data };\n    };\n}\nfunction normalizeDateString(dateString, template, separator) {\n    const dateSegments = dateString.split(/\\D/).filter(Boolean);\n    const templateSegments = template.split(separator);\n    const normalizedSegments = dateSegments.map((segment, index) => {\n        var _a;\n        return index === templateSegments.length - 1\n            ? segment\n            : segment.padStart(((_a = templateSegments[index]) === null || _a === void 0 ? void 0 : _a.length) || 0, '0');\n    });\n    return normalizedSegments.join(separator);\n}\n\nfunction maskitoPostfixPostprocessorGenerator(postfix) {\n    const postfixRE = new RegExp(`${escapeRegExp(postfix)}$`);\n    return postfix\n        ? ({ value, selection }, initialElementState) => {\n            if (!value && !initialElementState.value.endsWith(postfix)) {\n                // cases when developer wants input to be empty (programmatically)\n                return { value, selection };\n            }\n            if (!value.endsWith(postfix) &&\n                !initialElementState.value.endsWith(postfix)) {\n                return { selection, value: value + postfix };\n            }\n            const initialValueBeforePostfix = initialElementState.value.replace(postfixRE, '');\n            const postfixWasModified = initialElementState.selection[1] >= initialValueBeforePostfix.length;\n            const alreadyExistedValueBeforePostfix = findCommonBeginningSubstr(initialValueBeforePostfix, value);\n            return {\n                selection,\n                value: Array.from(postfix)\n                    .reverse()\n                    .reduce((newValue, char, index) => {\n                    const i = newValue.length - 1 - index;\n                    const isInitiallyMirroredChar = alreadyExistedValueBeforePostfix[i] === char &&\n                        postfixWasModified;\n                    return newValue[i] !== char || isInitiallyMirroredChar\n                        ? newValue.slice(0, i + 1) + char + newValue.slice(i + 1)\n                        : newValue;\n                }, value),\n            };\n        }\n        : identity;\n}\n\nfunction maskitoPrefixPostprocessorGenerator(prefix) {\n    return prefix\n        ? ({ value, selection }, initialElementState) => {\n            if (value.startsWith(prefix) || // already valid\n                (!value && !initialElementState.value.startsWith(prefix)) // cases when developer wants input to be empty\n            ) {\n                return { value, selection };\n            }\n            const [from, to] = selection;\n            const prefixedValue = Array.from(prefix).reduce((modifiedValue, char, i) => modifiedValue[i] === char\n                ? modifiedValue\n                : modifiedValue.slice(0, i) + char + modifiedValue.slice(i), value);\n            const addedCharsCount = prefixedValue.length - value.length;\n            return {\n                selection: [from + addedCharsCount, to + addedCharsCount],\n                value: prefixedValue,\n            };\n        }\n        : identity;\n}\n\nfunction createValidDatePreprocessor({ dateModeTemplate, dateSegmentsSeparator, rangeSeparator = '', }) {\n    return ({ elementState, data }) => {\n        const { value, selection } = elementState;\n        if (data === dateSegmentsSeparator) {\n            return {\n                elementState,\n                data: selection[0] === value.length ? data : '',\n            };\n        }\n        const newCharacters = data.replaceAll(new RegExp(`[^\\\\d${escapeRegExp(dateSegmentsSeparator)}${rangeSeparator}]`, 'g'), '');\n        if (!newCharacters) {\n            return { elementState, data: '' };\n        }\n        const [from, rawTo] = selection;\n        let to = rawTo + data.length;\n        const newPossibleValue = value.slice(0, from) + newCharacters + value.slice(to);\n        const dateStrings = parseDateRangeString(newPossibleValue, dateModeTemplate, rangeSeparator);\n        let validatedValue = '';\n        const hasRangeSeparator = Boolean(rangeSeparator) && newPossibleValue.includes(rangeSeparator);\n        for (const dateString of dateStrings) {\n            const { validatedDateString, updatedSelection } = validateDateString({\n                dateString,\n                dateModeTemplate,\n                dateSegmentsSeparator,\n                offset: validatedValue.length,\n                selection: [from, to],\n            });\n            if (dateString && !validatedDateString) {\n                return { elementState, data: '' }; // prevent changes\n            }\n            to = updatedSelection[1];\n            validatedValue +=\n                hasRangeSeparator && !validatedValue\n                    ? validatedDateString + rangeSeparator\n                    : validatedDateString;\n        }\n        const newData = validatedValue.slice(from, to);\n        return {\n            elementState: {\n                selection,\n                value: validatedValue.slice(0, from) +\n                    newData\n                        .split(dateSegmentsSeparator)\n                        .map((segment) => '0'.repeat(segment.length))\n                        .join(dateSegmentsSeparator) +\n                    validatedValue.slice(to),\n            },\n            data: newData,\n        };\n    };\n}\n\nfunction maskitoEventHandler(name, handler, eventListenerOptions) {\n    return (element, maskitoOptions) => {\n        const listener = () => handler(element, maskitoOptions);\n        element.addEventListener(name, listener, eventListenerOptions);\n        return () => element.removeEventListener(name, listener, eventListenerOptions);\n    };\n}\n\nfunction maskitoAddOnFocusPlugin(value) {\n    return maskitoEventHandler('focus', (element) => {\n        if (!element.value) {\n            maskitoUpdateElement(element, value);\n        }\n    });\n}\n\nfunction maskitoCaretGuard(guard) {\n    return (element) => {\n        const document = element.ownerDocument;\n        let isPointerDown = 0;\n        const onPointerDown = () => isPointerDown++;\n        const onPointerUp = () => {\n            isPointerDown = Math.max(--isPointerDown, 0);\n        };\n        const listener = () => {\n            if (!element.matches(':focus')) {\n                return;\n            }\n            if (isPointerDown) {\n                return document.addEventListener('mouseup', listener, {\n                    once: true,\n                    passive: true,\n                });\n            }\n            const start = element.selectionStart || 0;\n            const end = element.selectionEnd || 0;\n            const [fromLimit, toLimit] = guard(element.value, [start, end]);\n            if (fromLimit > start || toLimit < end) {\n                element.setSelectionRange(clamp(start, fromLimit, toLimit), clamp(end, fromLimit, toLimit));\n            }\n        };\n        document.addEventListener('selectionchange', listener, { passive: true });\n        element.addEventListener('mousedown', onPointerDown, { passive: true });\n        document.addEventListener('mouseup', onPointerUp, { passive: true });\n        return () => {\n            document.removeEventListener('selectionchange', listener);\n            document.removeEventListener('mousedown', onPointerDown);\n            document.removeEventListener('mouseup', onPointerUp);\n        };\n    };\n}\n\nconst maskitoRejectEvent = (element) => {\n    const listener = () => {\n        const value = element.value;\n        element.addEventListener('beforeinput', (event) => {\n            if (event.defaultPrevented && value === element.value) {\n                element.dispatchEvent(new CustomEvent('maskitoReject', { bubbles: true }));\n            }\n        }, { once: true });\n    };\n    element.addEventListener('beforeinput', listener, true);\n    return () => element.removeEventListener('beforeinput', listener, true);\n};\n\nfunction maskitoRemoveOnBlurPlugin(value) {\n    return maskitoEventHandler('blur', (element) => {\n        if (element.value === value) {\n            maskitoUpdateElement(element, '');\n        }\n    });\n}\n\nconst noop = () => { };\nfunction createTimeSegmentsSteppingPlugin({ step, fullMode, timeSegmentMaxValues, }) {\n    const segmentsIndexes = createTimeSegmentsIndexes(fullMode);\n    return step <= 0\n        ? noop\n        : (element) => {\n            const listener = (event) => {\n                if (event.key !== 'ArrowUp' && event.key !== 'ArrowDown') {\n                    return;\n                }\n                event.preventDefault();\n                const selectionStart = element.selectionStart || 0;\n                const activeSegment = getActiveSegment({\n                    segmentsIndexes,\n                    selectionStart,\n                });\n                if (!activeSegment) {\n                    return;\n                }\n                const updatedValue = updateSegmentValue({\n                    selection: segmentsIndexes.get(activeSegment),\n                    value: element.value,\n                    toAdd: event.key === 'ArrowUp' ? step : -step,\n                    max: timeSegmentMaxValues[activeSegment],\n                });\n                maskitoUpdateElement(element, {\n                    value: updatedValue,\n                    selection: [selectionStart, selectionStart],\n                });\n            };\n            element.addEventListener('keydown', listener);\n            return () => element.removeEventListener('keydown', listener);\n        };\n}\nfunction createTimeSegmentsIndexes(fullMode) {\n    return new Map([\n        ['hours', getSegmentRange(fullMode, 'HH')],\n        ['minutes', getSegmentRange(fullMode, 'MM')],\n        ['seconds', getSegmentRange(fullMode, 'SS')],\n        ['milliseconds', getSegmentRange(fullMode, 'MSS')],\n    ]);\n}\nfunction getSegmentRange(mode, segment) {\n    const index = mode.indexOf(segment);\n    return index === -1 ? [-1, -1] : [index, index + segment.length];\n}\nfunction getActiveSegment({ segmentsIndexes, selectionStart, }) {\n    for (const [segmentName, segmentRange] of segmentsIndexes.entries()) {\n        const [from, to] = segmentRange;\n        if (from <= selectionStart && selectionStart <= to) {\n            return segmentName;\n        }\n    }\n    return null;\n}\nfunction updateSegmentValue({ selection, value, toAdd, max, }) {\n    const [from, to] = selection;\n    const segmentValue = Number(value.slice(from, to).padEnd(to - from, '0'));\n    const newSegmentValue = mod(segmentValue + toAdd, max + 1);\n    return (value.slice(0, from) +\n        String(newSegmentValue).padStart(to - from, '0') +\n        value.slice(to, value.length));\n}\nfunction mod(value, max) {\n    if (value < 0) {\n        value += Math.floor(Math.abs(value) / max + 1) * max;\n    }\n    return value % max;\n}\n\nfunction maskitoWithPlaceholder(placeholder, focusedOnly = false) {\n    let lastClearValue = '';\n    let action = 'validation';\n    const removePlaceholder = (value) => {\n        for (let i = value.length - 1; i >= lastClearValue.length; i--) {\n            if (value[i] !== placeholder[i]) {\n                return value.slice(0, i + 1);\n            }\n        }\n        return value.slice(0, lastClearValue.length);\n    };\n    const plugins = [maskitoCaretGuard((value) => [0, removePlaceholder(value).length])];\n    let focused = false;\n    if (focusedOnly) {\n        const focus = maskitoEventHandler('focus', (element) => {\n            focused = true;\n            maskitoUpdateElement(element, element.value + placeholder.slice(element.value.length));\n        }, { capture: true });\n        const blur = maskitoEventHandler('blur', (element) => {\n            focused = false;\n            maskitoUpdateElement(element, removePlaceholder(element.value));\n        }, { capture: true });\n        plugins.push(focus, blur);\n    }\n    return {\n        plugins,\n        removePlaceholder,\n        preprocessors: [\n            ({ elementState, data }, actionType) => {\n                action = actionType;\n                const { value, selection } = elementState;\n                return {\n                    elementState: {\n                        selection,\n                        value: removePlaceholder(value),\n                    },\n                    data,\n                };\n            },\n        ],\n        postprocessors: [\n            ({ value, selection }, initialElementState) => {\n                lastClearValue = value;\n                const justPlaceholderRemoval = value +\n                    placeholder.slice(value.length, initialElementState.value.length) ===\n                    initialElementState.value;\n                if (action === 'validation' && justPlaceholderRemoval) {\n                    /**\n                     * If `value` still equals to `initialElementState.value`,\n                     * then it means that value is patched programmatically (from Maskito's plugin or externally).\n                     * In this case, we don't want to mutate value and automatically add/remove placeholder.\n                     * ___\n                     * For example, developer wants to remove manually placeholder (+ do something else with value) on blur.\n                     * Without this condition, placeholder will be unexpectedly added again.\n                     */\n                    return { selection, value: initialElementState.value };\n                }\n                const newValue = focused || !focusedOnly\n                    ? value + placeholder.slice(value.length)\n                    : value;\n                if (newValue === initialElementState.value &&\n                    action === 'deleteBackward') {\n                    const [caretIndex] = initialElementState.selection;\n                    return {\n                        value: newValue,\n                        selection: [caretIndex, caretIndex],\n                    };\n                }\n                return { value: newValue, selection };\n            },\n        ],\n    };\n}\n\nfunction createZeroPlaceholdersPreprocessor() {\n    return ({ elementState }, actionType) => {\n        const { value, selection } = elementState;\n        if (!value || isLastChar(value, selection)) {\n            return { elementState };\n        }\n        const [from, to] = selection;\n        const zeroes = value.slice(from, to).replaceAll(/\\d/g, '0');\n        const newValue = value.slice(0, from) + zeroes + value.slice(to);\n        if (actionType === 'validation' || (actionType === 'insert' && from === to)) {\n            return {\n                elementState: { selection, value: newValue },\n            };\n        }\n        return {\n            elementState: {\n                selection: actionType === 'deleteBackward' || actionType === 'insert'\n                    ? [from, from]\n                    : [to, to],\n                value: newValue,\n            },\n        };\n    };\n}\nfunction isLastChar(value, [_, to]) {\n    return to === value.length;\n}\n\nfunction maskitoDateOptionsGenerator({ mode, separator = '.', max, min, }) {\n    const dateModeTemplate = mode.split('/').join(separator);\n    return Object.assign(Object.assign({}, MASKITO_DEFAULT_OPTIONS), { mask: Array.from(dateModeTemplate).map((char) => separator.includes(char) ? char : /\\d/), overwriteMode: 'replace', preprocessors: [\n            createFullWidthToHalfWidthPreprocessor(),\n            createZeroPlaceholdersPreprocessor(),\n            normalizeDatePreprocessor({\n                dateModeTemplate,\n                dateSegmentsSeparator: separator,\n            }),\n            createValidDatePreprocessor({\n                dateModeTemplate,\n                dateSegmentsSeparator: separator,\n            }),\n        ], postprocessors: [\n            createDateSegmentsZeroPaddingPostprocessor({\n                dateModeTemplate,\n                dateSegmentSeparator: separator,\n                splitFn: (value) => ({ dateStrings: [value] }),\n                uniteFn: ([dateString = '']) => dateString,\n            }),\n            createMinMaxDatePostprocessor({\n                min,\n                max,\n                dateModeTemplate,\n                dateSegmentSeparator: separator,\n            }),\n        ] });\n}\n\nconst POSSIBLE_DATE_RANGE_SEPARATOR = [\n    CHAR_HYPHEN,\n    CHAR_EN_DASH,\n    CHAR_EM_DASH,\n    CHAR_MINUS,\n    CHAR_JP_HYPHEN,\n];\n\nfunction createMinMaxRangeLengthPostprocessor({ dateModeTemplate, rangeSeparator, minLength, maxLength, max = DEFAULT_MAX_DATE, }) {\n    if (isEmpty(minLength) && isEmpty(maxLength)) {\n        return identity;\n    }\n    return ({ value, selection }) => {\n        const dateStrings = parseDateRangeString(value, dateModeTemplate, rangeSeparator);\n        if (dateStrings.length !== 2 ||\n            dateStrings.some((date) => !isDateStringComplete(date, dateModeTemplate))) {\n            return { value, selection };\n        }\n        const [fromDate, toDate] = dateStrings.map((dateString) => segmentsToDate(parseDateString(dateString, dateModeTemplate)));\n        if (!fromDate || !toDate) {\n            return { value, selection };\n        }\n        const minDistantToDate = appendDate(fromDate, Object.assign(Object.assign({}, minLength), { \n            // 06.02.2023 - 07.02.2023 => {minLength: {day: 3}} => 06.02.2023 - 08.02.2023\n            // \"from\"-day is included in the range\n            day: (minLength === null || minLength === void 0 ? void 0 : minLength.day) && minLength.day - 1 }));\n        const maxDistantToDate = !isEmpty(maxLength)\n            ? appendDate(fromDate, Object.assign(Object.assign({}, maxLength), { day: (maxLength === null || maxLength === void 0 ? void 0 : maxLength.day) && maxLength.day - 1 }))\n            : max;\n        const minLengthClampedToDate = clamp(toDate, minDistantToDate, max);\n        const minMaxLengthClampedToDate = minLengthClampedToDate > maxDistantToDate\n            ? maxDistantToDate\n            : minLengthClampedToDate;\n        return {\n            selection,\n            value: dateStrings[0] +\n                rangeSeparator +\n                toDateString(dateToSegments(minMaxLengthClampedToDate), {\n                    dateMode: dateModeTemplate,\n                }),\n        };\n    };\n}\n\nfunction createSwapDatesPostprocessor({ dateModeTemplate, rangeSeparator, }) {\n    return ({ value, selection }) => {\n        const dateStrings = parseDateRangeString(value, dateModeTemplate, rangeSeparator);\n        const isDateRangeComplete = dateStrings.length === 2 &&\n            dateStrings.every((date) => isDateStringComplete(date, dateModeTemplate));\n        const [from, to] = selection;\n        const caretAtTheEnd = from >= value.length;\n        const allValueSelected = from === 0 && to >= value.length; // dropping text inside with a pointer\n        if (!(caretAtTheEnd || allValueSelected) || !isDateRangeComplete) {\n            return { value, selection };\n        }\n        const [fromDate, toDate] = dateStrings.map((dateString) => segmentsToDate(parseDateString(dateString, dateModeTemplate)));\n        return {\n            selection,\n            value: fromDate && toDate && fromDate > toDate\n                ? dateStrings.reverse().join(rangeSeparator)\n                : value,\n        };\n    };\n}\n\nfunction maskitoDateRangeOptionsGenerator({ mode, min, max, minLength, maxLength, dateSeparator = '.', rangeSeparator = `${CHAR_NO_BREAK_SPACE}${CHAR_EN_DASH}${CHAR_NO_BREAK_SPACE}`, }) {\n    const dateModeTemplate = mode.split('/').join(dateSeparator);\n    const dateMask = Array.from(dateModeTemplate).map((char) => dateSeparator.includes(char) ? char : /\\d/);\n    return Object.assign(Object.assign({}, MASKITO_DEFAULT_OPTIONS), { mask: [...dateMask, ...Array.from(rangeSeparator), ...dateMask], overwriteMode: 'replace', preprocessors: [\n            createFullWidthToHalfWidthPreprocessor(),\n            createFirstDateEndSeparatorPreprocessor({\n                dateModeTemplate,\n                dateSegmentSeparator: dateSeparator,\n                firstDateEndSeparator: rangeSeparator,\n                pseudoFirstDateEndSeparators: POSSIBLE_DATE_RANGE_SEPARATOR,\n            }),\n            createZeroPlaceholdersPreprocessor(),\n            normalizeDatePreprocessor({\n                dateModeTemplate,\n                rangeSeparator,\n                dateSegmentsSeparator: dateSeparator,\n            }),\n            createValidDatePreprocessor({\n                dateModeTemplate,\n                rangeSeparator,\n                dateSegmentsSeparator: dateSeparator,\n            }),\n        ], postprocessors: [\n            createDateSegmentsZeroPaddingPostprocessor({\n                dateModeTemplate,\n                dateSegmentSeparator: dateSeparator,\n                splitFn: (value) => ({\n                    dateStrings: parseDateRangeString(value, dateModeTemplate, rangeSeparator),\n                }),\n                uniteFn: (validatedDateStrings, initialValue) => validatedDateStrings.reduce((acc, dateString, dateIndex) => acc +\n                    dateString +\n                    (!dateIndex && initialValue.includes(rangeSeparator)\n                        ? rangeSeparator\n                        : ''), ''),\n            }),\n            createMinMaxDatePostprocessor({\n                min,\n                max,\n                dateModeTemplate,\n                rangeSeparator,\n                dateSegmentSeparator: dateSeparator,\n            }),\n            createMinMaxRangeLengthPostprocessor({\n                dateModeTemplate,\n                minLength,\n                maxLength,\n                max,\n                rangeSeparator,\n            }),\n            createSwapDatesPostprocessor({\n                dateModeTemplate,\n                rangeSeparator,\n            }),\n        ] });\n}\n\nfunction padTimeSegments(timeSegments, pad) {\n    return Object.fromEntries(Object.entries(timeSegments).map(([segmentName, segmentValue]) => [\n        segmentName,\n        pad(String(segmentValue), TIME_SEGMENT_VALUE_LENGTHS[segmentName]),\n    ]));\n}\n\nfunction padEndTimeSegments(timeSegments) {\n    return padTimeSegments(timeSegments, (value, length) => value.padEnd(length, '0'));\n}\n\nfunction padStartTimeSegments(timeSegments) {\n    return padTimeSegments(timeSegments, (value, length) => value.padStart(length, '0'));\n}\n\nconst SEGMENT_FULL_NAME = {\n    HH: 'hours',\n    MM: 'minutes',\n    SS: 'seconds',\n    MSS: 'milliseconds',\n};\n/**\n * @param timeString can be with/without fixed characters\n */\nfunction parseTimeString(timeString, timeMode) {\n    const onlyDigits = timeString.replaceAll(/\\D+/g, '');\n    let offset = 0;\n    return Object.fromEntries(timeMode.split(/\\W/).map((segmentAbbr) => {\n        const segmentValue = onlyDigits.slice(offset, offset + segmentAbbr.length);\n        offset += segmentAbbr.length;\n        return [SEGMENT_FULL_NAME[segmentAbbr], segmentValue];\n    }));\n}\n\nconst LEADING_NON_DIGITS = /^\\D*/;\nconst TRAILING_NON_DIGITS = /\\D*$/;\nfunction toTimeString({ hours = '', minutes = '', seconds = '', milliseconds = '', }) {\n    return `${hours}:${minutes}:${seconds}.${milliseconds}`\n        .replace(LEADING_NON_DIGITS, '')\n        .replace(TRAILING_NON_DIGITS, '');\n}\n\nconst TRAILING_TIME_SEGMENT_SEPARATOR_REG = new RegExp(`[${TIME_FIXED_CHARACTERS.map(escapeRegExp).join('')}]$`);\nfunction validateTimeString({ timeString, paddedMaxValues, offset, selection: [from, to], timeMode, }) {\n    const parsedTime = parseTimeString(timeString, timeMode);\n    const possibleTimeSegments = Object.entries(parsedTime);\n    const validatedTimeSegments = {};\n    let paddedZeroes = 0;\n    for (const [segmentName, segmentValue] of possibleTimeSegments) {\n        const validatedTime = toTimeString(validatedTimeSegments);\n        const maxSegmentValue = paddedMaxValues[segmentName];\n        const fantomSeparator = validatedTime.length && 1;\n        const lastSegmentDigitIndex = offset +\n            validatedTime.length +\n            fantomSeparator +\n            TIME_SEGMENT_VALUE_LENGTHS[segmentName];\n        const isLastSegmentDigitAdded = lastSegmentDigitIndex >= from && lastSegmentDigitIndex <= to;\n        if (isLastSegmentDigitAdded && Number(segmentValue) > Number(maxSegmentValue)) {\n            // 2|0:00 => Type 9 => 2|0:00\n            return { validatedTimeString: '', updatedTimeSelection: [from, to] }; // prevent changes\n        }\n        const { validatedSegmentValue, prefixedZeroesCount } = padWithZeroesUntilValid(segmentValue, `${maxSegmentValue}`);\n        paddedZeroes += prefixedZeroesCount;\n        validatedTimeSegments[segmentName] = validatedSegmentValue;\n    }\n    const [trailingSegmentSeparator = ''] = timeString.match(TRAILING_TIME_SEGMENT_SEPARATOR_REG) || [];\n    const validatedTimeString = toTimeString(validatedTimeSegments) + trailingSegmentSeparator;\n    const addedDateSegmentSeparators = Math.max(validatedTimeString.length - timeString.length, 0);\n    return {\n        validatedTimeString,\n        updatedTimeSelection: [\n            from + paddedZeroes + addedDateSegmentSeparators,\n            to + paddedZeroes + addedDateSegmentSeparators,\n        ],\n    };\n}\n\nfunction isDateTimeStringComplete(dateTimeString, { dateMode, timeMode, dateTimeSeparator = DATE_TIME_SEPARATOR, }) {\n    return (dateTimeString.length >=\n        dateMode.length + timeMode.length + dateTimeSeparator.length &&\n        (dateTimeString.split(dateTimeSeparator)[0] || '')\n            .split(/\\D/)\n            .every((segment) => !segment.match(/^0+$/)));\n}\n\nfunction parseDateTimeString(dateTime, { dateModeTemplate, dateTimeSeparator, }) {\n    const hasSeparator = dateTime.includes(dateTimeSeparator);\n    return [\n        dateTime.slice(0, dateModeTemplate.length),\n        dateTime.slice(hasSeparator\n            ? dateModeTemplate.length + dateTimeSeparator.length\n            : dateModeTemplate.length),\n    ];\n}\n\nfunction createMinMaxDateTimePostprocessor({ dateModeTemplate, timeMode, min = DEFAULT_MIN_DATE, max = DEFAULT_MAX_DATE, dateTimeSeparator, }) {\n    return ({ value, selection }) => {\n        const [dateString, timeString] = parseDateTimeString(value, {\n            dateModeTemplate,\n            dateTimeSeparator,\n        });\n        const parsedDate = parseDateString(dateString, dateModeTemplate);\n        const parsedTime = parseTimeString(timeString, timeMode);\n        if (!isDateTimeStringComplete(value, {\n            dateMode: dateModeTemplate,\n            timeMode,\n            dateTimeSeparator,\n        })) {\n            const fixedDate = raiseSegmentValueToMin(parsedDate, dateModeTemplate);\n            const { year, month, day } = isDateStringComplete(dateString, dateModeTemplate)\n                ? dateToSegments(clamp(segmentsToDate(fixedDate), min, max))\n                : fixedDate;\n            const fixedValue = toDateString(Object.assign({ year,\n                month,\n                day }, parsedTime), { dateMode: dateModeTemplate, dateTimeSeparator, timeMode });\n            const tail = value.slice(fixedValue.length);\n            return {\n                selection,\n                value: fixedValue + tail,\n            };\n        }\n        const date = segmentsToDate(parsedDate, parsedTime);\n        const clampedDate = clamp(date, min, max);\n        const validatedValue = toDateString(dateToSegments(clampedDate), {\n            dateMode: dateModeTemplate,\n            dateTimeSeparator,\n            timeMode,\n        });\n        return {\n            selection,\n            value: validatedValue,\n        };\n    };\n}\n\nfunction createValidDateTimePreprocessor({ dateModeTemplate, dateSegmentsSeparator, dateTimeSeparator, timeMode, }) {\n    const invalidCharsRegExp = new RegExp(`[^\\\\d${TIME_FIXED_CHARACTERS.map(escapeRegExp).join('')}${escapeRegExp(dateSegmentsSeparator)}]+`);\n    return ({ elementState, data }) => {\n        const { value, selection } = elementState;\n        if (data === dateSegmentsSeparator) {\n            return {\n                elementState,\n                data: selection[0] === value.length ? data : '',\n            };\n        }\n        const newCharacters = data.replace(invalidCharsRegExp, '');\n        if (!newCharacters) {\n            return { elementState, data: '' };\n        }\n        const [from, rawTo] = selection;\n        let to = rawTo + data.length;\n        const newPossibleValue = value.slice(0, from) + newCharacters + value.slice(to);\n        const [dateString, timeString] = parseDateTimeString(newPossibleValue, {\n            dateModeTemplate,\n            dateTimeSeparator,\n        });\n        let validatedValue = '';\n        const hasDateTimeSeparator = newPossibleValue.includes(dateTimeSeparator);\n        const { validatedDateString, updatedSelection } = validateDateString({\n            dateString,\n            dateSegmentsSeparator,\n            dateModeTemplate,\n            offset: 0,\n            selection: [from, to],\n        });\n        if (dateString && !validatedDateString) {\n            return { elementState, data: '' }; // prevent changes\n        }\n        to = updatedSelection[1];\n        validatedValue += validatedDateString;\n        const paddedMaxValues = padStartTimeSegments(DEFAULT_TIME_SEGMENT_MAX_VALUES);\n        const { validatedTimeString, updatedTimeSelection } = validateTimeString({\n            timeString,\n            paddedMaxValues,\n            offset: validatedValue.length + dateTimeSeparator.length,\n            selection: [from, to],\n            timeMode,\n        });\n        if (timeString && !validatedTimeString) {\n            return { elementState, data: '' }; // prevent changes\n        }\n        to = updatedTimeSelection[1];\n        validatedValue += hasDateTimeSeparator\n            ? dateTimeSeparator + validatedTimeString\n            : validatedTimeString;\n        const newData = validatedValue.slice(from, to);\n        return {\n            elementState: {\n                selection,\n                value: validatedValue.slice(0, from) +\n                    newData\n                        .split(dateSegmentsSeparator)\n                        .map((segment) => '0'.repeat(segment.length))\n                        .join(dateSegmentsSeparator) +\n                    validatedValue.slice(to),\n            },\n            data: newData,\n        };\n    };\n}\n\nfunction maskitoDateTimeOptionsGenerator({ dateMode, timeMode, dateSeparator = '.', min, max, dateTimeSeparator = DATE_TIME_SEPARATOR, timeStep = 0, }) {\n    const dateModeTemplate = dateMode.split('/').join(dateSeparator);\n    return Object.assign(Object.assign({}, MASKITO_DEFAULT_OPTIONS), { mask: [\n            ...Array.from(dateModeTemplate).map((char) => dateSeparator.includes(char) ? char : /\\d/),\n            ...dateTimeSeparator.split(''),\n            ...Array.from(timeMode).map((char) => TIME_FIXED_CHARACTERS.includes(char) ? char : /\\d/),\n        ], overwriteMode: 'replace', preprocessors: [\n            createFullWidthToHalfWidthPreprocessor(),\n            createColonConvertPreprocessor(),\n            createFirstDateEndSeparatorPreprocessor({\n                dateModeTemplate,\n                dateSegmentSeparator: dateSeparator,\n                firstDateEndSeparator: dateTimeSeparator,\n                pseudoFirstDateEndSeparators: dateTimeSeparator.split(''),\n            }),\n            createZeroPlaceholdersPreprocessor(),\n            normalizeDatePreprocessor({\n                dateModeTemplate,\n                dateSegmentsSeparator: dateSeparator,\n                dateTimeSeparator,\n            }),\n            createValidDateTimePreprocessor({\n                dateModeTemplate,\n                dateSegmentsSeparator: dateSeparator,\n                dateTimeSeparator,\n                timeMode,\n            }),\n        ], postprocessors: [\n            createDateSegmentsZeroPaddingPostprocessor({\n                dateModeTemplate,\n                dateSegmentSeparator: dateSeparator,\n                splitFn: (value) => {\n                    const [dateString, timeString] = parseDateTimeString(value, {\n                        dateModeTemplate,\n                        dateTimeSeparator,\n                    });\n                    return { dateStrings: [dateString], restPart: timeString };\n                },\n                uniteFn: ([validatedDateString], initialValue) => validatedDateString +\n                    (initialValue.includes(dateTimeSeparator) ? dateTimeSeparator : ''),\n            }),\n            createMinMaxDateTimePostprocessor({\n                min,\n                max,\n                dateModeTemplate,\n                timeMode,\n                dateTimeSeparator,\n            }),\n        ], plugins: [\n            createTimeSegmentsSteppingPlugin({\n                step: timeStep,\n                fullMode: `${dateModeTemplate}${dateTimeSeparator}${timeMode}`,\n                timeSegmentMaxValues: DEFAULT_TIME_SEGMENT_MAX_VALUES,\n            }),\n        ] });\n}\n\n/**\n * It drops prefix and postfix from data\n * Needed for case, when prefix or postfix contain decimalSeparator, to ignore it in resulting number\n * @example User pastes '{prefix}123.45{postfix}' => 123.45\n */\nfunction createAffixesFilterPreprocessor({ prefix, postfix, }) {\n    return ({ elementState, data }) => {\n        const { cleanValue: cleanData } = extractAffixes(data, {\n            prefix,\n            postfix,\n        });\n        return {\n            elementState,\n            data: cleanData,\n        };\n    };\n}\n\nfunction generateMaskExpression({ decimalSeparator, isNegativeAllowed, precision, thousandSeparator, prefix, postfix, decimalPseudoSeparators = [], pseudoMinuses = [], minusSign, }) {\n    const computedPrefix = computeAllOptionalCharsRegExp(prefix);\n    const digit = String.raw `\\d`;\n    const optionalMinus = isNegativeAllowed\n        ? `[${minusSign}${pseudoMinuses.map((x) => `\\\\${x}`).join('')}]?`\n        : '';\n    const integerPart = thousandSeparator\n        ? `[${digit}${escapeRegExp(thousandSeparator).replaceAll(/\\s/g, String.raw `\\s`)}]*`\n        : `[${digit}]*`;\n    const decimalPart = precision > 0\n        ? `([${escapeRegExp(decimalSeparator)}${decimalPseudoSeparators\n            .map(escapeRegExp)\n            .join('')}]${digit}{0,${Number.isFinite(precision) ? precision : ''}})?`\n        : '';\n    const computedPostfix = computeAllOptionalCharsRegExp(postfix);\n    return new RegExp(`^${computedPrefix}${optionalMinus}${integerPart}${decimalPart}${computedPostfix}$`);\n}\nfunction computeAllOptionalCharsRegExp(str) {\n    return str\n        ? `${str\n            .split('')\n            .map((char) => `${escapeRegExp(char)}?`)\n            .join('')}`\n        : '';\n}\n\nfunction maskitoParseNumber(maskedNumber, decimalSeparator = '.') {\n    const hasNegativeSign = !!maskedNumber.match(new RegExp(`^\\\\D*[${CHAR_MINUS}\\\\${CHAR_HYPHEN}${CHAR_EN_DASH}${CHAR_EM_DASH}${CHAR_JP_HYPHEN}]`));\n    const escapedDecimalSeparator = escapeRegExp(decimalSeparator);\n    const unmaskedNumber = maskedNumber\n        // drop all decimal separators not followed by a digit\n        .replaceAll(new RegExp(`${escapedDecimalSeparator}(?!\\\\d)`, 'g'), '')\n        // drop all non-digit characters except decimal separator\n        .replaceAll(new RegExp(`[^\\\\d${escapedDecimalSeparator}]`, 'g'), '')\n        .replace(decimalSeparator, '.');\n    return unmaskedNumber\n        ? Number((hasNegativeSign ? CHAR_HYPHEN : '') + unmaskedNumber)\n        : NaN;\n}\n\n/**\n * Convert number to string with replacing exponent part on decimals\n *\n * @param value the number\n * @return string representation of a number\n */\nfunction stringifyNumberWithoutExp(value) {\n    const valueAsString = String(value);\n    const [numberPart = '', expPart] = valueAsString.split('e-');\n    let valueWithoutExp = valueAsString;\n    if (expPart) {\n        const [, fractionalPart] = numberPart.split('.');\n        const decimalDigits = Number(expPart) + ((fractionalPart === null || fractionalPart === void 0 ? void 0 : fractionalPart.length) || 0);\n        valueWithoutExp = value.toFixed(decimalDigits);\n    }\n    return valueWithoutExp;\n}\n\nfunction toNumberParts(value, { decimalSeparator, thousandSeparator, }) {\n    const [integerWithMinus = '', decimalPart = ''] = value.split(decimalSeparator);\n    const [, minus = '', integerPart = ''] = integerWithMinus.match(new RegExp(`([^\\\\d${escapeRegExp(thousandSeparator)}]+)?(.*)`)) || [];\n    return { minus, integerPart, decimalPart };\n}\n\nfunction validateDecimalPseudoSeparators({ decimalSeparator, thousandSeparator, decimalPseudoSeparators = DEFAULT_DECIMAL_PSEUDO_SEPARATORS, }) {\n    return decimalPseudoSeparators.filter((char) => char !== thousandSeparator && char !== decimalSeparator);\n}\n\n/**\n * If `decimalZeroPadding` is `true`, it pads decimal part with zeroes\n * (until number of digits after decimalSeparator is equal to the `precision`).\n * @example 1,42 => (`precision` is equal to 4) => 1,4200.\n */\nfunction createDecimalZeroPaddingPostprocessor({ decimalSeparator, precision, decimalZeroPadding, prefix, postfix, }) {\n    if (precision <= 0 || !decimalZeroPadding) {\n        return identity;\n    }\n    return ({ value, selection }) => {\n        const { cleanValue, extractedPrefix, extractedPostfix } = extractAffixes(value, {\n            prefix,\n            postfix,\n        });\n        if (Number.isNaN(maskitoParseNumber(cleanValue, decimalSeparator))) {\n            return { value, selection };\n        }\n        const [integerPart, decimalPart = ''] = cleanValue.split(decimalSeparator);\n        return {\n            value: extractedPrefix +\n                integerPart +\n                decimalSeparator +\n                decimalPart.padEnd(precision, '0') +\n                extractedPostfix,\n            selection,\n        };\n    };\n}\n\n/**\n * Make textfield empty if there is no integer part and all decimal digits are zeroes.\n * @example 0|,00 => Backspace => Empty.\n * @example -0|,00 => Backspace => -.\n * @example ,42| => Backspace x2 => ,|00 => Backspace => Empty\n */\nfunction emptyPostprocessor({ prefix, postfix, decimalSeparator, thousandSeparator, }) {\n    return ({ value, selection }) => {\n        const [caretIndex] = selection;\n        const { cleanValue, extractedPrefix, extractedPostfix } = extractAffixes(value, {\n            prefix,\n            postfix,\n        });\n        const { minus, integerPart, decimalPart } = toNumberParts(cleanValue, {\n            decimalSeparator,\n            thousandSeparator,\n        });\n        const aloneDecimalSeparator = !integerPart && !decimalPart && cleanValue.includes(decimalSeparator);\n        if ((!integerPart &&\n            !Number(decimalPart) &&\n            caretIndex === (minus + extractedPrefix).length) ||\n            aloneDecimalSeparator) {\n            return {\n                selection,\n                value: extractedPrefix + minus + extractedPostfix,\n            };\n        }\n        return { value, selection };\n    };\n}\n\n/**\n * This preprocessor works only once at initialization phase (when `new Maskito(...)` is executed).\n * This preprocessor helps to avoid conflicts during transition from one mask to another (for the same input).\n * For example, the developer changes postfix (or other mask's props) during run-time.\n * ```\n * let maskitoOptions = maskitoNumberOptionsGenerator({postfix: ' year'});\n * // [3 seconds later]\n * maskitoOptions = maskitoNumberOptionsGenerator({postfix: ' years'});\n * ```\n */\nfunction createInitializationOnlyPreprocessor({ decimalSeparator, decimalPseudoSeparators, pseudoMinuses, prefix, postfix, minusSign, }) {\n    let isInitializationPhase = true;\n    const cleanNumberMask = generateMaskExpression({\n        decimalSeparator,\n        decimalPseudoSeparators,\n        pseudoMinuses,\n        prefix: '',\n        postfix: '',\n        thousandSeparator: '',\n        precision: Infinity,\n        isNegativeAllowed: true,\n        minusSign,\n    });\n    return ({ elementState, data }) => {\n        if (!isInitializationPhase) {\n            return { elementState, data };\n        }\n        isInitializationPhase = false;\n        const { value, selection } = elementState;\n        const [from, to] = selection;\n        const { extractedPrefix, cleanValue, extractedPostfix } = extractAffixes(value, {\n            prefix,\n            postfix,\n        });\n        const cleanState = maskitoTransform({\n            selection: [\n                Math.max(from - extractedPrefix.length, 0),\n                clamp(to - extractedPrefix.length, 0, cleanValue.length),\n            ],\n            value: cleanValue,\n        }, {\n            mask: cleanNumberMask,\n        });\n        const [cleanFrom, cleanTo] = cleanState.selection;\n        return {\n            elementState: {\n                selection: [\n                    cleanFrom + extractedPrefix.length,\n                    cleanTo + extractedPrefix.length,\n                ],\n                value: extractedPrefix + cleanState.value + extractedPostfix,\n            },\n            data,\n        };\n    };\n}\n\n/**\n * It removes repeated leading zeroes for integer part.\n * @example 0,|00005 => Backspace => |5\n * @example -0,|00005 => Backspace => -|5\n * @example User types \"000000\" => 0|\n * @example 0| => User types \"5\" => 5|\n */\nfunction createLeadingZeroesValidationPostprocessor({ decimalSeparator, thousandSeparator, prefix, postfix, }) {\n    const trimLeadingZeroes = (value) => {\n        const escapedThousandSeparator = escapeRegExp(thousandSeparator);\n        return value\n            .replace(\n        // all leading zeroes followed by another zero\n        new RegExp(`^(\\\\D+)?[0${escapedThousandSeparator}]+(?=0)`), '$1')\n            .replace(\n        // zero followed by not-zero digit\n        new RegExp(`^(\\\\D+)?[0${escapedThousandSeparator}]+(?=[1-9])`), '$1');\n    };\n    const countTrimmedZeroesBefore = (value, index) => {\n        const valueBefore = value.slice(0, index);\n        const followedByZero = value.slice(index).startsWith('0');\n        return (valueBefore.length -\n            trimLeadingZeroes(valueBefore).length +\n            (followedByZero ? 1 : 0));\n    };\n    return ({ value, selection }) => {\n        const [from, to] = selection;\n        const { cleanValue, extractedPrefix, extractedPostfix } = extractAffixes(value, {\n            prefix,\n            postfix,\n        });\n        const hasDecimalSeparator = cleanValue.includes(decimalSeparator);\n        const [integerPart = '', decimalPart = ''] = cleanValue.split(decimalSeparator);\n        const zeroTrimmedIntegerPart = trimLeadingZeroes(integerPart);\n        if (integerPart === zeroTrimmedIntegerPart) {\n            return { value, selection };\n        }\n        const newFrom = from - countTrimmedZeroesBefore(value, from);\n        const newTo = to - countTrimmedZeroesBefore(value, to);\n        return {\n            value: extractedPrefix +\n                zeroTrimmedIntegerPart +\n                (hasDecimalSeparator ? decimalSeparator : '') +\n                decimalPart +\n                extractedPostfix,\n            selection: [Math.max(newFrom, 0), Math.max(newTo, 0)],\n        };\n    };\n}\n\n/**\n * This postprocessor is connected with {@link createMinMaxPlugin}:\n * both validate `min`/`max` bounds of entered value (but at the different point of time).\n */\nfunction createMinMaxPostprocessor({ min, max, decimalSeparator, minusSign, }) {\n    return ({ value, selection }) => {\n        const parsedNumber = maskitoParseNumber(value, decimalSeparator);\n        const limitedValue = \n        /**\n         * We cannot limit lower bound if user enters positive number.\n         * The same for upper bound and negative number.\n         * ___\n         * @example (min = 5)\n         * Empty input => Without this condition user cannot type 42 (the first digit will be rejected)\n         * ___\n         * @example (max = -10)\n         * Value is -10 => Without this condition user cannot delete 0 to enter another digit\n         */\n        parsedNumber > 0 ? Math.min(parsedNumber, max) : Math.max(parsedNumber, min);\n        if (parsedNumber && limitedValue !== parsedNumber) {\n            const newValue = `${limitedValue}`\n                .replace('.', decimalSeparator)\n                .replace(CHAR_HYPHEN, minusSign);\n            return {\n                value: newValue,\n                selection: [newValue.length, newValue.length],\n            };\n        }\n        return {\n            value,\n            selection,\n        };\n    };\n}\n\n/**\n * Manage caret-navigation when user \"deletes\" non-removable digits or separators\n * @example 1,|42 => Backspace => 1|,42 (only if `decimalZeroPadding` is `true`)\n * @example 1|,42 => Delete => 1,|42 (only if `decimalZeroPadding` is `true`)\n * @example 0,|00 => Delete => 0,0|0 (only if `decimalZeroPadding` is `true`)\n * @example 1 |000 => Backspace => 1| 000 (always)\n */\nfunction createNonRemovableCharsDeletionPreprocessor({ decimalSeparator, thousandSeparator, decimalZeroPadding, }) {\n    return ({ elementState, data }, actionType) => {\n        const { value, selection } = elementState;\n        const [from, to] = selection;\n        const selectedCharacters = value.slice(from, to);\n        const nonRemovableSeparators = decimalZeroPadding\n            ? [decimalSeparator, thousandSeparator]\n            : [thousandSeparator];\n        const areNonRemovableZeroesSelected = decimalZeroPadding &&\n            from > value.indexOf(decimalSeparator) &&\n            Boolean(selectedCharacters.match(/^0+$/gi));\n        if ((actionType !== 'deleteBackward' && actionType !== 'deleteForward') ||\n            (!nonRemovableSeparators.includes(selectedCharacters) &&\n                !areNonRemovableZeroesSelected)) {\n            return {\n                elementState,\n                data,\n            };\n        }\n        return {\n            elementState: {\n                value,\n                selection: actionType === 'deleteForward' ? [to, to] : [from, from],\n            },\n            data,\n        };\n    };\n}\n\n/**\n * It pads integer part with zero if user types decimal separator (for empty input).\n * @example Empty input => User types \",\" (decimal separator) => 0,|\n */\nfunction createNotEmptyIntegerPartPreprocessor({ decimalSeparator, precision, prefix, postfix, }) {\n    const startWithDecimalSepRegExp = new RegExp(`^\\\\D*${escapeRegExp(decimalSeparator)}`);\n    return ({ elementState, data }) => {\n        const { value, selection } = elementState;\n        const { cleanValue, extractedPrefix } = extractAffixes(value, {\n            prefix,\n            postfix,\n        });\n        const [from, to] = selection;\n        const cleanFrom = clamp(from - extractedPrefix.length, 0, cleanValue.length);\n        const cleanTo = clamp(to - extractedPrefix.length, 0, cleanValue.length);\n        if (precision <= 0 ||\n            cleanValue.slice(0, cleanFrom).includes(decimalSeparator) ||\n            cleanValue.slice(cleanTo).includes(decimalSeparator) ||\n            !data.match(startWithDecimalSepRegExp)) {\n            return { elementState, data };\n        }\n        const digitsBeforeCursor = cleanValue.slice(0, cleanFrom).match(/\\d+/);\n        return {\n            elementState,\n            data: digitsBeforeCursor ? data : `0${data}`,\n        };\n    };\n}\n\n/**\n * It replaces pseudo characters with valid one.\n * @example User types '.' (but separator is equal to comma) => dot is replaced with comma.\n * @example User types hyphen / en-dash / em-dash => it is replaced with minus.\n */\nfunction createPseudoCharactersPreprocessor({ validCharacter, pseudoCharacters, prefix, postfix, }) {\n    const pseudoCharactersRegExp = new RegExp(`[${pseudoCharacters.join('')}]`, 'gi');\n    return ({ elementState, data }) => {\n        const { value, selection } = elementState;\n        const { cleanValue, extractedPostfix, extractedPrefix } = extractAffixes(value, {\n            prefix,\n            postfix,\n        });\n        return {\n            elementState: {\n                selection,\n                value: extractedPrefix +\n                    cleanValue.replace(pseudoCharactersRegExp, validCharacter) +\n                    extractedPostfix,\n            },\n            data: data.replace(pseudoCharactersRegExp, validCharacter),\n        };\n    };\n}\n\n/**\n * It rejects new typed decimal separator if it already exists in text field.\n * Behaviour is similar to native <input type=\"number\"> (Chrome).\n * @example 1|23,45 => Press comma (decimal separator) => 1|23,45 (do nothing).\n */\nfunction createRepeatedDecimalSeparatorPreprocessor({ decimalSeparator, prefix, postfix, }) {\n    return ({ elementState, data }) => {\n        const { value, selection } = elementState;\n        const [from, to] = selection;\n        const { cleanValue } = extractAffixes(value, { prefix, postfix });\n        return {\n            elementState,\n            data: !cleanValue.includes(decimalSeparator) ||\n                value.slice(from, to + 1).includes(decimalSeparator)\n                ? data\n                : data.replaceAll(new RegExp(escapeRegExp(decimalSeparator), 'gi'), ''),\n        };\n    };\n}\n\n/**\n * It adds symbol for separating thousands.\n * @example 1000000 => (thousandSeparator is equal to space) => 1 000 000.\n */\nfunction createThousandSeparatorPostprocessor({ thousandSeparator, decimalSeparator, prefix, postfix, }) {\n    if (!thousandSeparator) {\n        return identity;\n    }\n    const isAllSpaces = (...chars) => chars.every((x) => /\\s/.test(x));\n    return ({ value, selection }) => {\n        const { cleanValue, extractedPostfix, extractedPrefix } = extractAffixes(value, {\n            prefix,\n            postfix,\n        });\n        const { minus, integerPart, decimalPart } = toNumberParts(cleanValue, {\n            decimalSeparator,\n            thousandSeparator,\n        });\n        const [initialFrom, initialTo] = selection;\n        let [from, to] = selection;\n        const processedIntegerPart = Array.from(integerPart).reduceRight((formattedValuePart, char, i) => {\n            const isLeadingThousandSeparator = !i && char === thousandSeparator;\n            const isPositionForSeparator = !isLeadingThousandSeparator &&\n                formattedValuePart.length &&\n                (formattedValuePart.length + 1) % 4 === 0;\n            if (isPositionForSeparator &&\n                (char === thousandSeparator || isAllSpaces(char, thousandSeparator))) {\n                return thousandSeparator + formattedValuePart;\n            }\n            if (char === thousandSeparator && !isPositionForSeparator) {\n                if (i && i <= initialFrom) {\n                    from--;\n                }\n                if (i && i <= initialTo) {\n                    to--;\n                }\n                return formattedValuePart;\n            }\n            if (!isPositionForSeparator) {\n                return char + formattedValuePart;\n            }\n            if (i <= initialFrom) {\n                from++;\n            }\n            if (i <= initialTo) {\n                to++;\n            }\n            return char + thousandSeparator + formattedValuePart;\n        }, '');\n        return {\n            value: extractedPrefix +\n                minus +\n                processedIntegerPart +\n                (cleanValue.includes(decimalSeparator) ? decimalSeparator : '') +\n                decimalPart +\n                extractedPostfix,\n            selection: [from, to],\n        };\n    };\n}\n\n/**\n * It drops decimal part if precision is zero.\n * @example User pastes '123.45' (but precision is zero) => 123\n */\nfunction createZeroPrecisionPreprocessor({ precision, decimalSeparator, prefix, postfix, }) {\n    if (precision > 0) {\n        return identity;\n    }\n    const decimalPartRegExp = new RegExp(`${escapeRegExp(decimalSeparator)}.*$`, 'g');\n    return ({ elementState, data }) => {\n        const { value, selection } = elementState;\n        const { cleanValue, extractedPrefix, extractedPostfix } = extractAffixes(value, {\n            prefix,\n            postfix,\n        });\n        const [from, to] = selection;\n        const newValue = extractedPrefix +\n            cleanValue.replace(decimalPartRegExp, '') +\n            extractedPostfix;\n        return {\n            elementState: {\n                selection: [\n                    Math.min(from, newValue.length),\n                    Math.min(to, newValue.length),\n                ],\n                value: newValue,\n            },\n            data: data.replace(decimalPartRegExp, ''),\n        };\n    };\n}\n\nconst DUMMY_SELECTION = [0, 0];\n/**\n * It removes repeated leading zeroes for integer part on blur-event.\n * @example 000000 => blur => 0\n * @example 00005 => blur => 5\n */\nfunction createLeadingZeroesValidationPlugin({ decimalSeparator, thousandSeparator, prefix, postfix, }) {\n    const dropRepeatedLeadingZeroes = createLeadingZeroesValidationPostprocessor({\n        decimalSeparator,\n        thousandSeparator,\n        prefix,\n        postfix,\n    });\n    return maskitoEventHandler('blur', (element) => {\n        const newValue = dropRepeatedLeadingZeroes({\n            value: element.value,\n            selection: DUMMY_SELECTION,\n        }, { value: '', selection: DUMMY_SELECTION }).value;\n        maskitoUpdateElement(element, newValue);\n    }, { capture: true });\n}\n\n/**\n * This plugin is connected with {@link createMinMaxPostprocessor}:\n * both validate `min`/`max` bounds of entered value (but at the different point of time).\n */\nfunction createMinMaxPlugin({ min, max, decimalSeparator, }) {\n    return maskitoEventHandler('blur', (element, options) => {\n        const parsedNumber = maskitoParseNumber(element.value, decimalSeparator);\n        const clampedNumber = clamp(parsedNumber, min, max);\n        if (!Number.isNaN(parsedNumber) && parsedNumber !== clampedNumber) {\n            maskitoUpdateElement(element, maskitoTransform(stringifyNumberWithoutExp(clampedNumber), options));\n        }\n    }, { capture: true });\n}\n\n/**\n * It pads EMPTY integer part with zero if decimal parts exists.\n * It works on blur event only!\n * @example 1|,23 => Backspace => Blur => 0,23\n */\nfunction createNotEmptyIntegerPlugin({ decimalSeparator, prefix, postfix, }) {\n    return maskitoEventHandler('blur', (element) => {\n        const { cleanValue, extractedPostfix, extractedPrefix } = extractAffixes(element.value, { prefix, postfix });\n        const newValue = extractedPrefix +\n            cleanValue.replace(new RegExp(`^(\\\\D+)?${escapeRegExp(decimalSeparator)}`), `$10${decimalSeparator}`) +\n            extractedPostfix;\n        maskitoUpdateElement(element, newValue);\n    }, { capture: true });\n}\n\nfunction maskitoNumberOptionsGenerator({ max = Number.MAX_SAFE_INTEGER, min = Number.MIN_SAFE_INTEGER, precision = 0, thousandSeparator = CHAR_NO_BREAK_SPACE, decimalSeparator = '.', decimalPseudoSeparators, decimalZeroPadding = false, prefix: unsafePrefix = '', postfix = '', minusSign = CHAR_MINUS, } = {}) {\n    const pseudoMinuses = [\n        CHAR_HYPHEN,\n        CHAR_EN_DASH,\n        CHAR_EM_DASH,\n        CHAR_JP_HYPHEN,\n        CHAR_MINUS,\n    ].filter((char) => char !== thousandSeparator && char !== decimalSeparator && char !== minusSign);\n    const validatedDecimalPseudoSeparators = validateDecimalPseudoSeparators({\n        decimalSeparator,\n        thousandSeparator,\n        decimalPseudoSeparators,\n    });\n    const prefix = unsafePrefix.endsWith(decimalSeparator) && precision > 0\n        ? `${unsafePrefix}${CHAR_ZERO_WIDTH_SPACE}`\n        : unsafePrefix;\n    return Object.assign(Object.assign({}, MASKITO_DEFAULT_OPTIONS), { mask: generateMaskExpression({\n            decimalSeparator,\n            precision,\n            thousandSeparator,\n            prefix,\n            postfix,\n            isNegativeAllowed: min < 0,\n            minusSign,\n        }), preprocessors: [\n            createFullWidthToHalfWidthPreprocessor(),\n            createInitializationOnlyPreprocessor({\n                decimalSeparator,\n                decimalPseudoSeparators: validatedDecimalPseudoSeparators,\n                pseudoMinuses,\n                prefix,\n                postfix,\n                minusSign,\n            }),\n            createAffixesFilterPreprocessor({ prefix, postfix }),\n            createPseudoCharactersPreprocessor({\n                validCharacter: minusSign,\n                pseudoCharacters: pseudoMinuses,\n                prefix,\n                postfix,\n            }),\n            createPseudoCharactersPreprocessor({\n                validCharacter: decimalSeparator,\n                pseudoCharacters: validatedDecimalPseudoSeparators,\n                prefix,\n                postfix,\n            }),\n            createNotEmptyIntegerPartPreprocessor({\n                decimalSeparator,\n                precision,\n                prefix,\n                postfix,\n            }),\n            createNonRemovableCharsDeletionPreprocessor({\n                decimalSeparator,\n                decimalZeroPadding,\n                thousandSeparator,\n            }),\n            createZeroPrecisionPreprocessor({\n                precision,\n                decimalSeparator,\n                prefix,\n                postfix,\n            }),\n            createRepeatedDecimalSeparatorPreprocessor({\n                decimalSeparator,\n                prefix,\n                postfix,\n            }),\n        ], postprocessors: [\n            createMinMaxPostprocessor({ decimalSeparator, min, max, minusSign }),\n            maskitoPrefixPostprocessorGenerator(prefix),\n            maskitoPostfixPostprocessorGenerator(postfix),\n            createThousandSeparatorPostprocessor({\n                decimalSeparator,\n                thousandSeparator,\n                prefix,\n                postfix,\n            }),\n            createDecimalZeroPaddingPostprocessor({\n                decimalSeparator,\n                decimalZeroPadding,\n                precision,\n                prefix,\n                postfix,\n            }),\n            emptyPostprocessor({ prefix, postfix, decimalSeparator, thousandSeparator }),\n        ], plugins: [\n            createLeadingZeroesValidationPlugin({\n                decimalSeparator,\n                thousandSeparator,\n                prefix,\n                postfix,\n            }),\n            createNotEmptyIntegerPlugin({\n                decimalSeparator,\n                prefix,\n                postfix,\n            }),\n            createMinMaxPlugin({ min, max, decimalSeparator }),\n        ], overwriteMode: decimalZeroPadding\n            ? ({ value, selection: [from] }) => from <= value.indexOf(decimalSeparator) ? 'shift' : 'replace'\n            : 'shift' });\n}\n\nfunction createMaxValidationPreprocessor(timeSegmentMaxValues, timeMode) {\n    const paddedMaxValues = padStartTimeSegments(timeSegmentMaxValues);\n    const invalidCharsRegExp = new RegExp(`[^\\\\d${TIME_FIXED_CHARACTERS.map(escapeRegExp).join('')}]+`);\n    return ({ elementState, data }, actionType) => {\n        if (actionType === 'deleteBackward' || actionType === 'deleteForward') {\n            return { elementState, data };\n        }\n        const { value, selection } = elementState;\n        if (actionType === 'validation') {\n            const { validatedTimeString, updatedTimeSelection } = validateTimeString({\n                timeString: value,\n                paddedMaxValues,\n                offset: 0,\n                selection,\n                timeMode,\n            });\n            return {\n                elementState: {\n                    value: validatedTimeString,\n                    selection: updatedTimeSelection,\n                },\n                data,\n            };\n        }\n        const newCharacters = data.replace(invalidCharsRegExp, '');\n        const [from, rawTo] = selection;\n        let to = rawTo + newCharacters.length; // to be conformed with `overwriteMode: replace`\n        const newPossibleValue = value.slice(0, from) + newCharacters + value.slice(to);\n        const { validatedTimeString, updatedTimeSelection } = validateTimeString({\n            timeString: newPossibleValue,\n            paddedMaxValues,\n            offset: 0,\n            selection: [from, to],\n            timeMode,\n        });\n        if (newPossibleValue && !validatedTimeString) {\n            return { elementState, data: '' }; // prevent changes\n        }\n        to = updatedTimeSelection[1];\n        const newData = validatedTimeString.slice(from, to);\n        return {\n            elementState: {\n                selection,\n                value: validatedTimeString.slice(0, from) +\n                    '0'.repeat(newData.length) +\n                    validatedTimeString.slice(to),\n            },\n            data: newData,\n        };\n    };\n}\n\nfunction maskitoTimeOptionsGenerator({ mode, timeSegmentMaxValues = {}, step = 0, }) {\n    const enrichedTimeSegmentMaxValues = Object.assign(Object.assign({}, DEFAULT_TIME_SEGMENT_MAX_VALUES), timeSegmentMaxValues);\n    return Object.assign(Object.assign({}, MASKITO_DEFAULT_OPTIONS), { mask: Array.from(mode).map((char) => TIME_FIXED_CHARACTERS.includes(char) ? char : /\\d/), preprocessors: [\n            createFullWidthToHalfWidthPreprocessor(),\n            createColonConvertPreprocessor(),\n            createZeroPlaceholdersPreprocessor(),\n            createMaxValidationPreprocessor(enrichedTimeSegmentMaxValues, mode),\n        ], plugins: [\n            createTimeSegmentsSteppingPlugin({\n                fullMode: mode,\n                step,\n                timeSegmentMaxValues: enrichedTimeSegmentMaxValues,\n            }),\n        ], overwriteMode: 'replace' });\n}\n\n/**\n * Converts a formatted time string to milliseconds based on the given `options.mode`.\n *\n * @param maskedTime a formatted time string by {@link maskitoTimeOptionsGenerator} or {@link maskitoStringifyTime}\n * @param params\n */\nfunction maskitoParseTime(maskedTime, { mode, timeSegmentMaxValues = {} }) {\n    var _a, _b, _c, _d;\n    const maxValues = Object.assign(Object.assign({}, DEFAULT_TIME_SEGMENT_MAX_VALUES), timeSegmentMaxValues);\n    const msInSecond = maxValues.milliseconds + 1;\n    const msInMinute = (maxValues.seconds + 1) * msInSecond;\n    const msInHour = (maxValues.minutes + 1) * msInMinute;\n    const parsedTime = padEndTimeSegments(parseTimeString(maskedTime, mode));\n    return (Number((_a = parsedTime.hours) !== null && _a !== void 0 ? _a : '') * msInHour +\n        Number((_b = parsedTime.minutes) !== null && _b !== void 0 ? _b : '') * msInMinute +\n        Number((_c = parsedTime.seconds) !== null && _c !== void 0 ? _c : '') * msInSecond +\n        Number((_d = parsedTime.milliseconds) !== null && _d !== void 0 ? _d : ''));\n}\n\n/**\n * Converts milliseconds to a formatted time string based on the given `options.mode`.\n *\n * @param milliseconds unsigned integer milliseconds\n * @param params\n */\nfunction maskitoStringifyTime(milliseconds, { mode, timeSegmentMaxValues = {} }) {\n    const maxValues = Object.assign(Object.assign({}, DEFAULT_TIME_SEGMENT_MAX_VALUES), timeSegmentMaxValues);\n    const msInSecond = maxValues.milliseconds + 1;\n    const msInMinute = (maxValues.seconds + 1) * msInSecond;\n    const msInHour = (maxValues.minutes + 1) * msInMinute;\n    const hours = Math.trunc(milliseconds / msInHour);\n    milliseconds -= hours * msInHour;\n    const minutes = Math.trunc(milliseconds / msInMinute);\n    milliseconds -= minutes * msInMinute;\n    const seconds = Math.trunc(milliseconds / msInSecond);\n    milliseconds -= seconds * msInSecond;\n    const result = padStartTimeSegments({ hours, minutes, seconds, milliseconds });\n    return mode\n        .replaceAll(/H+/g, result.hours)\n        .replaceAll('MSS', result.milliseconds)\n        .replaceAll(/M+/g, result.minutes)\n        .replaceAll(/S+/g, result.seconds);\n}\n\nexport { maskitoAddOnFocusPlugin, maskitoCaretGuard, maskitoDateOptionsGenerator, maskitoDateRangeOptionsGenerator, maskitoDateTimeOptionsGenerator, maskitoEventHandler, maskitoNumberOptionsGenerator, maskitoParseNumber, maskitoParseTime, maskitoPostfixPostprocessorGenerator, maskitoPrefixPostprocessorGenerator, maskitoRejectEvent, maskitoRemoveOnBlurPlugin, maskitoStringifyTime, maskitoTimeOptionsGenerator, maskitoWithPlaceholder };\n","popover-select-date {\n}\n","import {Component, h, Host, Element, Prop, State} from \"@stencil/core\";\nimport {Environment} from \"../../../../global/env\";\nimport {toZonedTime} from \"date-fns-tz\";\nimport {format, formatISO, isValid, parse} from \"date-fns\";\nimport {showDate} from \"../../../../helpers/utils\";\nimport {Maskito} from \"@maskito/core\";\nimport {\n  maskitoDateOptionsGenerator,\n  maskitoDateTimeOptionsGenerator,\n} from \"@maskito/kit\";\n\n@Component({\n  tag: \"popover-select-date\",\n  styleUrl: \"popover-select-date.scss\",\n})\nexport class PopoverSelectDate {\n  @Element() el: HTMLElement;\n  @State() inputValue: string;\n\n  @Prop() value: string;\n  @Prop() labelTag?: string;\n  @Prop() labelText?: string;\n  @Prop() labelReplace?: any;\n  @Prop() appendText?: any;\n  @Prop() datePresentation?:\n    | \"date\"\n    | \"date-time\"\n    | \"month\"\n    | \"month-year\"\n    | \"time\"\n    | \"time-date\"\n    | \"year\" = \"date\";\n  @Prop() preferWheel?: boolean = false; //prefer wheel type for dates\n  @Prop() showDateTitle?: boolean = true; //show date title for dates\n  @Prop() maxDate?: string;\n  localTime: Date;\n  @State() updateView = true;\n  targetTimeZone: string;\n  popover: HTMLIonPopoverElement;\n  maskedInput: Maskito;\n\n  componentWillLoad() {\n    // The target timezone, i.e., the user's local timezone\n    this.targetTimeZone = Intl.DateTimeFormat().resolvedOptions().timeZone;\n    // Convert the provided date string (in the original timezone) to the user's local time\n    this.setLocalTime(this.value);\n    this.popover = this.el.closest(\"ion-popover\");\n  }\n  componentDidLoad() {\n    this.initializeMask();\n  }\n\n  disconnectedCallback() {\n    this.maskedInput.destroy();\n  }\n\n  setLocalTime(date) {\n    // Parsing as UTC or specified timezone\n    this.localTime = toZonedTime(new Date(date), this.targetTimeZone);\n    this.inputValue = showDate(\n      formatISO(this.localTime),\n      this.datePresentation,\n      true\n    );\n    this.updateView = !this.updateView;\n  }\n\n  async initializeMask() {\n    const optionsDate = maskitoDateOptionsGenerator({\n      mode: \"dd/mm/yyyy\",\n      separator: \"/\",\n    });\n    const optionsDateTime = maskitoDateTimeOptionsGenerator({\n      dateMode: \"dd/mm/yyyy\",\n      timeMode: \"HH:MM\",\n      dateSeparator: \"/\",\n    });\n    const ionInput = document.querySelector(\n      \"#dateInput\"\n    ) as HTMLIonInputElement;\n    const nativeEl = await ionInput.getInputElement();\n    this.maskedInput = new Maskito(\n      nativeEl,\n      this.datePresentation == \"date\" ? optionsDate : optionsDateTime\n    );\n  }\n\n  handleChange(ev) {\n    this.value = ev.detail.value;\n    this.setLocalTime(this.value);\n  }\n\n  handleInputChange(ev) {\n    const inputDate = ev.target.value;\n    const parsedDate = parse(\n      inputDate,\n      this.datePresentation == \"date\" ? \"dd/MM/yyyy\" : \"dd/MM/yyyy HH:ss\",\n      new Date()\n    );\n    if (isValid(parsedDate)) {\n      this.value = formatISO(parsedDate);\n      this.setLocalTime(this.value);\n    }\n  }\n\n  close() {\n    this.popover.dismiss();\n  }\n  save() {\n    //save in database in UTC format\n    const utcDate = toZonedTime(this.value, \"UTC\");\n    const formatDate = format(utcDate, \"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'\");\n    this.popover.dismiss(formatDate);\n  }\n\n  render() {\n    return (\n      <Host>\n        <ion-content>\n          <ion-datetime\n            color={Environment.getAppColor()}\n            presentation={this.datePresentation}\n            prefer-wheel={this.preferWheel}\n            show-default-title={!this.showDateTitle}\n            onIonChange={(ev) => this.handleChange(ev)}\n            max={this.maxDate}\n            value={formatISO(this.localTime)}\n          >\n            {this.showDateTitle ? (\n              <span slot=\"title\">\n                {this.labelTag ? (\n                  <my-transl\n                    tag={this.labelTag}\n                    text={this.labelText}\n                    replace={this.labelReplace}\n                  ></my-transl>\n                ) : this.labelText ? (\n                  this.labelText\n                ) : undefined}\n                {this.appendText ? this.appendText : undefined}\n              </span>\n            ) : undefined}\n          </ion-datetime>\n          {this.datePresentation == \"date-time\" ||\n          this.datePresentation == \"time-date\" ||\n          this.datePresentation == \"date\" ? (\n            <ion-item>\n              <ion-input\n                id=\"dateInput\"\n                fill=\"outline\"\n                type=\"text\"\n                debounce={300}\n                inputmode=\"numeric\"\n                value={this.inputValue}\n                onIonInput={(ev) => this.handleInputChange(ev)}\n              ></ion-input>\n            </ion-item>\n          ) : undefined}\n        </ion-content>\n        <ion-footer>\n          <app-modal-footer\n            onCancelEmit={() => this.close()}\n            onSaveEmit={() => this.save()}\n          />\n        </ion-footer>\n      </Host>\n    );\n  }\n}\n"],"mappings":"4VAIO,SAASA,EAAeC,EAAMC,GACjC,MAAMC,EAAMC,EAAkBF,GAC9B,MAAO,kBAAmBC,EAAME,EAAYF,EAAKF,GAAQK,EAAYH,EAAKF,EAC9E,CACA,MAAMM,EAAY,CACdC,KAAM,EACNC,MAAO,EACPC,IAAK,EACLC,KAAM,EACNC,OAAQ,EACRC,OAAQ,GAEZ,SAASR,EAAYF,EAAKF,GACtB,IACI,MAAMa,EAAYX,EAAIY,cAAcd,GACpC,MAAMe,EAAS,GACf,IAAK,IAAIC,EAAI,EAAGA,EAAIH,EAAUI,OAAQD,IAAK,CACvC,MAAME,EAAMZ,EAAUO,EAAUG,GAAGG,MACnC,GAAID,IAAQE,UAAW,CACnBL,EAAOG,GAAOG,SAASR,EAAUG,GAAGM,MAAO,GAC3D,CACA,CACQ,OAAOP,CACf,CACI,MAAOQ,GACH,GAAIA,aAAiBC,WAAY,CAC7B,MAAO,CAACC,IACpB,CACQ,MAAMF,CACd,CACA,CACA,SAASlB,EAAYH,EAAKF,GACtB,MAAMa,EAAYX,EAAIwB,OAAO1B,GAE7B,MAAM2B,EAAS,0CAA0CC,KAAKf,GAG9D,MAAO,CACHQ,SAASM,EAAO,GAAI,IACpBN,SAASM,EAAO,GAAI,IACpBN,SAASM,EAAO,GAAI,IACpBN,SAASM,EAAO,GAAI,IACpBN,SAASM,EAAO,GAAI,IACpBN,SAASM,EAAO,GAAI,IAE5B,CAIA,MAAME,EAAW,GACjB,SAAS1B,EAAkBF,GACvB,IAAK4B,EAAS5B,GAAW,CAErB,MAAM6B,EAAoB,IAAIC,KAAKC,eAAe,QAAS,CACvDC,UAAW,MACXhC,SAAU,mBACVM,KAAM,UACNC,MAAO,UACPC,IAAK,UACLC,KAAM,UACNC,OAAQ,UACRC,OAAQ,YACTc,OAAO,IAAIQ,KAAK,6BACnB,MAAMC,EAAqBL,IAAsB,wBAC7CA,IAAsB,iCAC1BD,EAAS5B,GAAYkC,EACf,IAAIJ,KAAKC,eAAe,QAAS,CAC/BC,UAAW,MACXhC,SAAUA,EACVM,KAAM,UACNC,MAAO,UACPC,IAAK,UACLC,KAAM,UACNC,OAAQ,UACRC,OAAQ,YAEV,IAAImB,KAAKC,eAAe,QAAS,CAC/BI,OAAQ,MACRnC,SAAUA,EACVM,KAAM,UACNC,MAAO,UACPC,IAAK,UACLC,KAAM,UACNC,OAAQ,UACRC,OAAQ,WAExB,CACI,OAAOiB,EAAS5B,EACpB,CCrFO,SAASoC,EAAWC,EAAU9B,EAAOC,EAAKC,EAAMC,EAAQC,EAAQ2B,GACnE,MAAMC,EAAU,IAAIN,KAAK,GACzBM,EAAQC,eAAeH,EAAU9B,EAAOC,GACxC+B,EAAQE,YAAYhC,EAAMC,EAAQC,EAAQ2B,GAC1C,OAAOC,CACX,CCVA,MAAMG,EAAuB,KAC7B,MAAMC,EAAyB,IAC/B,MAAMC,EAAW,CACbC,SAAU,aACVC,UAAW,QACXC,WAAY,gBACZC,aAAc,4BAGX,SAASC,EAAgBC,EAAgBnD,EAAMoD,GAElD,IAAKD,EAAgB,CACjB,OAAO,CACf,CAEI,IAAIE,EAAQR,EAASE,UAAUnB,KAAKuB,GACpC,GAAIE,EAAO,CACP,OAAO,CACf,CACI,IAAIC,EACJ,IAAIC,EAEJF,EAAQR,EAASG,WAAWpB,KAAKuB,GACjC,GAAIE,EAAO,CACPC,EAAQjC,SAASgC,EAAM,GAAI,IAC3B,IAAKG,EAAiBF,GAAQ,CAC1B,OAAO7B,GACnB,CACQ,QAAS6B,EAAQX,EACzB,CAEIU,EAAQR,EAASI,aAAarB,KAAKuB,GACnC,GAAIE,EAAO,CACPC,EAAQjC,SAASgC,EAAM,GAAI,IAC3B,MAAMI,EAAUpC,SAASgC,EAAM,GAAI,IACnC,IAAKG,EAAiBF,EAAOG,GAAU,CACnC,OAAOhC,GACnB,CACQ8B,EAAiBG,KAAKC,IAAIL,GAASX,EAAuBc,EAAUb,EACpE,OAAOS,EAAM,KAAO,KAAOE,EAAiBA,CACpD,CAEI,GAAIK,EAA0BT,GAAiB,CAC3CnD,EAAO,IAAIkC,KAAKlC,GAAQkC,KAAK2B,OAC7B,MAAMrB,EAAUY,EAAYpD,EAAO8D,EAAU9D,GAC7C,MAAM+D,EAASC,EAAWxB,EAASW,GACnC,MAAMc,EAAcb,EAAYW,EAASG,EAAUlE,EAAM+D,EAAQZ,GACjE,OAAQc,CAChB,CACI,OAAOxC,GACX,CACA,SAASqC,EAAU9D,GACf,OAAOqC,EAAWrC,EAAKmE,cAAenE,EAAKoE,WAAYpE,EAAKqE,UAAWrE,EAAKsE,WAAYtE,EAAKuE,aAAcvE,EAAKwE,aAAcxE,EAAKyE,kBACvI,CACA,SAAST,EAAWhE,EAAMmD,GACtB,MAAMuB,EAAS3E,EAAeC,EAAMmD,GAEpC,MAAMwB,EAAQtC,EAAWqC,EAAO,GAAIA,EAAO,GAAK,EAAGA,EAAO,GAAIA,EAAO,GAAK,GAAIA,EAAO,GAAIA,EAAO,GAAI,GAAGE,UACvG,IAAIC,EAAO7E,EAAK4E,UAChB,MAAME,EAAOD,EAAO,IACpBA,GAAQC,GAAQ,EAAIA,EAAO,IAAOA,EAClC,OAAOH,EAAQE,CACnB,CACA,SAASX,EAAUlE,EAAM+D,EAAQZ,GAC7B,MAAM4B,EAAU/E,EAAK4E,UAErB,IAAII,EAAWD,EAAUhB,EAEzB,MAAMkB,EAAKjB,EAAW,IAAI9B,KAAK8C,GAAW7B,GAE1C,GAAIY,IAAWkB,EAAI,CACf,OAAOlB,CACf,CAEIiB,GAAYC,EAAKlB,EAEjB,MAAMmB,EAAKlB,EAAW,IAAI9B,KAAK8C,GAAW7B,GAC1C,GAAI8B,IAAOC,EAAI,CACX,OAAOD,CACf,CAEI,OAAOvB,KAAKyB,IAAIF,EAAIC,EACxB,CACA,SAAS1B,EAAiBF,EAAOG,GAC7B,OAAQ,IAAMH,GAASA,GAAS,KAAOG,GAAW,MAAS,GAAKA,GAAWA,GAAW,GAC1F,CACA,MAAM2B,EAAyB,GAC/B,SAASxB,EAA0ByB,GAC/B,GAAID,EAAuBC,GACvB,OAAO,KACX,IAEID,EAAuBC,GAAkB,KACzC,OAAO,IACf,CACI,MAAO9D,GACH,OAAO,KACf,CACA,CCzFO,SAAS+D,EAAgCtF,GAC5C,MAAMwC,EAAU,IAAIN,KAAKA,KAAKqD,IAAIvF,EAAKmE,cAAenE,EAAKoE,WAAYpE,EAAKqE,UAAWrE,EAAKsE,WAAYtE,EAAKuE,aAAcvE,EAAKwE,aAAcxE,EAAKyE,oBACnJjC,EAAQC,eAAezC,EAAKmE,eAC5B,OAAQnE,GAAQwC,CACpB,CCdO,MAAMgD,EAAY,0ECEzB,MAAM7C,EAAuB,KAC7B,MAAMC,EAAyB,IAC/B,MAAM6C,EAA4B,EAClC,MAAM5C,EAAW,CACb6C,gBAAiB,wBACjBC,YAAa,mBACbC,UAAW,IAEXC,GAAI,YACJC,IAAK,CACD,gBACA,gBACA,iBAEJC,KAAM,WACNC,MAAO,CACH,eACA,eACA,gBAGJC,GAAI,aACJC,IAAK,cACLC,KAAM,uBACNC,IAAK,eACLC,KAAM,wBACNC,GAAI,sBACJC,KAAM,+BACNC,OAAQ,wCAERvG,SAAUuF,GA4CP,SAASiB,EAAOC,EAAUC,EAAU,IACvC,GAAIC,UAAU3F,OAAS,EAAG,CACtB,MAAM,IAAI4F,UAAU,iCAAmCD,UAAU3F,OAAS,WAClF,CACI,GAAIyF,IAAa,KAAM,CACnB,OAAO,IAAIxE,KAAKT,IACxB,CACI,MAAMqF,EAAmBH,EAAQG,kBAAoB,KAAOrB,EAA4BsB,OAAOJ,EAAQG,kBACvG,GAAIA,IAAqB,GAAKA,IAAqB,GAAKA,IAAqB,EAAG,CAC5E,MAAM,IAAItF,WAAW,qCAC7B,CAEI,GAAIkF,aAAoBxE,aACZwE,IAAa,UAAYM,OAAOC,UAAUC,SAASC,KAAKT,KAAc,gBAAkB,CAEhG,OAAO,IAAIxE,KAAKwE,EAAS9B,UACjC,MACS,UAAW8B,IAAa,UACzBM,OAAOC,UAAUC,SAASC,KAAKT,KAAc,kBAAmB,CAChE,OAAO,IAAIxE,KAAKwE,EACxB,MACS,KAAMM,OAAOC,UAAUC,SAASC,KAAKT,KAAc,mBAAoB,CACxE,OAAO,IAAIxE,KAAKT,IACxB,CACI,MAAM2F,EAAcC,EAAgBX,GACpC,MAAMnG,KAAEA,EAAI+G,eAAEA,GAAmBC,EAAUH,EAAYpH,KAAM8G,GAC7D,MAAM9G,EAAOwH,EAAUF,EAAgB/G,GACvC,GAAIP,IAAS,MAAQyH,MAAMzH,EAAK4E,WAAY,CACxC,OAAO,IAAI1C,KAAKT,IACxB,CACI,GAAIzB,EAAM,CACN,MAAM0H,EAAY1H,EAAK4E,UACvB,IAAI+C,EAAO,EACX,IAAI5D,EACJ,GAAIqD,EAAYO,KAAM,CAClBA,EAAOC,EAAUR,EAAYO,MAC7B,GAAIA,IAAS,MAAQF,MAAME,GAAO,CAC9B,OAAO,IAAIzF,KAAKT,IAChC,CACA,CACQ,GAAI2F,EAAYnH,UAAY0G,EAAQ1G,SAAU,CAC1C8D,EAASb,EAAgBkE,EAAYnH,UAAY0G,EAAQ1G,SAAU,IAAIiC,KAAKwF,EAAYC,IACxF,GAAIF,MAAM1D,GAAS,CACf,OAAO,IAAI7B,KAAKT,IAChC,CACA,KACa,CAEDsC,EAASuB,EAAgC,IAAIpD,KAAKwF,EAAYC,IAC9D5D,EAASuB,EAAgC,IAAIpD,KAAKwF,EAAYC,EAAO5D,GACjF,CACQ,OAAO,IAAI7B,KAAKwF,EAAYC,EAAO5D,EAC3C,KACS,CACD,OAAO,IAAI7B,KAAKT,IACxB,CACA,CACA,SAAS4F,EAAgBQ,GACrB,MAAMT,EAAc,GACpB,IAAIU,EAAQjF,EAAS6C,gBAAgB9D,KAAKiG,GAC1C,IAAIE,EACJ,IAAKD,EAAO,CACRA,EAAQjF,EAAS8C,YAAY/D,KAAKiG,GAClC,GAAIC,EAAO,CACPV,EAAYpH,KAAO8H,EAAM,GACzBC,EAAaD,EAAM,EAC/B,KACa,CACDV,EAAYpH,KAAO,KACnB+H,EAAaF,CACzB,CACA,KACS,CACDT,EAAYpH,KAAO8H,EAAM,GACzBC,EAAaD,EAAM,EAC3B,CACI,GAAIC,EAAY,CACZ,MAAM1E,EAAQR,EAAS5C,SAAS2B,KAAKmG,GACrC,GAAI1E,EAAO,CACP+D,EAAYO,KAAOI,EAAWC,QAAQ3E,EAAM,GAAI,IAChD+D,EAAYnH,SAAWoD,EAAM,GAAG4E,MAC5C,KACa,CACDb,EAAYO,KAAOI,CAC/B,CACA,CACI,OAAOX,CACX,CACA,SAASG,EAAUM,EAAYf,GAC3B,GAAIe,EAAY,CACZ,MAAMK,EAAarF,EAASiD,IAAIgB,GAChC,MAAMqB,EAAetF,EAASmD,MAAMc,GAEpC,IAAIzD,EAAQR,EAASkD,KAAKnE,KAAKiG,IAAeM,EAAavG,KAAKiG,GAChE,GAAIxE,EAAO,CACP,MAAM+E,EAAa/E,EAAM,GACzB,MAAO,CACH9C,KAAMc,SAAS+G,EAAY,IAC3Bd,eAAgBO,EAAWQ,MAAMD,EAAWnH,QAE5D,CAEQoC,EAAQR,EAASgD,GAAGjE,KAAKiG,IAAeK,EAAWtG,KAAKiG,GACxD,GAAIxE,EAAO,CACP,MAAMiF,EAAgBjF,EAAM,GAC5B,MAAO,CACH9C,KAAMc,SAASiH,EAAe,IAAM,IACpChB,eAAgBO,EAAWQ,MAAMC,EAAcrH,QAE/D,CACA,CAEI,MAAO,CACHV,KAAM,KAEd,CACA,SAASiH,EAAUK,EAAYtH,GAE3B,GAAIA,IAAS,KAAM,CACf,OAAO,IACf,CACI,IAAIP,EACJ,IAAIQ,EACJ,IAAI+H,EAEJ,IAAKV,IAAeA,EAAW5G,OAAQ,CACnCjB,EAAO,IAAIkC,KAAK,GAChBlC,EAAKyC,eAAelC,GACpB,OAAOP,CACf,CAEI,IAAIqD,EAAQR,EAASoD,GAAGrE,KAAKiG,GAC7B,GAAIxE,EAAO,CACPrD,EAAO,IAAIkC,KAAK,GAChB1B,EAAQa,SAASgC,EAAM,GAAI,IAAM,EACjC,IAAKmF,EAAajI,EAAMC,GAAQ,CAC5B,OAAO,IAAI0B,KAAKT,IAC5B,CACQzB,EAAKyC,eAAelC,EAAMC,GAC1B,OAAOR,CACf,CAEIqD,EAAQR,EAASqD,IAAItE,KAAKiG,GAC1B,GAAIxE,EAAO,CACPrD,EAAO,IAAIkC,KAAK,GAChB,MAAMuG,EAAYpH,SAASgC,EAAM,GAAI,IACrC,IAAKqF,EAAsBnI,EAAMkI,GAAY,CACzC,OAAO,IAAIvG,KAAKT,IAC5B,CACQzB,EAAKyC,eAAelC,EAAM,EAAGkI,GAC7B,OAAOzI,CACf,CAEIqD,EAAQR,EAASsD,KAAKvE,KAAKiG,GAC3B,GAAIxE,EAAO,CACPrD,EAAO,IAAIkC,KAAK,GAChB1B,EAAQa,SAASgC,EAAM,GAAI,IAAM,EACjC,MAAM5C,EAAMY,SAASgC,EAAM,GAAI,IAC/B,IAAKmF,EAAajI,EAAMC,EAAOC,GAAM,CACjC,OAAO,IAAIyB,KAAKT,IAC5B,CACQzB,EAAKyC,eAAelC,EAAMC,EAAOC,GACjC,OAAOT,CACf,CAEIqD,EAAQR,EAASuD,IAAIxE,KAAKiG,GAC1B,GAAIxE,EAAO,CACPkF,EAAOlH,SAASgC,EAAM,GAAI,IAAM,EAChC,IAAKsF,EAAiBJ,GAAO,CACzB,OAAO,IAAIrG,KAAKT,IAC5B,CACQ,OAAOmH,EAAiBrI,EAAMgI,EACtC,CAEIlF,EAAQR,EAASwD,KAAKzE,KAAKiG,GAC3B,GAAIxE,EAAO,CACPkF,EAAOlH,SAASgC,EAAM,GAAI,IAAM,EAChC,MAAMwF,EAAYxH,SAASgC,EAAM,GAAI,IAAM,EAC3C,IAAKsF,EAAiBJ,EAAMM,GAAY,CACpC,OAAO,IAAI3G,KAAKT,IAC5B,CACQ,OAAOmH,EAAiBrI,EAAMgI,EAAMM,EAC5C,CAEI,OAAO,IACX,CACA,SAASjB,EAAUG,GACf,IAAIzE,EACJ,IAAIG,EAEJ,IAAIJ,EAAQR,EAASyD,GAAG1E,KAAKmG,GAC7B,GAAI1E,EAAO,CACPC,EAAQwF,WAAWzF,EAAM,GAAG2E,QAAQ,IAAK,MACzC,IAAKe,EAAazF,GAAQ,CACtB,OAAO7B,GACnB,CACQ,OAAQ6B,EAAQ,GAAMX,CAC9B,CAEIU,EAAQR,EAAS0D,KAAK3E,KAAKmG,GAC3B,GAAI1E,EAAO,CACPC,EAAQjC,SAASgC,EAAM,GAAI,IAC3BI,EAAUqF,WAAWzF,EAAM,GAAG2E,QAAQ,IAAK,MAC3C,IAAKe,EAAazF,EAAOG,GAAU,CAC/B,OAAOhC,GACnB,CACQ,OAAQ6B,EAAQ,GAAMX,EAAuBc,EAAUb,CAC/D,CAEIS,EAAQR,EAAS2D,OAAO5E,KAAKmG,GAC7B,GAAI1E,EAAO,CACPC,EAAQjC,SAASgC,EAAM,GAAI,IAC3BI,EAAUpC,SAASgC,EAAM,GAAI,IAC7B,MAAM2F,EAAUF,WAAWzF,EAAM,GAAG2E,QAAQ,IAAK,MACjD,IAAKe,EAAazF,EAAOG,EAASuF,GAAU,CACxC,OAAOvH,GACnB,CACQ,OAAQ6B,EAAQ,GAAMX,EAAuBc,EAAUb,EAAyBoG,EAAU,GAClG,CAEI,OAAO,IACX,CACA,SAASJ,EAAiBK,EAAaV,EAAM9H,GACzC8H,EAAOA,GAAQ,EACf9H,EAAMA,GAAO,EACb,MAAMT,EAAO,IAAIkC,KAAK,GACtBlC,EAAKyC,eAAewG,EAAa,EAAG,GACpC,MAAMC,EAAqBlJ,EAAKmJ,aAAe,EAC/C,MAAMC,EAAOb,EAAO,EAAI9H,EAAM,EAAIyI,EAClClJ,EAAKqJ,WAAWrJ,EAAKsJ,aAAeF,GACpC,OAAOpJ,CACX,CAEA,MAAMuJ,EAAgB,CAAC,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,IACnE,MAAMC,EAA0B,CAAC,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,GAAI,IAC7E,SAASC,EAAgBlJ,GACrB,OAAOA,EAAO,MAAQ,GAAMA,EAAO,IAAM,GAAKA,EAAO,MAAQ,CACjE,CACA,SAASiI,EAAajI,EAAMC,EAAOR,GAC/B,GAAIQ,EAAQ,GAAKA,EAAQ,GAAI,CACzB,OAAO,KACf,CACI,GAAIR,GAAQ,KAAM,CACd,GAAIA,EAAO,EAAG,CACV,OAAO,KACnB,CACQ,MAAM0J,EAAaD,EAAgBlJ,GACnC,GAAImJ,GAAc1J,EAAOwJ,EAAwBhJ,GAAQ,CACrD,OAAO,KACnB,CACQ,IAAKkJ,GAAc1J,EAAOuJ,EAAc/I,GAAQ,CAC5C,OAAO,KACnB,CACA,CACI,OAAO,IACX,CACA,SAASkI,EAAsBnI,EAAMkI,GACjC,GAAIA,EAAY,EAAG,CACf,OAAO,KACf,CACI,MAAMiB,EAAaD,EAAgBlJ,GACnC,GAAImJ,GAAcjB,EAAY,IAAK,CAC/B,OAAO,KACf,CACI,IAAKiB,GAAcjB,EAAY,IAAK,CAChC,OAAO,KACf,CACI,OAAO,IACX,CACA,SAASE,EAAiBJ,EAAM9H,GAC5B,GAAI8H,EAAO,GAAKA,EAAO,GAAI,CACvB,OAAO,KACf,CACI,GAAI9H,GAAO,OAASA,EAAM,GAAKA,EAAM,GAAI,CACrC,OAAO,KACf,CACI,OAAO,IACX,CACA,SAASsI,EAAazF,EAAOG,EAASuF,GAClC,GAAI1F,EAAQ,GAAKA,GAAS,GAAI,CAC1B,OAAO,KACf,CACI,GAAIG,GAAW,OAASA,EAAU,GAAKA,GAAW,IAAK,CACnD,OAAO,KACf,CACI,GAAIuF,GAAW,OAASA,EAAU,GAAKA,GAAW,IAAK,CACnD,OAAO,KACf,CACI,OAAO,IACX,CCpVO,SAASW,EAAY3J,EAAMC,EAAU0G,GACxC3G,EAAOyG,EAAOzG,EAAM2G,GACpB,MAAMiD,EAAqB1G,EAAgBjD,EAAUD,EAAM,MAC3D,MAAM6J,EAAI,IAAI3H,KAAKlC,EAAK4E,UAAYgF,GACpC,MAAME,EAAa,IAAI5H,KAAK,GAC5B4H,EAAWC,YAAYF,EAAEG,iBAAkBH,EAAEI,cAAeJ,EAAEP,cAC9DQ,EAAWI,SAASL,EAAEM,cAAeN,EAAEO,gBAAiBP,EAAEQ,gBAAiBR,EAAES,sBAC7E,OAAOR,CACX,CCkCA,MAAMS,EAA0B,CAC5BC,KAAM,OACNC,cAAe,GACfC,eAAgB,GAChBC,QAAS,GACTC,cAAe,SAGnB,MAAMC,EACF,WAAAC,GACIC,KAAKlH,IAAM,KACXkH,KAAKC,KAAO,GACZD,KAAKE,OAAS,EACtB,CACI,IAAAC,GACI,MAAMC,EAAQJ,KAAKC,KAAKI,MACxB,GAAID,GAASJ,KAAKlH,IAAK,CACnBkH,KAAKE,OAAOI,KAAKN,KAAKlH,KACtBkH,KAAKO,cAAcH,EAAO,cACtC,CACA,CACI,IAAAI,GACI,MAAMJ,EAAQJ,KAAKE,OAAOG,MAC1B,GAAID,GAASJ,KAAKlH,IAAK,CACnBkH,KAAKC,KAAKK,KAAKN,KAAKlH,KACpBkH,KAAKO,cAAcH,EAAO,cACtC,CACA,CACI,aAAAK,CAAcL,GACV,IAAKJ,KAAKlH,IAAK,CACXkH,KAAKlH,IAAMsH,EACX,MACZ,CACQ,MAAMM,EAAiBV,KAAKlH,IAAIvC,QAAU6J,EAAM7J,MAChD,MAAMoK,EAAqBX,KAAKlH,IAAI8H,UAAUC,MAAK,CAACC,EAAMC,IAAUD,IAASV,EAAMQ,UAAUG,KAC7F,IAAKL,IAAmBC,EAAoB,CACxC,MACZ,CACQ,GAAID,EAAgB,CAChBV,KAAKC,KAAKK,KAAKN,KAAKlH,KACpBkH,KAAKE,OAAS,EAC1B,CACQF,KAAKlH,IAAMsH,CACnB,CACI,aAAAG,CAAcH,EAAOY,GACjBhB,KAAKlH,IAAMsH,EACXJ,KAAKiB,mBAAmBb,EAAO,CAAEY,YAAWE,KAAM,MAC1D,EAGA,SAASC,EAAsBC,KAAgBC,GAC3C,OAAOA,EAAOC,OAAM,EAAG/K,WAAYA,IAAU6K,EAAY7K,OAC7D,CACA,SAASgL,EAAsBH,KAAgBC,GAC3C,OAAOA,EAAOC,OAAM,EAAG/K,QAAOqK,eAAgBrK,IAAU6K,EAAY7K,OAChEqK,EAAU,KAAOQ,EAAYR,UAAU,IACvCA,EAAU,KAAOQ,EAAYR,UAAU,IAC/C,CAEA,SAASY,GAAmBjL,MAAEA,EAAKqK,UAAEA,GAAaa,EAAeC,GAC7D,MAAOC,EAAMC,GAAMhB,EACnB,MAAMiB,SAAsBH,IAAS,WAAaA,EAAK,CAAEnL,QAAOqK,cAAec,EAC/E,MAAO,CACHnL,QACAqK,UAAWiB,IAAiB,UAAY,CAACF,EAAMA,EAAOF,EAAcvL,QAAU,CAACyL,EAAMC,GAE7F,CAEA,SAASE,EAAiBC,GACtB,cAAcA,IAAS,QAC3B,CAEA,SAASC,EAA0BvC,EAAMwC,EAAoBC,EAAcC,GACvE,IAAIC,EAAyB,GAC7B,IAAK,IAAInM,EAAIgM,EAAmB/L,OAAQD,EAAIwJ,EAAKvJ,OAAQD,IAAK,CAC1D,MAAMoM,EAAiB5C,EAAKxJ,IAAM,GAClC,MAAMqM,GAAsBH,IAAwB,MAAQA,SAA6B,OAAS,EAAIA,EAAoB5L,MAAMN,MAAQoM,EACxI,IAAKP,EAAiBO,IACjBA,IAAmBH,IAAiBI,EAAqB,CAC1D,OAAOF,CACnB,CACQA,GAA0BC,CAClC,CACI,OAAOD,CACX,CAEA,SAASG,EAAsBhM,EAAOiM,GAClC,GAAIC,MAAMC,QAAQF,GAAiB,CAC/B,OAAQjM,EAAML,SAAWsM,EAAetM,QACpCuM,MAAMd,KAAKpL,GAAO+K,OAAM,CAACS,EAAM9L,KAC3B,MAAMoM,EAAiBG,EAAevM,IAAM,GAC5C,OAAO6L,EAAiBO,GAClBN,IAASM,EACTN,EAAKY,MAAMN,EAAe,GAEhD,CACI,OAAOG,EAAeI,KAAKrM,EAC/B,CAEA,SAASsM,EAAyBC,EAAcrD,EAAM0C,GAClD,IAAIY,EAAa,KACjB,IAAIC,EAAW,KACf,MAAMC,EAAcR,MAAMd,KAAKmB,EAAavM,OAAO2M,QAAO,CAACC,EAAqBpB,EAAMqB,KAClF,MAAMC,EAAoBrB,EAA0BvC,EAAM0D,EAAqBpB,EAAMI,GACrF,MAAMmB,EAAoBH,EAAsBE,EAChD,MAAMhB,EAAiB5C,EAAK6D,EAAkBpN,SAAW,GACzD,GAAI4L,EAAiBO,GAAiB,CAClC,OAAOiB,EAAoBjB,CACvC,CACQ,IAAKN,EAAKY,MAAMN,GAAiB,CAC7B,OAAOiB,CACnB,CACQ,GAAIP,IAAe,MAAQK,GAAaN,EAAalC,UAAU,GAAI,CAC/DmC,EAAaO,EAAkBpN,MAC3C,CACQ,GAAI8M,IAAa,MAAQI,GAAaN,EAAalC,UAAU,GAAI,CAC7DoC,EAAWM,EAAkBpN,MACzC,CACQ,OAAOoN,EAAoBvB,CAAI,GAChC,IACH,MAAMwB,EAA0BvB,EAA0BvC,EAAMwD,EAAa,GAAId,GACjF,MAAO,CACH5L,MAAOgM,EAAsBU,EAAcM,EAAyB9D,GAC9DwD,EAAcM,EACdN,EACNrC,UAAW,CAACmC,IAAe,MAAQA,SAAoB,EAAIA,EAAaE,EAAY/M,OAAQ8M,IAAa,MAAQA,SAAkB,EAAIA,EAAWC,EAAY/M,QAEtK,CAEA,SAASsN,GAAwBjN,MAAEA,EAAKqK,UAAEA,GAAa6C,GACnD,MAAO9B,EAAMC,GAAMhB,EACnB,IAAI8C,EAAU/B,EACd,IAAIgC,EAAQ/B,EACZ,MAAMgC,EAAiBnB,MAAMd,KAAKpL,GAAO2M,QAAO,CAACjB,EAAoBF,EAAM9L,KACvE,MAAM4N,EAAmB5B,EAAqBF,EAC9C,GAAIJ,IAAS1L,EAAG,CACZyN,EAAUzB,EAAmB/L,MACzC,CACQ,GAAI0L,IAAO3L,EAAG,CACV0N,EAAQ1B,EAAmB/L,MACvC,CACQ,OAAO2N,EAAiBlB,MAAMc,GAAcI,EAAmB5B,CAAkB,GAClF,IACH,MAAO,CAAE1L,MAAOqN,EAAgBhD,UAAW,CAAC8C,EAASC,GACzD,CAEA,SAASG,GAAqBhB,EAAcrD,EAAM0C,EAAsB,MACpE,GAAII,EAAsBO,EAAavM,MAAOkJ,GAAO,CACjD,OAAOqD,CACf,CACI,MAAMvM,MAAEA,EAAKqK,UAAEA,GAAc6B,MAAMC,QAAQjD,GACrCoD,EAAyBC,EAAcrD,EAAM0C,GAC7CqB,EAAwBV,EAAcrD,GAC5C,MAAO,CACHmB,YACArK,MAAOkM,MAAMC,QAAQjD,GAAQlJ,EAAM+G,MAAM,EAAGmC,EAAKvJ,QAAUK,EAEnE,CAEA,SAASwN,GAA0B5B,EAAqB1C,GACpD,IAAKgD,MAAMC,QAAQjD,GAAO,CACtB,OAAO0C,CACf,CACI,MAAOR,EAAMC,GAAMO,EAAoBvB,UACvC,MAAMA,EAAY,GAClB,MAAMoD,EAAgBvB,MAAMd,KAAKQ,EAAoB5L,OAAO2M,QAAO,CAACe,EAAUlC,EAAM9L,KAChF,MAAMoM,EAAiB5C,EAAKxJ,IAAM,GAClC,GAAIA,IAAM0L,EAAM,CACZf,EAAUN,KAAK2D,EAAS/N,OACpC,CACQ,GAAID,IAAM2L,EAAI,CACVhB,EAAUN,KAAK2D,EAAS/N,OACpC,CACQ,OAAO4L,EAAiBO,IAAmBA,IAAmBN,EACxDkC,EACAA,EAAWlC,CAAI,GACtB,IACH,GAAInB,EAAU1K,OAAS,EAAG,CACtB0K,EAAUN,QAAQ,IAAImC,MAAM,EAAI7B,EAAU1K,QAAQgO,KAAKF,EAAc9N,QAC7E,CACI,MAAO,CACHK,MAAOyN,EACPpD,UAAW,CAACA,EAAU,GAAIA,EAAU,IAE5C,CAEA,MAAMuD,GACF,WAAApE,CAAYoC,EAAqBiC,GAC7BpE,KAAKmC,oBAAsBA,EAC3BnC,KAAKoE,YAAcA,EACnBpE,KAAKzJ,MAAQ,GACbyJ,KAAKY,UAAY,CAAC,EAAG,GACrB,MAAMrK,MAAEA,EAAKqK,UAAEA,GAAckD,GAAqB9D,KAAKmC,oBAAqBnC,KAAKqE,kBAAkBrE,KAAKmC,sBACxGnC,KAAKzJ,MAAQA,EACbyJ,KAAKY,UAAYA,CACzB,CACI,aAAA0D,EAAe3C,EAAMC,GAAKH,GACtB,MAAMlL,MAAEA,EAAK6N,YAAEA,GAAgBpE,KAC/B,MAAMwC,EAAiBxC,KAAKqE,kBAAkB,CAC1C9N,MAAOA,EAAM+G,MAAM,EAAGqE,GAAQF,EAAgBlL,EAAM+G,MAAMsE,GAC1DhB,UAAW,CAACe,EAAOF,EAAcvL,OAAQyL,EAAOF,EAAcvL,UAElE,MAAMiM,EAAsB,CAAE5L,QAAOqK,UAAW,CAACe,EAAMC,IACvD,MAAM2C,EAAuBR,GAA0B5B,EAAqBK,GAC5E,MAAOgC,EAAcC,GAAcjD,EAAmB+C,EAAsB9C,EAAe2C,EAAYvE,eAAee,UACtH,MAAM8D,EAA8BH,EAAqBhO,MAAM+G,MAAM,EAAGkH,GAAgB/C,EACxF,MAAMkD,EAAgBD,EAA4BxO,OAClD,MAAM0O,EAAqBd,GAAqB,CAC5CvN,MAAOmO,EACHH,EAAqBhO,MAAM+G,MAAMmH,GACrC7D,UAAW,CAAC+D,EAAeA,IAC5BnC,EAAgBL,GACnB,MAAM0C,EAENtO,EAAM+G,MAAM,EAAGkH,KACXV,GAAqB,CACjBvN,MAAOmO,EACP9D,UAAW,CAAC+D,EAAeA,IAC5BnC,EAAgBL,GAAqB5L,MAC5C,GAAIsO,GACAtD,EAAsBvB,KAAM4E,GAC9B,CACE,MAAM,IAAIE,MAAM,qBAC5B,CACQ9E,KAAKzJ,MAAQqO,EAAmBrO,MAChCyJ,KAAKY,UAAYgE,EAAmBhE,SAC5C,CACI,gBAAAmE,EAAkBpD,EAAMC,IACpB,GAAID,IAASC,IAAOA,EAAI,CACpB,MACZ,CACQ,MAAMrL,MAAEA,GAAUyJ,KAClB,MAAMwC,EAAiBxC,KAAKqE,kBAAkB,CAC1C9N,MAAOA,EAAM+G,MAAM,EAAGqE,GAAQpL,EAAM+G,MAAMsE,GAC1ChB,UAAW,CAACe,EAAMA,KAEtB,MAAMQ,EAAsB,CAAE5L,QAAOqK,UAAW,CAACe,EAAMC,IACvD,MAAM2C,EAAuBR,GAA0B5B,EAAqBK,GAC5E,MAAOgC,EAAcC,GAAcF,EAAqB3D,UACxD,MAAMoE,EAAmBT,EAAqBhO,MAAM+G,MAAM,EAAGkH,GACzDD,EAAqBhO,MAAM+G,MAAMmH,GACrC,MAAMG,EAAqBd,GAAqB,CAAEvN,MAAOyO,EAAkBpE,UAAW,CAAC4D,EAAcA,IAAiBhC,EAAgBL,GACtInC,KAAKzJ,MAAQqO,EAAmBrO,MAChCyJ,KAAKY,UAAYgE,EAAmBhE,SAC5C,CACI,iBAAAyD,CAAkBvB,GACd,MAAMrD,KAAEA,GAASO,KAAKoE,YACtB,cAAc3E,IAAS,WAAaA,EAAKqD,GAAgBrD,CACjE,EAGA,MAAMwF,GACF,WAAAlF,CAAYmF,GACRlF,KAAKkF,QAAUA,EACflF,KAAKmF,UAAY,EACzB,CACI,MAAAC,CAAOC,EAAWC,EAAI1J,GAClB,MAAM2J,EAAYD,EAClBtF,KAAKkF,QAAQM,iBAAiBH,EAAWE,EAAW3J,GACpDoE,KAAKmF,UAAU7E,MAAK,IAAMN,KAAKkF,QAAQO,oBAAoBJ,EAAWE,IAC9E,CACI,OAAAG,GACI1F,KAAKmF,UAAUQ,SAASC,GAAeA,KAC/C,EAGA,MAAMC,GAAiB,CACnBC,KAAM,GAAK,EACXC,IAAK,GAAK,EACVC,MAAO,GAAK,EACZC,KAAM,GAAK,GAGf,MAAMC,GAAa,CACfC,EAAG,GACHC,EAAG,IAeP,SAASC,GAASC,EAAOC,EAAWC,GAChC,OAAQF,EAAMG,aAAeF,EAAYV,GAAeC,OACpDQ,EAAMI,YAAcH,EAAYV,GAAeE,MAC/CO,EAAMK,cAAgBJ,EAAYV,GAAeG,QACjDM,EAAMM,aAAeL,EAAYV,GAAeI,OAMhDK,EAAMO,UAAYL,CAC1B,CAEA,SAASM,GAAOR,GACZ,OAAQD,GAASC,EAAOT,GAAeC,KAAMI,GAAWC,IACpDE,GAASC,EAAOT,GAAeC,KAAOD,GAAeG,MAAOE,GAAWE,IACvEC,GAASC,EAAOT,GAAeI,KAAOJ,GAAeG,MAAOE,GAAWE,EAE/E,CACA,SAASW,GAAOT,GACZ,OAAQD,GAASC,EAAOT,GAAeC,KAAMI,GAAWE,IACpDC,GAASC,EAAOT,GAAeI,KAAMC,GAAWE,EAExD,CAcA,SAASY,GAAqB9B,EAAS+B,GACnC,IAAIC,EACJ,MAAMC,EAAejC,EAAQ3O,MAC7B,UAAW0Q,IAAwB,SAAU,CACzC/B,EAAQ3O,MAAQ0Q,CACxB,KACS,CACD,MAAOtF,EAAMC,GAAMqF,EAAoBrG,UACvCsE,EAAQ3O,MAAQ0Q,EAAoB1Q,MACpC,GAAI2O,EAAQkC,QAAQ,UAAW,EAC1BF,EAAKhC,EAAQmC,qBAAuB,MAAQH,SAAY,OAAS,EAAIA,EAAG9K,KAAK8I,EAASvD,EAAMC,EACzG,CACA,CACI,GAAIsD,EAAQ3O,QAAU4Q,EAAc,CAChCjC,EAAQoC,cAAc,IAAIC,MAAM,QAOhC,CAAEC,QAAS,OACnB,CACA,CAEA,SAASC,IAAiBlR,MAAEA,EAAKqK,UAAEA,GAAa8G,GAC5C,MAAO/F,EAAMC,GAAMhB,EACnB,GAAIe,IAASC,EAAI,CACb,MAAO,CAACD,EAAMC,EACtB,CACI,MAAM+F,EAAeD,EACfnR,EAAM+G,MAAMqE,GAAMiG,QAAQ,MAAQ,GAAKrR,EAAML,OAC7CK,EAAM+G,MAAM,EAAGsE,GAAIiG,YAAY,MAAQ,EAC7C,MAAMC,EAAaJ,EAAY/F,EAAOgG,EACtC,MAAMI,EAAWL,EAAYC,EAAe/F,EAC5C,MAAO,CAACkG,EAAYC,EACxB,CAEA,SAASC,IAAqBzR,MAAEA,EAAKqK,UAAEA,GAAa8G,GAChD,MAAO/F,EAAMC,GAAMhB,EACnB,GAAIe,IAASC,EAAI,CACb,MAAO,CAACD,EAAMC,EACtB,CACI,MAAMqG,EAAoBP,EAAY,CAAC/F,EAAMC,EAAK,GAAK,CAACD,EAAO,EAAGC,GAClE,OAAOqG,EAAkBC,KAAKC,GAAMxP,KAAKyP,IAAIzP,KAAKyB,IAAI+N,EAAG,GAAI5R,EAAML,SACvE,CAEA,MAAMmS,GAAsB,QAC5B,MAAMC,GAAqB,QAC3B,MAAMC,GAAY,KAClB,SAASC,IAAiBjS,MAAEA,EAAKqK,UAAEA,GAAa8G,GAC5C,MAAO/F,EAAMC,GAAMhB,EACnB,GAAIe,IAASC,EAAI,CACb,MAAO,CAACD,EAAMC,EACtB,CACI,GAAI8F,EAAW,CACX,MAAMe,EAA2BlS,EAAM+G,MAAMqE,GAC7C,MAAO+G,GAAiBD,EAAyB9F,MAAM2F,KAAuB,CAC1E,IAEJ,MAAMK,EAAsBF,EACvBG,YACAC,OAAON,IACZ,MAAO,CACH5G,EACAgH,KAAyB,EACnBhH,EAAO+G,EAAcxS,OAASyS,EAC9BpS,EAAML,OAExB,CACI,MAAM4S,EAA0BvS,EAAM+G,MAAM,EAAGsE,GAC/C,MAAOmH,GAAkBD,EAAwBnG,MAAM0F,KAAwB,CAAC,IAChF,MAAMW,EAAqBF,EACtBG,UACAC,MAAM,IACNC,UACAC,WAAWrH,GAASA,EAAKY,MAAM4F,MACpC,MAAO,CACHS,KAAwB,EAAIpH,EAAKmH,EAAe7S,OAAS8S,EAAqB,EAC9EpH,EAER,CAMA,SAASyH,GAAYC,EAAa,IAC9B,MAAO,CAACC,KAAgBC,IAAiBF,EAAWpG,QAAO,CAAChC,EAAMoE,IAAQrJ,OAAOwN,OAAOxN,OAAOwN,OAAO,GAAIvI,GAAOoE,EAAGpE,KAASsI,KAAiBD,EAClJ,CAEA,SAASG,GAAiBC,EAAcC,GACpC,MAAMhO,EAAUK,OAAOwN,OAAOxN,OAAOwN,OAAO,GAAIjK,GAA0BoK,GAC1E,MAAMC,EAAeR,GAAYzN,EAAQ8D,eACzC,MAAMoK,EAAgBT,GAAYzN,EAAQ+D,gBAC1C,MAAMwC,SAA6BwH,IAAiB,SAC9C,CAAEpT,MAAOoT,EAAc/I,UAAW,CAAC,EAAG,IACtC+I,EACN,MAAM7G,aAAEA,GAAiB+G,EAAa,CAAE/G,aAAcX,EAAqBjB,KAAM,IAAM,cACvF,MAAM6I,EAAY,IAAI5F,GAAUrB,EAAclH,GAC9C,MAAMrF,MAAEA,EAAKqK,UAAEA,GAAckJ,EAAcC,EAAW5H,GACtD,cAAcwH,IAAiB,SAAWpT,EAAQ,CAAEA,QAAOqK,YAC/D,CAEA,MAAMoJ,WAAgBlK,EAClB,WAAAC,CAAYmF,EAAS0E,GACjBK,QACAjK,KAAKkF,QAAUA,EACflF,KAAK4J,eAAiBA,EACtB5J,KAAKkK,WAAalK,KAAKkF,QAAQiF,WAAa,WAC5CnK,KAAKoK,cAAgB,IAAInF,GAAcjF,KAAKkF,SAC5ClF,KAAKpE,QAAUK,OAAOwN,OAAOxN,OAAOwN,OAAO,GAAIjK,GAA0BQ,KAAK4J,gBAC9E5J,KAAK6J,aAAeR,GAAYrJ,KAAKpE,QAAQ8D,eAC7CM,KAAK8J,cAAgBT,GAAYrJ,KAAKpE,QAAQ+D,gBAC9CK,KAAKqK,UAAYrK,KAAKpE,QAAQgE,QAAQsI,KAAKoC,GAAWA,EAAOtK,KAAKkF,QAASlF,KAAKpE,WAChFoE,KAAKS,cAAcT,KAAK8C,cACxB9C,KAAKoK,cAAchF,OAAO,WAAYkB,IAClC,GAAIQ,GAAOR,GAAQ,CACfA,EAAMiE,iBACN,OAAOvK,KAAKQ,MAC5B,CACY,GAAIuG,GAAOT,GAAQ,CACfA,EAAMiE,iBACN,OAAOvK,KAAKG,MAC5B,KAEQH,KAAKoK,cAAchF,OAAO,eAAgBkB,IACtC,IAAIY,EACJ,MAAMQ,EAAYpB,EAAMtF,UAAUwJ,SAAS,WAC3CxK,KAAKS,cAAcT,KAAK8C,cACxB,OAAQwD,EAAMtF,WAEV,IAAK,cACDsF,EAAMiE,iBACN,OAAOvK,KAAKG,OAChB,IAAK,cACDmG,EAAMiE,iBACN,OAAOvK,KAAKQ,OAChB,IAAK,cACL,IAAK,wBACL,IAAK,uBACD,OAAOR,KAAKyK,aAAa,CACrBnE,QACAoB,YACA9G,UAAWoH,GAAqBhI,KAAK8C,aAAc4E,KAE3D,IAAK,oBACL,IAAK,qBACD,OAAO1H,KAAKyK,aAAa,CACrBnE,QACAoB,YACA9G,UAAW4H,GAAiBxI,KAAK8C,aAAc4E,GAC/CgD,MAAO,OAEf,IAAK,yBACL,IAAK,wBACL,IAAK,yBACL,IAAK,wBACD,OAAO1K,KAAKyK,aAAa,CACrBnE,QACAoB,YACA9G,UAAW6G,GAAiBzH,KAAK8C,aAAc4E,GAC/CgD,MAAO,OAEf,IAAK,wBACD,OACJ,IAAK,wBAeD,OACJ,IAAK,kBACL,IAAK,kBACD,OAAO1K,KAAK2K,YAAYrE,GAC5B,IAAK,kBACL,IAAK,aACL,IAAK,iBACL,QACI,OAAOtG,KAAK4K,aAAatE,EAAOA,EAAMpF,QAGjCgG,EAAKZ,EAAMuE,gBAAkB,MAAQ3D,SAAY,OAAS,EAAIA,EAAG4D,QAAQ,gBAC1E,IACxB,IAEQ9K,KAAKoK,cAAchF,OAAO,SAAS,EAAGpE,gBAClC,GAAIA,IAAc,wBAAyB,CACvC,MAChB,CACYhB,KAAK+K,sBACL/K,KAAKS,cAAcT,KAAK8C,aAAa,IAEzC9C,KAAKoK,cAAchF,OAAO,kBAAkB,KACxCpF,KAAK+K,sBACL/K,KAAKS,cAAcT,KAAK8C,aAAa,GAEjD,CACI,gBAAIA,GACA,MAAMvM,MAAEA,EAAKyU,eAAEA,EAAcC,aAAEA,GAAiBjL,KAAKkF,QACrD,MAAO,CACH3O,QACAqK,UAAW,CAACoK,GAAkB,EAAGC,GAAgB,GAE7D,CACI,aAAIC,GACA,MAAMA,UAAEA,GAAclL,KAAKkF,QAC3B,OAAOgG,KAAe,EAAIC,SAAWD,CAC7C,CACI,OAAAxF,GACI1F,KAAKoK,cAAc1E,UACnB1F,KAAKqK,UAAU1E,SAASyF,GAAaA,IAAa,MAAQA,SAAkB,OAAS,EAAIA,KACjG,CACI,kBAAAnK,EAAmB1K,MAAEA,EAAKqK,UAAEA,GAAayK,EAAY,CACjDrK,UAAW,aACXE,KAAM,OAEN,MAAMiG,EAAenH,KAAK8C,aAAavM,MACvCyJ,KAAKsL,YAAY/U,GACjByJ,KAAKuL,qBAAqB3K,GAC1B,GAAIuG,IAAiB5Q,EAAO,CACxByJ,KAAKwL,mBAAmBH,EACpC,CACA,CACI,oBAAAE,EAAsB5J,EAAMC,IACxB,IAAIsF,EACJ,MAAMhC,QAAEA,GAAYlF,KACpB,GAAIkF,EAAQkC,QAAQ,YACflC,EAAQ8F,iBAAmBrJ,GAAQuD,EAAQ+F,eAAiBrJ,GAAK,EACjEsF,EAAKhC,EAAQmC,qBAAuB,MAAQH,SAAY,OAAS,EAAIA,EAAG9K,KAAK8I,EAASvD,EAAMC,EACzG,CACA,CACI,WAAA0J,CAAY/U,GACRyJ,KAAKkF,QAAQ3O,MAAQA,CAC7B,CACI,mBAAAwU,GACI/K,KAAKiB,mBAAmByI,GAAiB1J,KAAK8C,aAAc9C,KAAKpE,SACzE,CACI,kBAAA4P,CAAmBH,EAAY,CAC3BrK,UAAW,aACXE,KAAM,OAEN,GAAIuK,WAAWC,WAAY,CACvB1L,KAAKkF,QAAQoC,cAAc,IAAIoE,WAAW,QAASzP,OAAOwN,OAAOxN,OAAOwN,OAAO,GAAI4B,GAAY,CAAE7D,QAAS,KAAMmE,WAAY,SACxI,CACA,CACI,YAAAlB,EAAanE,MAAEA,EAAK1F,UAAEA,EAAS8G,UAAEA,EAASgD,MAAEA,EAAQ,QAChD,MAAMkB,EAAe,CACjBrV,MAAOyJ,KAAK8C,aAAavM,MACzBqK,aAEJ,MAAOiL,EAAaC,GAAaF,EAAahL,UAC9C,MAAMkC,aAAEA,GAAiB9C,KAAK6J,aAAa,CACvC/G,aAAc8I,EACd1K,KAAM,IACPwG,EAAY,gBAAkB,kBACjC,MAAMqC,EAAY,IAAI5F,GAAUrB,EAAc9C,KAAKpE,SACnD,MAAO+F,EAAMC,GAAMkB,EAAalC,UAChCmJ,EAAUhF,iBAAiB,CAACpD,EAAMC,IAClC,MAAMmK,EAAkB/L,KAAK8J,cAAcC,EAAW6B,GACtD,MAAM/H,EAAmB+H,EAAarV,MAAM+G,MAAM,EAAGuO,GACjDD,EAAarV,MAAM+G,MAAMwO,GAC7B,GAAIjI,IAAqBkI,EAAgBxV,QACpCmU,IACA1K,KAAKkF,QAAQ8G,kBAAmB,CACjC,MACZ,CACQ1F,EAAMiE,iBACN,GAAIpJ,EAAsByK,EAAc9I,EAAciH,EAAWgC,GAAkB,CAE/E,OAAO/L,KAAKuL,qBAAqB7D,EAAY,CAAC9F,EAAIA,GAAM,CAACD,EAAMA,GAC3E,CACQ3B,KAAKiB,mBAAmB8K,EAAiB,CACrC/K,UAAWsF,EAAMtF,UACjBE,KAAM,OAEVlB,KAAKS,cAAcsL,EAC3B,CACI,YAAAnB,CAAatE,EAAOpF,GAChB,MAAMiB,EAAsBnC,KAAK8C,aACjC,MAAMA,aAAEA,EAAc5B,KAAM+K,EAAe/K,GAASlB,KAAK6J,aAAa,CAClE3I,OACA4B,aAAcX,GACf,UACH,MAAM4H,EAAY,IAAI5F,GAAUrB,EAAc9C,KAAKpE,SACnD,IACImO,EAAUzF,cAAcxB,EAAalC,UAAWqL,EAC5D,CACQ,MAAO/E,GACH,OAAOZ,EAAMiE,gBACzB,CACQ,MAAO5I,EAAMC,GAAMkB,EAAalC,UAChC,MAAMiD,EAAmB1B,EAAoB5L,MAAM+G,MAAM,EAAGqE,GACxDT,EACAiB,EAAoB5L,MAAM+G,MAAMsE,GACpC,MAAMmK,EAAkB/L,KAAK8J,cAAcC,EAAW5H,GACtD,GAAI4J,EAAgBxV,MAAML,OAAS8J,KAAKkL,UAAW,CAC/C,OAAO5E,EAAMiE,gBACzB,CACQ,GAAI1G,IAAqBkI,EAAgBxV,OACrCyJ,KAAKkF,QAAQ8G,kBAAmB,CAChC1F,EAAMiE,iBACNvK,KAAKiB,mBAAmB8K,EAAiB,CACrC7K,OACAF,UAAWsF,EAAMtF,YAErBhB,KAAKS,cAAcsL,EAC/B,CACA,CACI,WAAApB,CAAYrE,GACR,GAAItG,KAAKkK,YAAclK,KAAKkF,QAAQ8G,kBAAmB,CACnDhM,KAAK4K,aAAatE,EAAO,KACrC,CACA,ECrsBA,SAAS4F,GAAM3V,EAAO6R,EAAKhO,GACvB,MAAM+R,EAAexT,KAAKyP,IAAIpM,OAAO5B,GAAMzB,KAAKyB,IAAI4B,OAAOoM,GAAMpM,OAAOzF,KACxE,OAAQA,aAAiBY,KAAO,IAAIA,KAAKgV,GAAgBA,CAC7D,CAEA,SAASC,GAAYC,GACjB,OAAOA,EAAIC,WAAW,MAAO,IAAIpW,MACrC,CAgBA,MAAMqW,GAA6BzP,IAC/B,IAAIoK,EAAIsF,EAAIC,EACZ,OACI/W,MAAOwR,EAAKpK,EAAW6F,MAAM,SAAW,MAAQuE,SAAY,OAAS,EAAIA,EAAGhR,SAAW,EACvFT,QAAS+W,EAAK1P,EAAW6F,MAAM,SAAW,MAAQ6J,SAAY,OAAS,EAAIA,EAAGtW,SAAW,EACzFV,OAAQiX,EAAK3P,EAAW6F,MAAM,SAAW,MAAQ8J,SAAY,OAAS,EAAIA,EAAGvW,SAAW,EAC3F,EAGL,SAASwW,GAAezX,GACpB,MAAO,CACHS,IAAKiX,OAAO1X,EAAKqE,WAAWsT,SAAS,EAAG,KACxCnX,MAAOkX,OAAO1X,EAAKoE,WAAa,GAAGuT,SAAS,EAAG,KAC/CpX,KAAMmX,OAAO1X,EAAKmE,eAAewT,SAAS,EAAG,KAC7CrU,MAAOoU,OAAO1X,EAAKsE,YAAYqT,SAAS,EAAG,KAC3ClU,QAASiU,OAAO1X,EAAKuE,cAAcoT,SAAS,EAAG,KAC/C3O,QAAS0O,OAAO1X,EAAKwE,cAAcmT,SAAS,EAAG,KAC/CC,aAAcF,OAAO1X,EAAKyE,mBAAmBkT,SAAS,EAAG,KAEjE,CAEA,SAASE,GAAqBhQ,EAAYiQ,GACtC,MAAMC,EAAeZ,GAAYW,GACjC,MAAOE,EAAe,IAAMnQ,EAAW6F,MAAM,IAAIuK,OAAO,aAAaF,QAAqB,GAC1F,OAAOC,CACX,CAEA,SAASE,GAAqBrQ,EAAYiQ,GACtC,GAAIjQ,EAAW5G,OAAS6W,EAAiB7W,OAAQ,CAC7C,OAAO,KACf,CACI,OAAO4G,EAAWoM,MAAM,MAAM5H,OAAO8L,IAAaA,EAAQzK,MAAM,SACpE,CAEA,SAAS0K,GAAqBC,EAAWP,EAAkBQ,GACvD,MAAMP,EAAeZ,GAAYW,GACjC,OAAQO,EACHrQ,QAAQsQ,EAAgB,IACxB5K,MAAM,IAAIuK,OAAO,yBAAyBF,KAAiB,OAAS,EAC7E,CAEA,SAASQ,GAAgB1Q,EAAY2Q,GACjC,MAAMC,EAAYD,EAASnB,WAAW,UAAW,IACjD,MAAMqB,EAAiB7Q,EAAWwP,WAAW,OAAQ,IACrD,MAAMsB,EAAe,CACjBlY,IAAKiY,EAAerQ,MAAMoQ,EAAU9F,QAAQ,KAAM8F,EAAU7F,YAAY,KAAO,GAC/EpS,MAAOkY,EAAerQ,MAAMoQ,EAAU9F,QAAQ,KAAM8F,EAAU7F,YAAY,KAAO,GACjFrS,KAAMmY,EAAerQ,MAAMoQ,EAAU9F,QAAQ,KAAM8F,EAAU7F,YAAY,KAAO,IAEpF,OAAO5L,OAAO4R,YAAY5R,OAAO6R,QAAQF,GACpCG,QAAO,EAAEC,EAAGzX,KAAW0X,QAAQ1X,KAC/B2X,MAAK,EAAEC,IAAKC,KAAOX,EAASY,cAAczG,QAAQuG,EAAE7Q,MAAM,EAAG,IAC9DmQ,EAASY,cAAczG,QAAQwG,EAAE9Q,MAAM,EAAG,IACxC,GACC,IACX,CAEA,SAASgR,GAAeC,EAAYC,GAChC,IAAItH,EAAIsF,EAAIC,EAAIgC,EAAIC,EAAIC,EAAIC,EAC5B,MAAMpZ,IAAS0R,EAAKqH,EAAW/Y,QAAU,MAAQ0R,SAAY,OAAS,EAAIA,EAAGhR,UAAY,EAAI,KAAKqY,EAAW/Y,OAAS+Y,EAAW/Y,KACjI,MAAMP,EAAO,IAAIkC,KAAK6E,OAAOxG,IAAS,MAAQA,SAAc,EAAIA,EAAO,KAAMwG,QAAQwQ,EAAK+B,EAAW9Y,SAAW,MAAQ+W,SAAY,EAAIA,EAAK,KAAO,EAAGxQ,QAAQyQ,EAAK8B,EAAW7Y,OAAS,MAAQ+W,SAAY,EAAIA,EAAK,KAAMzQ,QAAQyS,EAAKD,IAAe,MAAQA,SAAoB,OAAS,EAAIA,EAAWjW,SAAW,MAAQkW,SAAY,EAAIA,EAAK,KAAMzS,QAAQ0S,EAAKF,IAAe,MAAQA,SAAoB,OAAS,EAAIA,EAAW9V,WAAa,MAAQgW,SAAY,EAAIA,EAAK,KAAM1S,QAAQ2S,EAAKH,IAAe,MAAQA,SAAoB,OAAS,EAAIA,EAAWvQ,WAAa,MAAQ0Q,SAAY,EAAIA,EAAK,KAAM3S,QAAQ4S,EAAKJ,IAAe,MAAQA,SAAoB,OAAS,EAAIA,EAAW3B,gBAAkB,MAAQ+B,SAAY,EAAIA,EAAK,MAExtB3Z,EAAK+J,YAAYhD,OAAOxG,IAAS,MAAQA,SAAc,EAAIA,EAAO,MAClE,OAAOP,CACX,CAEA,MAAM4Z,GAAsB,KAE5B,SAASC,IAAapZ,IAAEA,EAAGD,MAAEA,EAAKD,KAAEA,EAAI+C,MAAEA,EAAKG,QAAEA,EAAOuF,QAAEA,EAAO4O,aAAEA,IAAiBkC,SAAEA,EAAQC,kBAAEA,EAAoBH,GAAmBI,SAAEA,IACrI,IAAI/H,EACJ,MAAMgI,IAAahI,EAAK6H,EAASpM,MAAM,SAAW,MAAQuE,SAAY,OAAS,EAAIA,EAAGhR,UAAY,EAAIV,IAAS,MAAQA,SAAc,OAAS,EAAIA,EAAK8H,OAAO,GAAK9H,EACnK,MAAMiY,EAAWsB,GAAYE,EAAWD,EAAoBC,EAAW,IACvE,OAAOxB,EACFnB,WAAW,MAAO5W,IAAQ,MAAQA,SAAa,EAAIA,EAAM,IACzD4W,WAAW,MAAO7W,IAAU,MAAQA,SAAe,EAAIA,EAAQ,IAC/D6W,WAAW,MAAO4C,IAAa,MAAQA,SAAkB,EAAIA,EAAW,IACxE5C,WAAW,MAAO/T,IAAU,MAAQA,SAAe,EAAIA,EAAQ,IAC/D+T,WAAW,MAAOO,IAAiB,MAAQA,SAAsB,EAAIA,EAAe,IACpFP,WAAW,MAAO5T,IAAY,MAAQA,SAAiB,EAAIA,EAAU,IACrE4T,WAAW,MAAOrO,IAAY,MAAQA,SAAiB,EAAIA,EAAU,IACrEqO,WAAW,QAAS,IACpBA,WAAW,QAAS,GAC7B,CAEA,MAAM6C,GAA2B,CAC7BzZ,IAAK,GACLD,MAAO,GACPD,KAAM,MAKV,MAAM4Z,GAAmB,IAAIjY,KAAK,cAClC,MAAMkY,GAAmB,IAAIlY,KAAK,cAElC,MAAMmY,GAAkC,CACpC/W,MAAO,GACPG,QAAS,GACTuF,QAAS,GACT4O,aAAc,KAGlB,MAAM0C,GAAwB,CAAC,IAAK,KAEpC,MAAMC,GAA6B,CAC/BjX,MAAO,EACPG,QAAS,EACTuF,QAAS,EACT4O,aAAc,GAmDlB,MAAM4C,GAAa,IAKnB,MAAMC,GAAgB,IAEtB,SAASC,IAAmB7S,WAAEA,EAAUiQ,iBAAEA,EAAgB6C,sBAAEA,EAAqB5W,OAAEA,EAAQ4H,WAAYe,EAAMC,KACzG,MAAM2M,EAAaf,GAAgB1Q,EAAYiQ,GAC/C,MAAMa,EAAe3R,OAAO6R,QAAQS,GACpC,MAAMsB,EAAwB,GAC9B,IAAK,MAAOC,EAAaC,KAAiBnC,EAAc,CACpD,MAAMoC,EAAgBlB,GAAae,EAAuB,CACtDd,SAAUhC,IAEd,MAAMkD,EAAkBd,GAAyBW,GACjD,MAAMI,EAAkBF,EAAc9Z,QAAU0Z,EAAsB1Z,OACtE,MAAMia,EAAwBnX,EAC1BgX,EAAc9Z,OACdga,EACA3D,GAA0BQ,GAAkB+C,GAChD,MAAMM,EAA0BD,GAAyBxO,GAAQwO,IAA0BvO,EAC3F,GAAIwO,GAA2BpU,OAAO+T,GAAgB/T,OAAOiU,GAAkB,CAE3E,MAAO,CAAEI,oBAAqB,GAAIC,iBAAkB,CAAC3O,EAAMC,GACvE,CACQ,GAAIwO,GAA2BpU,OAAO+T,GAAgB,EAAG,CAErD,MAAO,CAAEM,oBAAqB,GAAIC,iBAAkB,CAAC3O,EAAMC,GACvE,CACQiO,EAAsBC,GAAeC,CAC7C,CACI,MAAMM,EAAsBvB,GAAae,EAAuB,CAC5Dd,SAAUhC,IAEd,MAAMwD,EAA6BF,EAAoBna,OAAS4G,EAAW5G,OAC3E,MAAO,CACHma,sBACAC,iBAAkB,CACd3O,EAAO4O,EACP3O,EAAK2O,GAGjB,CAMA,MAAMC,GAAe,sBACrB,MAAMC,GAAkB,IAAIvD,OAAOsD,GAAaE,QAChD,SAASC,GAAatE,GAClB,OAAOA,GAAOoE,GAAgB7N,KAAKyJ,GAC7BA,EAAIC,WAAWkE,GAAc7D,OAAOiE,GAAI,OACxCvE,CACV,CA+BA,MAAMwE,GAAgB,OACtB,SAASC,GAAwBf,EAAcgB,EAAgBC,EAAsB,GACjF,MAAMC,EAAqBlB,EAAamB,OAAOH,EAAe7a,OAAQ,KACtE,GAAI8F,OAAOiV,IAAuBjV,OAAO+U,GAAiB,CACtD,MAAO,CAAEI,sBAAuBpB,EAAciB,sBACtD,CACI,GAAIC,EAAmBG,SAAS,KAAM,CAElC,OAAON,GAAwB,IAAIf,EAAazS,MAAM,EAAGyT,EAAe7a,OAAS,KAAM6a,EAAgBC,EAAsB,EACrI,CACI,MAAMK,EAAuBtB,EAAazS,MAAM,EAAGyT,EAAe7a,OAAS,GAC3E,GAAImb,EAAqB1O,MAAMkO,IAAgB,CAC3C,MAAO,CAAEM,sBAAuB,GAAIH,sBAC5C,CAEI,OAAOF,GAAwB,GAAGO,KAAyBN,EAAgBC,EAC/E,CAOA,SAASM,GAAiBC,GACtB,OAAOA,EAAejF,WAAW,IAAIY,OAAOwC,GAAe,KAAMD,GACrE,CAOA,SAAS+B,GAAkBC,GACvB,OAAOA,EAAgBnF,WAAW,UAAWoF,GAAM/E,OAAOgF,aAAaD,EAAEE,WAAW,GAAK,QAC7F,CAKA,SAASC,KACL,MAAO,EAAG/O,eAAc5B,WACpB,MAAM3K,MAAEA,EAAKqK,UAAEA,GAAckC,EAC7B,MAAO,CACHA,aAAc,CACVlC,YACArK,MAAO+a,GAAiB/a,IAE5B2K,KAAMoQ,GAAiBpQ,GAC1B,CAET,CAEA,SAAS4Q,IAA2C/E,iBAAEA,EAAgBgF,qBAAEA,EAAoBC,QAAEA,EAAOC,QAAEA,IACnG,MAAO,EAAG1b,QAAOqK,gBACb,IAAIsG,EACJ,MAAOvF,EAAMC,GAAMhB,EACnB,MAAMvE,YAAEA,EAAW6V,SAAEA,EAAW,IAAOF,EAAQzb,GAC/C,MAAM4b,EAAuB,GAC7B,IAAIC,EAAa,EACjB/V,EAAYsJ,SAAS7I,IACjB,MAAMyR,EAAaf,GAAgB1Q,EAAYiQ,GAC/C,MAAMa,EAAe3R,OAAO6R,QAAQS,GACpC,MAAMsB,EAAwBjC,EAAa1K,QAAO,CAACmP,GAAMvC,EAAaC,MAClE,MAAMoB,sBAAEA,EAAqBH,oBAAEA,GAAwBF,GAAwBf,EAAc,GAAGZ,GAAyBW,MACzHsC,GAAcpB,EACd,OAAO/U,OAAOwN,OAAOxN,OAAOwN,OAAO,GAAI4I,GAAM,CAAEvC,CAACA,GAAcqB,GAAwB,GACvF,IACHgB,EAAqB7R,KAAKwO,GAAae,EAAuB,CAAEd,SAAUhC,IAAoB,IAElG,MAAMnJ,EAAiBqO,EAAQE,EAAsB5b,MAC9C2Q,EAAK7K,EAAYA,EAAYnG,OAAS,MAAQ,MAAQgR,SAAY,OAAS,EAAIA,EAAGkK,SAASW,IACxFA,EACA,IACNG,EACJ,GAAIE,GACAxO,EAAetG,MAAMsE,EAAKwQ,EAAYxQ,EAAKwQ,EAAaL,EAAqB7b,UAAY6b,EAAsB,CAM/GK,GAAcL,EAAqB7b,MAC/C,CACQ,MAAO,CACH0K,UAAW,CAACe,EAAOyQ,EAAYxQ,EAAKwQ,GACpC7b,MAAOqN,EACV,CAET,CAOA,SAAS0O,IAAwCvF,iBAAEA,EAAgBwF,sBAAEA,EAAqBR,qBAAEA,EAAoBS,6BAAEA,IAC9G,MAAO,EAAG1P,eAAc5B,WACpB,MAAM3K,MAAEA,EAAKqK,UAAEA,GAAckC,EAC7B,MAAM2P,EAAoB3F,GAAqBvW,EAAOwW,GACtD,MAAM2F,EAAmBF,EAA6BzE,QAAQ5F,IAAOoK,EAAsB/H,SAASrC,IAAMA,IAAM4J,IAChH,MAAMY,EAAqB,IAAIzF,OAAO,IAAIwF,EAAiBE,KAAK,OAAQ,MACxE,MAAO,CACH9P,aAAc,CACVlC,YACArK,MAAOkc,GAAqBlc,EAAML,OAASuc,EAAkBvc,OACvDuc,EACElc,EACK+G,MAAMmV,EAAkBvc,QACxB+G,QAAQ,WAAYsV,GAC3Bhc,GAEV2K,KAAMA,EAAKjE,QAAQ0V,EAAoBJ,GAC1C,CAET,CAKA,SAASM,KACL,MAAO,EAAG/P,eAAc5B,WACpB,MAAM3K,MAAEA,EAAKqK,UAAEA,GAAckC,EAC7B,MAAO,CACHA,aAAc,CACVlC,YACArK,MAAOib,GAAkBjb,IAE7B2K,KAAMsQ,GAAkBtQ,GAC3B,CAET,CAEA,SAAS4R,GAAuBC,EAAUtF,GACtC,MAAMuF,EAAiBzG,GAA0BkB,GACjD,OAAOxR,OAAO4R,YAAY5R,OAAO6R,QAAQiF,GAAU7K,KAAI,EAAE+K,EAAK1c,MAC1D,MAAM2c,EAAgBF,EAAeC,GACrC,MAAO,CACHA,EACA1c,EAAML,SAAWgd,GAAiB3c,EAAMoM,MAAM,QACxC,IAAIiK,SAASsG,EAAe,KAC5B3c,EACT,IAET,CAEA,SAAS4c,IAA8BpG,iBAAEA,EAAgB3E,IAAEA,EAAMgH,GAAgBhV,IAAEA,EAAMiV,GAAgB9B,eAAEA,EAAiB,GAAEwE,qBAAEA,EAAuB,MACnJ,MAAO,EAAGxb,QAAOqK,gBACb,MAAMwS,EAAyB7F,GAAkBhX,EAAM6a,SAAS7D,GAChE,MAAMlR,EAAcgR,GAAqB9W,EAAOwW,EAAkBQ,GAClE,IAAI3J,EAAiB,GACrB,IAAK,MAAM9G,KAAcT,EAAa,CAClCuH,GAAkBA,EAAiB2J,EAAiB,GACpD,MAAMgB,EAAaf,GAAgB1Q,EAAYiQ,GAC/C,IAAKI,GAAqBrQ,EAAYiQ,GAAmB,CACrD,MAAMsG,EAAYP,GAAuBvE,EAAYxB,GACrD,MAAMuG,EAAaxE,GAAauE,EAAW,CAAEtE,SAAUhC,IACvD,MAAMwG,EAAOzW,EAAWsU,SAASW,GAC3BA,EACA,GACNnO,GAAkB0P,EAAaC,EAC/B,QAChB,CACY,MAAMte,EAAOqZ,GAAeC,GAC5B,MAAMiF,EAActH,GAAMjX,EAAMmT,EAAKhO,GACrCwJ,GAAkBkL,GAAapC,GAAe8G,GAAc,CACxDzE,SAAUhC,GAE1B,CACQ,MAAO,CACHnM,YACArK,MAAOqN,GAAkBwP,EAAyB7F,EAAiB,IACtE,CAET,CAEA,SAASkG,IAA0B1G,iBAAEA,EAAgB6C,sBAAEA,EAAqBrC,eAAEA,EAAiB,GAAEyB,kBAAEA,EAAoBH,KACnH,MAAO,EAAG/L,eAAc5B,WACpB,MAAMwS,EAAYnG,EACZ,IAAIL,OAAO,GAAGK,OACdyB,EACN,MAAM2E,EAAgBzS,EAAKgI,MAAMwK,GACjC,MAAME,EAAQ1S,EAAKsJ,SAASwE,GACtB,CAAC2E,EAAc,IAAM,IACrBA,EACN,GAAIC,EAAMtS,OAAOrM,GAASA,EAAKiI,OAAOgM,MAAM,MAAM6E,OAAOE,SAAS/X,SAC9D6W,EAAiB7D,MAAM0G,GAAuB1Z,SAAS,CACvD,MAAM2d,EAAUD,EACX1L,KAAKjT,GAAS6e,GAAoB7e,EAAM8X,EAAkB6C,KAC1DgD,KAAKrF,GACV,MAAO,CACHzK,eACA5B,KAAM,GAAG2S,IAAU3S,EAAKsJ,SAASwE,GAC3BA,EAAoB2E,EAAc,IAAM,GACxC,KAEtB,CACQ,MAAO,CAAE7Q,eAAc5B,OAAM,CAErC,CACA,SAAS4S,GAAoBhX,EAAYiX,EAAUL,GAC/C,MAAM9F,EAAe9Q,EAAWoM,MAAM,MAAM6E,OAAOE,SACnD,MAAM+F,EAAmBD,EAAS7K,MAAMwK,GACxC,MAAMO,EAAqBrG,EAAa1F,KAAI,CAACkF,EAASrM,KAClD,IAAImG,EACJ,OAAOnG,IAAUiT,EAAiB9d,OAAS,EACrCkX,EACAA,EAAQR,WAAW1F,EAAK8M,EAAiBjT,MAAY,MAAQmG,SAAY,OAAS,EAAIA,EAAGhR,SAAW,EAAG,IAAI,IAErH,OAAO+d,EAAmBrB,KAAKc,EACnC,CAuDA,SAASQ,IAA4BnH,iBAAEA,EAAgB6C,sBAAEA,EAAqBrC,eAAEA,EAAiB,KAC7F,MAAO,EAAGzK,eAAc5B,WACpB,MAAM3K,MAAEA,EAAKqK,UAAEA,GAAckC,EAC7B,GAAI5B,IAAS0O,EAAuB,CAChC,MAAO,CACH9M,eACA5B,KAAMN,EAAU,KAAOrK,EAAML,OAASgL,EAAO,GAE7D,CACQ,MAAMO,EAAgBP,EAAKoL,WAAW,IAAIY,OAAO,QAAQyD,GAAaf,KAAyBrC,KAAmB,KAAM,IACxH,IAAK9L,EAAe,CAChB,MAAO,CAAEqB,eAAc5B,KAAM,GACzC,CACQ,MAAOS,EAAMwS,GAASvT,EACtB,IAAIgB,EAAKuS,EAAQjT,EAAKhL,OACtB,MAAM2N,EAAmBtN,EAAM+G,MAAM,EAAGqE,GAAQF,EAAgBlL,EAAM+G,MAAMsE,GAC5E,MAAMvF,EAAcgR,GAAqBxJ,EAAkBkJ,EAAkBQ,GAC7E,IAAI3J,EAAiB,GACrB,MAAMwQ,EAAoBnG,QAAQV,IAAmB1J,EAAiB2G,SAAS+C,GAC/E,IAAK,MAAMzQ,KAAcT,EAAa,CAClC,MAAMgU,oBAAEA,EAAmBC,iBAAEA,GAAqBX,GAAmB,CACjE7S,aACAiQ,mBACA6C,wBACA5W,OAAQ4K,EAAe1N,OACvB0K,UAAW,CAACe,EAAMC,KAEtB,GAAI9E,IAAeuT,EAAqB,CACpC,MAAO,CAAEvN,eAAc5B,KAAM,GAC7C,CACYU,EAAK0O,EAAiB,GACtB1M,GACIwQ,IAAsBxQ,EAChByM,EAAsB9C,EACtB8C,CACtB,CACQ,MAAMwD,EAAUjQ,EAAetG,MAAMqE,EAAMC,GAC3C,MAAO,CACHkB,aAAc,CACVlC,YACArK,MAAOqN,EAAetG,MAAM,EAAGqE,GAC3BkS,EACK3K,MAAM0G,GACN1H,KAAKkF,GAAY,IAAIiH,OAAOjH,EAAQlX,UACpC0c,KAAKhD,GACVhM,EAAetG,MAAMsE,IAE7BV,KAAM2S,EACT,CAET,CA2EA,MAAMS,GAAO,OACb,SAASC,IAAiCC,KAAEA,EAAI/G,SAAEA,EAAQgH,qBAAEA,IACxD,MAAMC,EAAkBC,GAA0BlH,GAClD,OAAO+G,GAAQ,EACTF,GACCpP,IACC,MAAM0P,EAAYtO,IACd,GAAIA,EAAM2M,MAAQ,WAAa3M,EAAM2M,MAAQ,YAAa,CACtD,MACpB,CACgB3M,EAAMiE,iBACN,MAAMS,EAAiB9F,EAAQ8F,gBAAkB,EACjD,MAAM6J,EAAgBC,GAAiB,CACnCJ,kBACA1J,mBAEJ,IAAK6J,EAAe,CAChB,MACpB,CACgB,MAAME,EAAeC,GAAmB,CACpCpU,UAAW8T,EAAgBO,IAAIJ,GAC/Bte,MAAO2O,EAAQ3O,MACf2e,MAAO5O,EAAM2M,MAAQ,UAAYuB,GAAQA,EACzCpa,IAAKqa,EAAqBI,KAE9B7N,GAAqB9B,EAAS,CAC1B3O,MAAOwe,EACPnU,UAAW,CAACoK,EAAgBA,IAC9B,EAEN9F,EAAQM,iBAAiB,UAAWoP,GACpC,MAAO,IAAM1P,EAAQO,oBAAoB,UAAWmP,EAAS,CAEzE,CACA,SAASD,GAA0BlH,GAC/B,OAAO,IAAI0H,IAAI,CACX,CAAC,QAASC,GAAgB3H,EAAU,OACpC,CAAC,UAAW2H,GAAgB3H,EAAU,OACtC,CAAC,UAAW2H,GAAgB3H,EAAU,OACtC,CAAC,eAAgB2H,GAAgB3H,EAAU,SAEnD,CACA,SAAS2H,GAAgB1T,EAAM0L,GAC3B,MAAMrM,EAAQW,EAAKkG,QAAQwF,GAC3B,OAAOrM,KAAW,EAAI,EAAE,GAAI,GAAK,CAACA,EAAOA,EAAQqM,EAAQlX,OAC7D,CACA,SAAS4e,IAAiBJ,gBAAEA,EAAe1J,eAAEA,IACzC,IAAK,MAAO8E,EAAauF,KAAiBX,EAAgB5G,UAAW,CACjE,MAAOnM,EAAMC,GAAMyT,EACnB,GAAI1T,GAAQqJ,GAAkBA,GAAkBpJ,EAAI,CAChD,OAAOkO,CACnB,CACA,CACI,OAAO,IACX,CACA,SAASkF,IAAmBpU,UAAEA,EAASrK,MAAEA,EAAK2e,MAAEA,EAAK9a,IAAEA,IACnD,MAAOuH,EAAMC,GAAMhB,EACnB,MAAMmP,EAAe/T,OAAOzF,EAAM+G,MAAMqE,EAAMC,GAAIsP,OAAOtP,EAAKD,EAAM,MACpE,MAAM2T,EAAkBC,GAAIxF,EAAemF,EAAO9a,EAAM,GACxD,OAAQ7D,EAAM+G,MAAM,EAAGqE,GACnBgL,OAAO2I,GAAiB1I,SAAShL,EAAKD,EAAM,KAC5CpL,EAAM+G,MAAMsE,EAAIrL,EAAML,OAC9B,CACA,SAASqf,GAAIhf,EAAO6D,GAChB,GAAI7D,EAAQ,EAAG,CACXA,GAASoC,KAAK6c,MAAM7c,KAAKC,IAAIrC,GAAS6D,EAAM,GAAKA,CACzD,CACI,OAAO7D,EAAQ6D,CACnB,CA4EA,SAASqb,KACL,MAAO,EAAG3S,gBAAgB4S,KACtB,MAAMnf,MAAEA,EAAKqK,UAAEA,GAAckC,EAC7B,IAAKvM,GAASof,GAAWpf,EAAOqK,GAAY,CACxC,MAAO,CAAEkC,eACrB,CACQ,MAAOnB,EAAMC,GAAMhB,EACnB,MAAMgV,EAASrf,EAAM+G,MAAMqE,EAAMC,GAAI0K,WAAW,MAAO,KACvD,MAAMuJ,EAAWtf,EAAM+G,MAAM,EAAGqE,GAAQiU,EAASrf,EAAM+G,MAAMsE,GAC7D,GAAI8T,IAAe,cAAiBA,IAAe,UAAY/T,IAASC,EAAK,CACzE,MAAO,CACHkB,aAAc,CAAElC,YAAWrK,MAAOsf,GAElD,CACQ,MAAO,CACH/S,aAAc,CACVlC,UAAW8U,IAAe,kBAAoBA,IAAe,SACvD,CAAC/T,EAAMA,GACP,CAACC,EAAIA,GACXrL,MAAOsf,GAEd,CAET,CACA,SAASF,GAAWpf,GAAQyX,EAAGpM,IAC3B,OAAOA,IAAOrL,EAAML,MACxB,CAEA,SAAS4f,IAA4BpU,KAAEA,EAAIgS,UAAEA,EAAY,IAAGtZ,IAAEA,EAAGgO,IAAEA,IAC/D,MAAM2E,EAAmBrL,EAAKwH,MAAM,KAAK0J,KAAKc,GAC9C,OAAOzX,OAAOwN,OAAOxN,OAAOwN,OAAO,GAAIjK,GAA0B,CAAEC,KAAMgD,MAAMd,KAAKoL,GAAkB7E,KAAKnG,GAAS2R,EAAUlJ,SAASzI,GAAQA,EAAO,OAAOlC,cAAe,UAAWH,cAAe,CAC9LmT,KACA4C,KACAhC,GAA0B,CACtB1G,mBACA6C,sBAAuB8D,IAE3BQ,GAA4B,CACxBnH,mBACA6C,sBAAuB8D,KAE5B/T,eAAgB,CACfmS,GAA2C,CACvC/E,mBACAgF,qBAAsB2B,EACtB1B,QAAUzb,IAAK,CAAQ8F,YAAa,CAAC9F,KACrC0b,QAAS,EAAEnV,EAAa,MAAQA,IAEpCqW,GAA8B,CAC1B/K,MACAhO,MACA2S,mBACAgF,qBAAsB2B,MAGtC,CA2HA,SAASqC,GAAgBC,EAAcC,GACnC,OAAOha,OAAO4R,YAAY5R,OAAO6R,QAAQkI,GAAc9N,KAAI,EAAE4H,EAAaC,KAAkB,CACxFD,EACAmG,EAAItJ,OAAOoD,GAAeP,GAA2BM,OAE7D,CAMA,SAASoG,GAAqBF,GAC1B,OAAOD,GAAgBC,GAAc,CAACzf,EAAOL,IAAWK,EAAMqW,SAAS1W,EAAQ,MACnF,CAEA,MAAMigB,GAAoB,CACtB5a,GAAI,QACJL,GAAI,UACJkb,GAAI,UACJC,IAAK,gBAKT,SAASC,GAAgBtZ,EAAYiS,GACjC,MAAMsH,EAAavZ,EAAWsP,WAAW,OAAQ,IACjD,IAAItT,EAAS,EACb,OAAOiD,OAAO4R,YAAYoB,EAAS/F,MAAM,MAAMhB,KAAKsO,IAChD,MAAMzG,EAAewG,EAAWjZ,MAAMtE,EAAQA,EAASwd,EAAYtgB,QACnE8C,GAAUwd,EAAYtgB,OACtB,MAAO,CAACigB,GAAkBK,GAAczG,EAAa,IAE7D,CAEA,MAAM0G,GAAqB,OAC3B,MAAMC,GAAsB,OAC5B,SAASC,IAAape,MAAEA,EAAQ,GAAEG,QAAEA,EAAU,GAAEuF,QAAEA,EAAU,GAAE4O,aAAEA,EAAe,KAC3E,MAAO,GAAGtU,KAASG,KAAWuF,KAAW4O,IACpC5P,QAAQwZ,GAAoB,IAC5BxZ,QAAQyZ,GAAqB,GACtC,CAEA,MAAME,GAAsC,IAAI1J,OAAO,IAAIqC,GAAsBrH,IAAIyI,IAAciC,KAAK,SACxG,SAASiE,IAAmB7Z,WAAEA,EAAU8Z,gBAAEA,EAAe9d,OAAEA,EAAQ4H,WAAYe,EAAMC,GAAGqN,SAAEA,IACtF,MAAMT,EAAa8H,GAAgBtZ,EAAYiS,GAC/C,MAAM8H,EAAuB9a,OAAO6R,QAAQU,GAC5C,MAAMwI,EAAwB,GAC9B,IAAIC,EAAe,EACnB,IAAK,MAAOnH,EAAaC,KAAiBgH,EAAsB,CAC5D,MAAMG,EAAgBP,GAAaK,GACnC,MAAM/G,EAAkB6G,EAAgBhH,GACxC,MAAMI,EAAkBgH,EAAchhB,QAAU,EAChD,MAAMia,EAAwBnX,EAC1Bke,EAAchhB,OACdga,EACAV,GAA2BM,GAC/B,MAAMM,EAA0BD,GAAyBxO,GAAQwO,GAAyBvO,EAC1F,GAAIwO,GAA2BpU,OAAO+T,GAAgB/T,OAAOiU,GAAkB,CAE3E,MAAO,CAAEkH,oBAAqB,GAAIC,qBAAsB,CAACzV,EAAMC,GAC3E,CACQ,MAAMuP,sBAAEA,EAAqBH,oBAAEA,GAAwBF,GAAwBf,EAAc,GAAGE,KAChGgH,GAAgBjG,EAChBgG,EAAsBlH,GAAeqB,CAC7C,CACI,MAAOkG,EAA2B,IAAMra,EAAW2F,MAAMiU,KAAwC,GACjG,MAAMO,EAAsBR,GAAaK,GAAyBK,EAClE,MAAM9G,EAA6B5X,KAAKyB,IAAI+c,EAAoBjhB,OAAS8G,EAAW9G,OAAQ,GAC5F,MAAO,CACHihB,sBACAC,qBAAsB,CAClBzV,EAAOsV,EAAe1G,EACtB3O,EAAKqV,EAAe1G,GAGhC,CAEA,SAAS+G,GAAyBC,GAAgBxI,SAAEA,EAAQE,SAAEA,EAAQD,kBAAEA,EAAoBH,KACxF,OAAQ0I,EAAerhB,QACnB6Y,EAAS7Y,OAAS+Y,EAAS/Y,OAAS8Y,EAAkB9Y,SACrDqhB,EAAerO,MAAM8F,GAAmB,IAAM,IAC1C9F,MAAM,MACN5H,OAAO8L,IAAaA,EAAQzK,MAAM,SAC/C,CAEA,SAAS6U,GAAoBC,GAAU1K,iBAAEA,EAAgBiC,kBAAEA,IACvD,MAAM0I,EAAeD,EAASjN,SAASwE,GACvC,MAAO,CACHyI,EAASna,MAAM,EAAGyP,EAAiB7W,QACnCuhB,EAASna,MAAMoa,EACT3K,EAAiB7W,OAAS8Y,EAAkB9Y,OAC5C6W,EAAiB7W,QAE/B,CAEA,SAASyhB,IAAkC5K,iBAAEA,EAAgBkC,SAAEA,EAAQ7G,IAAEA,EAAMgH,GAAgBhV,IAAEA,EAAMiV,GAAgBL,kBAAEA,IACrH,MAAO,EAAGzY,QAAOqK,gBACb,MAAO9D,EAAYE,GAAcwa,GAAoBjhB,EAAO,CACxDwW,mBACAiC,sBAEJ,MAAMT,EAAaf,GAAgB1Q,EAAYiQ,GAC/C,MAAMyB,EAAa8H,GAAgBtZ,EAAYiS,GAC/C,IAAKqI,GAAyB/gB,EAAO,CACjCwY,SAAUhC,EACVkC,WACAD,sBACA,CACA,MAAMqE,EAAYP,GAAuBvE,EAAYxB,GACrD,MAAMvX,KAAEA,EAAIC,MAAEA,EAAKC,IAAEA,GAAQyX,GAAqBrQ,EAAYiQ,GACxDL,GAAeR,GAAMoC,GAAe+E,GAAYjL,EAAKhO,IACrDiZ,EACN,MAAMC,EAAaxE,GAAa7S,OAAOwN,OAAO,CAAEjU,OAC5CC,QACAC,OAAO8Y,GAAa,CAAEO,SAAUhC,EAAkBiC,oBAAmBC,aACzE,MAAMsE,EAAOhd,EAAM+G,MAAMgW,EAAWpd,QACpC,MAAO,CACH0K,YACArK,MAAO+c,EAAaC,EAEpC,CACQ,MAAMte,EAAOqZ,GAAeC,EAAYC,GACxC,MAAMgF,EAActH,GAAMjX,EAAMmT,EAAKhO,GACrC,MAAMwJ,EAAiBkL,GAAapC,GAAe8G,GAAc,CAC7DzE,SAAUhC,EACViC,oBACAC,aAEJ,MAAO,CACHrO,YACArK,MAAOqN,EACV,CAET,CAEA,SAASgU,IAAgC7K,iBAAEA,EAAgB6C,sBAAEA,EAAqBZ,kBAAEA,EAAiBC,SAAEA,IACnG,MAAM4I,EAAqB,IAAI3K,OAAO,QAAQqC,GAAsBrH,IAAIyI,IAAciC,KAAK,MAAMjC,GAAaf,QAC9G,MAAO,EAAG9M,eAAc5B,WACpB,MAAM3K,MAAEA,EAAKqK,UAAEA,GAAckC,EAC7B,GAAI5B,IAAS0O,EAAuB,CAChC,MAAO,CACH9M,eACA5B,KAAMN,EAAU,KAAOrK,EAAML,OAASgL,EAAO,GAE7D,CACQ,MAAMO,EAAgBP,EAAKjE,QAAQ4a,EAAoB,IACvD,IAAKpW,EAAe,CAChB,MAAO,CAAEqB,eAAc5B,KAAM,GACzC,CACQ,MAAOS,EAAMwS,GAASvT,EACtB,IAAIgB,EAAKuS,EAAQjT,EAAKhL,OACtB,MAAM2N,EAAmBtN,EAAM+G,MAAM,EAAGqE,GAAQF,EAAgBlL,EAAM+G,MAAMsE,GAC5E,MAAO9E,EAAYE,GAAcwa,GAAoB3T,EAAkB,CACnEkJ,mBACAiC,sBAEJ,IAAIpL,EAAiB,GACrB,MAAMkU,EAAuBjU,EAAiB2G,SAASwE,GACvD,MAAMqB,oBAAEA,EAAmBC,iBAAEA,GAAqBX,GAAmB,CACjE7S,aACA8S,wBACA7C,mBACA/T,OAAQ,EACR4H,UAAW,CAACe,EAAMC,KAEtB,GAAI9E,IAAeuT,EAAqB,CACpC,MAAO,CAAEvN,eAAc5B,KAAM,GACzC,CACQU,EAAK0O,EAAiB,GACtB1M,GAAkByM,EAClB,MAAMyG,EAAkBZ,GAAqB5G,IAC7C,MAAM6H,oBAAEA,EAAmBC,qBAAEA,GAAyBP,GAAmB,CACrE7Z,aACA8Z,kBACA9d,OAAQ4K,EAAe1N,OAAS8Y,EAAkB9Y,OAClD0K,UAAW,CAACe,EAAMC,GAClBqN,aAEJ,GAAIjS,IAAema,EAAqB,CACpC,MAAO,CAAErU,eAAc5B,KAAM,GACzC,CACQU,EAAKwV,EAAqB,GAC1BxT,GAAkBkU,EACZ9I,EAAoBmI,EACpBA,EACN,MAAMtD,EAAUjQ,EAAetG,MAAMqE,EAAMC,GAC3C,MAAO,CACHkB,aAAc,CACVlC,YACArK,MAAOqN,EAAetG,MAAM,EAAGqE,GAC3BkS,EACK3K,MAAM0G,GACN1H,KAAKkF,GAAY,IAAIiH,OAAOjH,EAAQlX,UACpC0c,KAAKhD,GACVhM,EAAetG,MAAMsE,IAE7BV,KAAM2S,EACT,CAET,CAEA,SAASkE,IAAgChJ,SAAEA,EAAQE,SAAEA,EAAQ+I,cAAEA,EAAgB,IAAG5P,IAAEA,EAAGhO,IAAEA,EAAG4U,kBAAEA,EAAoBH,GAAmBoJ,SAAEA,EAAW,IAC9I,MAAMlL,EAAmBgC,EAAS7F,MAAM,KAAK0J,KAAKoF,GAClD,OAAO/b,OAAOwN,OAAOxN,OAAOwN,OAAO,GAAIjK,GAA0B,CAAEC,KAAM,IAC9DgD,MAAMd,KAAKoL,GAAkB7E,KAAKnG,GAASiW,EAAcxN,SAASzI,GAAQA,EAAO,UACjFiN,EAAkB9F,MAAM,OACxBzG,MAAMd,KAAKsN,GAAU/G,KAAKnG,GAASwN,GAAsB/E,SAASzI,GAAQA,EAAO,QACrFlC,cAAe,UAAWH,cAAe,CACxCmT,KACAhB,KACAS,GAAwC,CACpCvF,mBACAgF,qBAAsBiG,EACtBzF,sBAAuBvD,EACvBwD,6BAA8BxD,EAAkB9F,MAAM,MAE1DuM,KACAhC,GAA0B,CACtB1G,mBACA6C,sBAAuBoI,EACvBhJ,sBAEJ4I,GAAgC,CAC5B7K,mBACA6C,sBAAuBoI,EACvBhJ,oBACAC,cAELtP,eAAgB,CACfmS,GAA2C,CACvC/E,mBACAgF,qBAAsBiG,EACtBhG,QAAUzb,IACN,MAAOuG,EAAYE,GAAcwa,GAAoBjhB,EAAO,CACxDwW,mBACAiC,sBAEJ,MAAO,CAAE3S,YAAa,CAACS,GAAaoV,SAAUlV,EAAY,EAE9DiV,QAAS,EAAE5B,GAAsBlJ,IAAiBkJ,GAC7ClJ,EAAaqD,SAASwE,GAAqBA,EAAoB,MAExE2I,GAAkC,CAC9BvP,MACAhO,MACA2S,mBACAkC,WACAD,uBAELpP,QAAS,CACR2U,GAAiC,CAC7BC,KAAMyD,EACNxK,SAAU,GAAGV,IAAmBiC,IAAoBC,IACpDwF,qBAAsBnF,OAGtC,CC5tCA,MAAM4I,GAAuB,GAC7B,MAAAC,GAAeD,G,MCcFE,GAAiB,M,qMAgBf,O,iBACmB,M,mBACE,K,uCAGZ,I,CAKtB,iBAAAC,GAEErY,KAAKsY,eAAiBthB,KAAKC,iBAAiBshB,kBAAkBrjB,SAE9D8K,KAAKwY,aAAaxY,KAAKzJ,OACvByJ,KAAKyY,QAAUzY,KAAK0Y,GAAGC,QAAQ,c,CAEjC,gBAAAC,GACE5Y,KAAK6Y,gB,CAGP,oBAAAC,GACE9Y,KAAK+Y,YAAYrT,S,CAGnB,YAAA8S,CAAavjB,GAEX+K,KAAKgZ,UAAYpa,EAAY,IAAIzH,KAAKlC,GAAO+K,KAAKsY,gBAClDtY,KAAKiZ,WAAaC,EAChBC,YAAUnZ,KAAKgZ,WACfhZ,KAAKoZ,iBACL,MAEFpZ,KAAKqZ,YAAcrZ,KAAKqZ,U,CAG1B,oBAAMR,GACJ,MAAMS,EAAcxD,GAA4B,CAC9CpU,KAAM,aACNgS,UAAW,MAEb,MAAM6F,EAAkBxB,GAAgC,CACtDhJ,SAAU,aACVE,SAAU,QACV+I,cAAe,MAEjB,MAAMwB,EAAWC,SAASC,cACxB,cAEF,MAAMC,QAAiBH,EAASI,kBAChC5Z,KAAK+Y,YAAc,IAAI/O,GACrB2P,EACA3Z,KAAKoZ,kBAAoB,OAASE,EAAcC,E,CAIpD,YAAAM,CAAaC,GACX9Z,KAAKzJ,MAAQujB,EAAGC,OAAOxjB,MACvByJ,KAAKwY,aAAaxY,KAAKzJ,M,CAGzB,iBAAAyjB,CAAkBF,GAChB,MAAMG,EAAYH,EAAGI,OAAO3jB,MAC5B,MAAMgY,EAAa4L,QACjBF,EACAja,KAAKoZ,kBAAoB,OAAS,aAAe,mBACjD,IAAIjiB,MAEN,GAAIijB,UAAQ7L,GAAa,CACvBvO,KAAKzJ,MAAQ4iB,YAAU5K,GACvBvO,KAAKwY,aAAaxY,KAAKzJ,M,EAI3B,KAAA8jB,GACEra,KAAKyY,QAAQ6B,S,CAEf,IAAAC,GAEE,MAAM9iB,EAAUmH,EAAYoB,KAAKzJ,MAAO,OACxC,MAAMikB,EAAa7jB,SAAOc,EAAS,gCACnCuI,KAAKyY,QAAQ6B,QAAQE,E,CAGvB,MAAAC,GACE,OACEC,EAACC,EAAI,CAAA1H,IAAA,4CACHyH,EAAA,eAAAzH,IAAA,4CACEyH,EAAA,gBAAAzH,IAAA,2CACE2H,MAAOC,EAAYC,cACnBC,aAAc/a,KAAKoZ,iBAAgB,eACrBpZ,KAAKgb,YAAW,sBACThb,KAAKib,cAC1BC,YAAcpB,GAAO9Z,KAAK6Z,aAAaC,GACvC1f,IAAK4F,KAAKmb,QACV5kB,MAAO4iB,YAAUnZ,KAAKgZ,YAErBhZ,KAAKib,cACJP,EAAA,QAAMU,KAAK,SACRpb,KAAKqb,SACJX,EAAA,aACEY,IAAKtb,KAAKqb,SACVE,KAAMvb,KAAKwb,UACXve,QAAS+C,KAAKyb,eAEdzb,KAAKwb,UACPxb,KAAc,UACZ3J,UACH2J,KAAK0b,WAAa1b,KAAK0b,WAAarlB,WAErCA,WAEL2J,KAAKoZ,kBAAoB,aAC1BpZ,KAAKoZ,kBAAoB,aACzBpZ,KAAKoZ,kBAAoB,OACvBsB,EAAA,gBACEA,EAAA,aACEiB,GAAG,YACHzX,KAAK,UACL9N,KAAK,OACLwlB,SAAU,IACVC,UAAU,UACVtlB,MAAOyJ,KAAKiZ,WACZ6C,WAAahC,GAAO9Z,KAAKga,kBAAkBF,MAG7CzjB,WAENqkB,EAAA,cAAAzH,IAAA,4CACEyH,EAAA,oBAAAzH,IAAA,2CACE8I,aAAc,IAAM/b,KAAKqa,QACzB2B,WAAY,IAAMhc,KAAKua,U","ignoreList":[]}