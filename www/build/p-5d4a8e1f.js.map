{"version":3,"names":["shouldUseCloseWatcher","config","get","win","undefined","blockHardwareBackButton","document","addEventListener","startHardwareBackButton","doc","busy","backButtonCallback","index","handlers","ev","CustomEvent","bubbles","detail","register","priority","handler","push","id","dispatchEvent","executeAction","async","handlerRegister","result","processHandlers","e","console","error","length","selectedHandler","Number","MIN_SAFE_INTEGER","forEach","filter","then","watcher","configureWatcher","destroy","CloseWatcher","onclose","OVERLAY_BACK_BUTTON_PRIORITY","MENU_BACK_BUTTON_PRIORITY","focusableQueryString","focusFirstDescendant","ref","fallbackElement","firstInput","querySelector","focusElementInContext","focusLastDescendant","inputs","Array","from","querySelectorAll","lastInput","hostToFocus","elementToFocus","shadowRoot","focusVisibleElement","focus","lastOverlayIndex","lastId","activeAnimations","WeakMap","createController","tagName","create","options","createOverlay","dismiss","data","role","dismissOverlay","getTop","getPresentedOverlay","alertController","actionSheetController","loadingController","modalController","popoverController","toastController","prepareOverlay","el","connectListeners","overlayIndex","setOverlayId","hasAttribute","opts","window","customElements","whenDefined","element","createElement","classList","add","Object","assign","hasController","getAppRoot","appendChild","Promise","resolve","componentOnReady","isOverlayHidden","overlay","contains","focusElementInOverlay","trapKeyboardFocus","lastOverlay","target","FOCUS_TRAP_DISABLE_CLASS","trapScopedFocus","lastFocus","overlayRoot","getElementRoot","overlayWrapper","activeElement","trapShadowFocus","backdropDismiss","BACKDROP","key","overlayTag","reject","getOverlays","selector","c","getPresentedOverlays","o","overlays","find","setRootAriaHidden","hidden","root","viewContainer","setAttribute","removeAttribute","present","name","iosEnterAnimation","mdEnterAnimation","_a","_b","presented","body","BACKDROP_NO_SCROLL","hideOverlaysFromScreenReaders","willPresent","emit","willPresentShorthand","mode","getIonMode","animationBuilder","enterAnimation","completed","overlayAnimation","didPresent","didPresentShorthand","restoreElementFocus","keyboardClose","overlayEl","previousElement","onDidDismiss","iosLeaveAnimation","mdLeaveAnimation","remove","style","setProperty","willDismiss","willDismissShorthand","leaveAnimation","GESTURE","didDismiss","didDismissShorthand","animations","ani","delete","removeProperty","err","revealOverlaysToScreenReaders","baseEl","aniRoot","animation","animated","getBoolean","duration","beforeAddWrite","ownerDocument","matches","blur","activeAni","set","play","eventMethod","eventName","promise","r","onceEvent","event","callback","removeEventListener","isCancel","defaultGate","h","safeCall","arg","jmp","OVERLAY_GESTURE_PRIORITY","createDelegateController","inline","workingDelegate","coreDelegate","CoreDelegate","getDelegate","force","delegate","parentEl","parentNode","attachViewToDom","component","Error","removeViewFromDom","parentElement","createTriggerController","destroyTriggerInteraction","removeClickListener","addClickListener","trigger","triggerEl","getElementById","printIonWarning","configureTriggerInteraction","targetEl","openOverlay","newTopMostOverlay","i","presentedOverlay","nextPresentedOverlay","currentOverlay"],"sources":["node_modules/@ionic/core/dist/collection/utils/hardware-back-button.js","node_modules/@ionic/core/dist/collection/utils/focus-trap.js","node_modules/@ionic/core/dist/collection/utils/overlays.js"],"sourcesContent":["/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { win } from \"./browser/index\";\nimport { config } from \"../global/config\";\n/**\n * CloseWatcher is a newer API that lets\n * use detect the hardware back button event\n * in a web browser: https://caniuse.com/?search=closewatcher\n * However, not every browser supports it yet.\n *\n * This needs to be a function so that we can\n * check the config once it has been set.\n * Otherwise, this code would be evaluated the\n * moment this file is evaluated which could be\n * before the config is set.\n */\nexport const shouldUseCloseWatcher = () => config.get('experimentalCloseWatcher', false) && win !== undefined && 'CloseWatcher' in win;\n/**\n * When hardwareBackButton: false in config,\n * we need to make sure we also block the default\n * webview behavior. If we don't then it will be\n * possible for users to navigate backward while\n * an overlay is still open. Additionally, it will\n * give the appearance that the hardwareBackButton\n * config is not working as the page transition\n * will still happen.\n */\nexport const blockHardwareBackButton = () => {\n    document.addEventListener('backbutton', () => { }); // eslint-disable-line\n};\nexport const startHardwareBackButton = () => {\n    const doc = document;\n    let busy = false;\n    const backButtonCallback = () => {\n        if (busy) {\n            return;\n        }\n        let index = 0;\n        let handlers = [];\n        const ev = new CustomEvent('ionBackButton', {\n            bubbles: false,\n            detail: {\n                register(priority, handler) {\n                    handlers.push({ priority, handler, id: index++ });\n                },\n            },\n        });\n        doc.dispatchEvent(ev);\n        const executeAction = async (handlerRegister) => {\n            try {\n                if (handlerRegister === null || handlerRegister === void 0 ? void 0 : handlerRegister.handler) {\n                    const result = handlerRegister.handler(processHandlers);\n                    if (result != null) {\n                        await result;\n                    }\n                }\n            }\n            catch (e) {\n                console.error(e);\n            }\n        };\n        const processHandlers = () => {\n            if (handlers.length > 0) {\n                let selectedHandler = {\n                    priority: Number.MIN_SAFE_INTEGER,\n                    handler: () => undefined,\n                    id: -1,\n                };\n                handlers.forEach((handler) => {\n                    if (handler.priority >= selectedHandler.priority) {\n                        selectedHandler = handler;\n                    }\n                });\n                busy = true;\n                handlers = handlers.filter((handler) => handler.id !== selectedHandler.id);\n                executeAction(selectedHandler).then(() => (busy = false));\n            }\n        };\n        processHandlers();\n    };\n    /**\n     * If the CloseWatcher is defined then\n     * we don't want to also listen for the native\n     * backbutton event otherwise we may get duplicate\n     * events firing.\n     */\n    if (shouldUseCloseWatcher()) {\n        let watcher;\n        const configureWatcher = () => {\n            watcher === null || watcher === void 0 ? void 0 : watcher.destroy();\n            watcher = new win.CloseWatcher();\n            /**\n             * Once a close request happens\n             * the watcher gets destroyed.\n             * As a result, we need to re-configure\n             * the watcher so we can respond to other\n             * close requests.\n             */\n            watcher.onclose = () => {\n                backButtonCallback();\n                configureWatcher();\n            };\n        };\n        configureWatcher();\n    }\n    else {\n        doc.addEventListener('backbutton', backButtonCallback);\n    }\n};\nexport const OVERLAY_BACK_BUTTON_PRIORITY = 100;\nexport const MENU_BACK_BUTTON_PRIORITY = 99; // 1 less than overlay priority since menu is displayed behind overlays\n","/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { focusVisibleElement } from \"./helpers\";\n/**\n * This query string selects elements that\n * are eligible to receive focus. We select\n * interactive elements that meet the following\n * criteria:\n * 1. Element does not have a negative tabindex\n * 2. Element does not have `hidden`\n * 3. Element does not have `disabled` for non-Ionic components.\n * 4. Element does not have `disabled` or `disabled=\"true\"` for Ionic components.\n * Note: We need this distinction because `disabled=\"false\"` is\n * valid usage for the disabled property on ion-button.\n */\nexport const focusableQueryString = '[tabindex]:not([tabindex^=\"-\"]):not([hidden]):not([disabled]), input:not([type=hidden]):not([tabindex^=\"-\"]):not([hidden]):not([disabled]), textarea:not([tabindex^=\"-\"]):not([hidden]):not([disabled]), button:not([tabindex^=\"-\"]):not([hidden]):not([disabled]), select:not([tabindex^=\"-\"]):not([hidden]):not([disabled]), .ion-focusable:not([tabindex^=\"-\"]):not([hidden]):not([disabled]), .ion-focusable[disabled=\"false\"]:not([tabindex^=\"-\"]):not([hidden])';\n/**\n * Focuses the first descendant in a context\n * that can receive focus. If none exists,\n * a fallback element will be focused.\n * This fallback is typically an ancestor\n * container such as a menu or overlay so focus does not\n * leave the container we are trying to trap focus in.\n *\n * If no fallback is specified then we focus the container itself.\n */\nexport const focusFirstDescendant = (ref, fallbackElement) => {\n    const firstInput = ref.querySelector(focusableQueryString);\n    focusElementInContext(firstInput, fallbackElement !== null && fallbackElement !== void 0 ? fallbackElement : ref);\n};\n/**\n * Focuses the last descendant in a context\n * that can receive focus. If none exists,\n * a fallback element will be focused.\n * This fallback is typically an ancestor\n * container such as a menu or overlay so focus does not\n * leave the container we are trying to trap focus in.\n *\n * If no fallback is specified then we focus the container itself.\n */\nexport const focusLastDescendant = (ref, fallbackElement) => {\n    const inputs = Array.from(ref.querySelectorAll(focusableQueryString));\n    const lastInput = inputs.length > 0 ? inputs[inputs.length - 1] : null;\n    focusElementInContext(lastInput, fallbackElement !== null && fallbackElement !== void 0 ? fallbackElement : ref);\n};\n/**\n * Focuses a particular element in a context. If the element\n * doesn't have anything focusable associated with it then\n * a fallback element will be focused.\n *\n * This fallback is typically an ancestor\n * container such as a menu or overlay so focus does not\n * leave the container we are trying to trap focus in.\n * This should be used instead of the focus() method\n * on most elements because the focusable element\n * may not be the host element.\n *\n * For example, if an ion-button should be focused\n * then we should actually focus the native <button>\n * element inside of ion-button's shadow root, not\n * the host element itself.\n */\nconst focusElementInContext = (hostToFocus, fallbackElement) => {\n    let elementToFocus = hostToFocus;\n    const shadowRoot = hostToFocus === null || hostToFocus === void 0 ? void 0 : hostToFocus.shadowRoot;\n    if (shadowRoot) {\n        // If there are no inner focusable elements, just focus the host element.\n        elementToFocus = shadowRoot.querySelector(focusableQueryString) || hostToFocus;\n    }\n    if (elementToFocus) {\n        focusVisibleElement(elementToFocus);\n    }\n    else {\n        // Focus fallback element instead of letting focus escape\n        fallbackElement.focus();\n    }\n};\n","/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { doc } from \"./browser/index\";\nimport { focusFirstDescendant, focusLastDescendant, focusableQueryString } from \"./focus-trap\";\nimport { shouldUseCloseWatcher } from \"./hardware-back-button\";\nimport { config } from \"../global/config\";\nimport { getIonMode } from \"../global/ionic-global\";\nimport { CoreDelegate } from \"./framework-delegate\";\nimport { BACKDROP_NO_SCROLL } from \"./gesture/gesture-controller\";\nimport { OVERLAY_BACK_BUTTON_PRIORITY } from \"./hardware-back-button\";\nimport { addEventListener, componentOnReady, focusVisibleElement, getElementRoot, removeEventListener, } from \"./helpers\";\nimport { printIonWarning } from \"./logging\";\nlet lastOverlayIndex = 0;\nlet lastId = 0;\nexport const activeAnimations = new WeakMap();\nconst createController = (tagName) => {\n    return {\n        create(options) {\n            return createOverlay(tagName, options);\n        },\n        dismiss(data, role, id) {\n            return dismissOverlay(document, data, role, tagName, id);\n        },\n        async getTop() {\n            return getPresentedOverlay(document, tagName);\n        },\n    };\n};\nexport const alertController = /*@__PURE__*/ createController('ion-alert');\nexport const actionSheetController = /*@__PURE__*/ createController('ion-action-sheet');\nexport const loadingController = /*@__PURE__*/ createController('ion-loading');\nexport const modalController = /*@__PURE__*/ createController('ion-modal');\n/**\n * @deprecated Use the inline ion-picker component instead.\n */\nexport const pickerController = /*@__PURE__*/ createController('ion-picker-legacy');\nexport const popoverController = /*@__PURE__*/ createController('ion-popover');\nexport const toastController = /*@__PURE__*/ createController('ion-toast');\n/**\n * Prepares the overlay element to be presented.\n */\nexport const prepareOverlay = (el) => {\n    if (typeof document !== 'undefined') {\n        /**\n         * Adds a single instance of event listeners for application behaviors:\n         *\n         * - Escape Key behavior to dismiss an overlay\n         * - Trapping focus within an overlay\n         * - Back button behavior to dismiss an overlay\n         *\n         * This only occurs when the first overlay is created.\n         */\n        connectListeners(document);\n    }\n    const overlayIndex = lastOverlayIndex++;\n    /**\n     * overlayIndex is used in the overlay components to set a zIndex.\n     * This ensures that the most recently presented overlay will be\n     * on top.\n     */\n    el.overlayIndex = overlayIndex;\n};\n/**\n * Assigns an incrementing id to an overlay element, that does not\n * already have an id assigned to it.\n *\n * Used to track unique instances of an overlay element.\n */\nexport const setOverlayId = (el) => {\n    if (!el.hasAttribute('id')) {\n        el.id = `ion-overlay-${++lastId}`;\n    }\n    return el.id;\n};\nexport const createOverlay = (tagName, opts) => {\n    // eslint-disable-next-line @typescript-eslint/prefer-optional-chain\n    if (typeof window !== 'undefined' && typeof window.customElements !== 'undefined') {\n        return window.customElements.whenDefined(tagName).then(() => {\n            const element = document.createElement(tagName);\n            element.classList.add('overlay-hidden');\n            /**\n             * Convert the passed in overlay options into props\n             * that get passed down into the new overlay.\n             */\n            Object.assign(element, Object.assign(Object.assign({}, opts), { hasController: true }));\n            // append the overlay element to the document body\n            getAppRoot(document).appendChild(element);\n            return new Promise((resolve) => componentOnReady(element, resolve));\n        });\n    }\n    return Promise.resolve();\n};\nconst isOverlayHidden = (overlay) => overlay.classList.contains('overlay-hidden');\n/**\n * Focuses a particular element in an overlay. If the element\n * doesn't have anything focusable associated with it then\n * the overlay itself will be focused.\n * This should be used instead of the focus() method\n * on most elements because the focusable element\n * may not be the host element.\n *\n * For example, if an ion-button should be focused\n * then we should actually focus the native <button>\n * element inside of ion-button's shadow root, not\n * the host element itself.\n */\nconst focusElementInOverlay = (hostToFocus, overlay) => {\n    let elementToFocus = hostToFocus;\n    const shadowRoot = hostToFocus === null || hostToFocus === void 0 ? void 0 : hostToFocus.shadowRoot;\n    if (shadowRoot) {\n        // If there are no inner focusable elements, just focus the host element.\n        elementToFocus = shadowRoot.querySelector(focusableQueryString) || hostToFocus;\n    }\n    if (elementToFocus) {\n        focusVisibleElement(elementToFocus);\n    }\n    else {\n        // Focus overlay instead of letting focus escape\n        overlay.focus();\n    }\n};\n/**\n * Traps keyboard focus inside of overlay components.\n * Based on https://w3c.github.io/aria-practices/examples/dialog-modal/alertdialog.html\n * This includes the following components: Action Sheet, Alert, Loading, Modal,\n * Picker, and Popover.\n * Should NOT include: Toast\n */\nconst trapKeyboardFocus = (ev, doc) => {\n    const lastOverlay = getPresentedOverlay(doc, 'ion-alert,ion-action-sheet,ion-loading,ion-modal,ion-picker-legacy,ion-popover');\n    const target = ev.target;\n    /**\n     * If no active overlay, ignore this event.\n     *\n     * If this component uses the shadow dom,\n     * this global listener is pointless\n     * since it will not catch the focus\n     * traps as they are inside the shadow root.\n     * We need to add a listener to the shadow root\n     * itself to ensure the focus trap works.\n     */\n    if (!lastOverlay || !target) {\n        return;\n    }\n    /**\n     * If the ion-disable-focus-trap class\n     * is present on an overlay, then this component\n     * instance has opted out of focus trapping.\n     * An example of this is when the sheet modal\n     * has a backdrop that is disabled. The content\n     * behind the sheet should be focusable until\n     * the backdrop is enabled.\n     */\n    if (lastOverlay.classList.contains(FOCUS_TRAP_DISABLE_CLASS)) {\n        return;\n    }\n    const trapScopedFocus = () => {\n        /**\n         * If we are focusing the overlay, clear\n         * the last focused element so that hitting\n         * tab activates the first focusable element\n         * in the overlay wrapper.\n         */\n        if (lastOverlay === target) {\n            lastOverlay.lastFocus = undefined;\n            /**\n             * Toasts can be presented from an overlay.\n             * However, focus should still be returned to\n             * the overlay when clicking a toast. Normally,\n             * focus would be returned to the last focusable\n             * descendant in the overlay which may not always be\n             * the button that the toast was presented from. In this case,\n             * the focus may be returned to an unexpected element.\n             * To account for this, we make sure to return focus to the\n             * last focused element in the overlay if focus is\n             * moved to the toast.\n             */\n        }\n        else if (target.tagName === 'ION-TOAST') {\n            focusElementInOverlay(lastOverlay.lastFocus, lastOverlay);\n            /**\n             * Otherwise, we must be focusing an element\n             * inside of the overlay. The two possible options\n             * here are an input/button/etc or the ion-focus-trap\n             * element. The focus trap element is used to prevent\n             * the keyboard focus from leaving the overlay when\n             * using Tab or screen assistants.\n             */\n        }\n        else {\n            /**\n             * We do not want to focus the traps, so get the overlay\n             * wrapper element as the traps live outside of the wrapper.\n             */\n            const overlayRoot = getElementRoot(lastOverlay);\n            if (!overlayRoot.contains(target)) {\n                return;\n            }\n            const overlayWrapper = overlayRoot.querySelector('.ion-overlay-wrapper');\n            if (!overlayWrapper) {\n                return;\n            }\n            /**\n             * If the target is inside the wrapper, let the browser\n             * focus as normal and keep a log of the last focused element.\n             * Additionally, if the backdrop was tapped we should not\n             * move focus back inside the wrapper as that could cause\n             * an interactive elements focus state to activate.\n             */\n            if (overlayWrapper.contains(target) || target === overlayRoot.querySelector('ion-backdrop')) {\n                lastOverlay.lastFocus = target;\n            }\n            else {\n                /**\n                 * Otherwise, we must have focused one of the focus traps.\n                 * We need to wrap the focus to either the first element\n                 * or the last element.\n                 */\n                /**\n                 * Once we call `focusFirstDescendant` and focus the first\n                 * descendant, another focus event will fire which will\n                 * cause `lastOverlay.lastFocus` to be updated before\n                 * we can run the code after that. We will cache the value\n                 * here to avoid that.\n                 */\n                const lastFocus = lastOverlay.lastFocus;\n                // Focus the first element in the overlay wrapper\n                focusFirstDescendant(overlayWrapper, lastOverlay);\n                /**\n                 * If the cached last focused element is the\n                 * same as the active element, then we need\n                 * to wrap focus to the last descendant. This happens\n                 * when the first descendant is focused, and the user\n                 * presses Shift + Tab. The previous line will focus\n                 * the same descendant again (the first one), causing\n                 * last focus to equal the active element.\n                 */\n                if (lastFocus === doc.activeElement) {\n                    focusLastDescendant(overlayWrapper, lastOverlay);\n                }\n                lastOverlay.lastFocus = doc.activeElement;\n            }\n        }\n    };\n    const trapShadowFocus = () => {\n        /**\n         * If the target is inside the wrapper, let the browser\n         * focus as normal and keep a log of the last focused element.\n         */\n        if (lastOverlay.contains(target)) {\n            lastOverlay.lastFocus = target;\n            /**\n             * Toasts can be presented from an overlay.\n             * However, focus should still be returned to\n             * the overlay when clicking a toast. Normally,\n             * focus would be returned to the last focusable\n             * descendant in the overlay which may not always be\n             * the button that the toast was presented from. In this case,\n             * the focus may be returned to an unexpected element.\n             * To account for this, we make sure to return focus to the\n             * last focused element in the overlay if focus is\n             * moved to the toast.\n             */\n        }\n        else if (target.tagName === 'ION-TOAST') {\n            focusElementInOverlay(lastOverlay.lastFocus, lastOverlay);\n        }\n        else {\n            /**\n             * Otherwise, we are about to have focus\n             * go out of the overlay. We need to wrap\n             * the focus to either the first element\n             * or the last element.\n             */\n            /**\n             * Once we call `focusFirstDescendant` and focus the first\n             * descendant, another focus event will fire which will\n             * cause `lastOverlay.lastFocus` to be updated before\n             * we can run the code after that. We will cache the value\n             * here to avoid that.\n             */\n            const lastFocus = lastOverlay.lastFocus;\n            // Focus the first element in the overlay wrapper\n            focusFirstDescendant(lastOverlay);\n            /**\n             * If the cached last focused element is the\n             * same as the active element, then we need\n             * to wrap focus to the last descendant. This happens\n             * when the first descendant is focused, and the user\n             * presses Shift + Tab. The previous line will focus\n             * the same descendant again (the first one), causing\n             * last focus to equal the active element.\n             */\n            if (lastFocus === doc.activeElement) {\n                focusLastDescendant(lastOverlay);\n            }\n            lastOverlay.lastFocus = doc.activeElement;\n        }\n    };\n    if (lastOverlay.shadowRoot) {\n        trapShadowFocus();\n    }\n    else {\n        trapScopedFocus();\n    }\n};\nconst connectListeners = (doc) => {\n    if (lastOverlayIndex === 0) {\n        lastOverlayIndex = 1;\n        doc.addEventListener('focus', (ev) => {\n            trapKeyboardFocus(ev, doc);\n        }, true);\n        // handle back-button click\n        doc.addEventListener('ionBackButton', (ev) => {\n            const lastOverlay = getPresentedOverlay(doc);\n            if (lastOverlay === null || lastOverlay === void 0 ? void 0 : lastOverlay.backdropDismiss) {\n                ev.detail.register(OVERLAY_BACK_BUTTON_PRIORITY, () => {\n                    /**\n                     * Do not return this promise otherwise\n                     * the hardware back button utility will\n                     * be blocked until the overlay dismisses.\n                     * This is important for a modal with canDismiss.\n                     * If the application presents a confirmation alert\n                     * in the \"canDismiss\" callback, then it will be impossible\n                     * to use the hardware back button to dismiss the alert\n                     * dialog because the hardware back button utility\n                     * is blocked on waiting for the modal to dismiss.\n                     */\n                    lastOverlay.dismiss(undefined, BACKDROP);\n                });\n            }\n        });\n        /**\n         * Handle ESC to close overlay.\n         * CloseWatcher also handles pressing the Esc\n         * key, so if a browser supports CloseWatcher then\n         * this behavior will be handled via the ionBackButton\n         * event.\n         */\n        if (!shouldUseCloseWatcher()) {\n            doc.addEventListener('keydown', (ev) => {\n                if (ev.key === 'Escape') {\n                    const lastOverlay = getPresentedOverlay(doc);\n                    if (lastOverlay === null || lastOverlay === void 0 ? void 0 : lastOverlay.backdropDismiss) {\n                        lastOverlay.dismiss(undefined, BACKDROP);\n                    }\n                }\n            });\n        }\n    }\n};\nexport const dismissOverlay = (doc, data, role, overlayTag, id) => {\n    const overlay = getPresentedOverlay(doc, overlayTag, id);\n    if (!overlay) {\n        return Promise.reject('overlay does not exist');\n    }\n    return overlay.dismiss(data, role);\n};\n/**\n * Returns a list of all overlays in the DOM even if they are not presented.\n */\nexport const getOverlays = (doc, selector) => {\n    if (selector === undefined) {\n        selector = 'ion-alert,ion-action-sheet,ion-loading,ion-modal,ion-picker-legacy,ion-popover,ion-toast';\n    }\n    return Array.from(doc.querySelectorAll(selector)).filter((c) => c.overlayIndex > 0);\n};\n/**\n * Returns a list of all presented overlays.\n * Inline overlays can exist in the DOM but not be presented,\n * so there are times when we want to exclude those.\n * @param doc The document to find the element within.\n * @param overlayTag The selector for the overlay, defaults to Ionic overlay components.\n */\nconst getPresentedOverlays = (doc, overlayTag) => {\n    return getOverlays(doc, overlayTag).filter((o) => !isOverlayHidden(o));\n};\n/**\n * Returns a presented overlay element.\n * @param doc The document to find the element within.\n * @param overlayTag The selector for the overlay, defaults to Ionic overlay components.\n * @param id The unique identifier for the overlay instance.\n * @returns The overlay element or `undefined` if no overlay element is found.\n */\nexport const getPresentedOverlay = (doc, overlayTag, id) => {\n    const overlays = getPresentedOverlays(doc, overlayTag);\n    return id === undefined ? overlays[overlays.length - 1] : overlays.find((o) => o.id === id);\n};\n/**\n * When an overlay is presented, the main\n * focus is the overlay not the page content.\n * We need to remove the page content from the\n * accessibility tree otherwise when\n * users use \"read screen from top\" gestures with\n * TalkBack and VoiceOver, the screen reader will begin\n * to read the content underneath the overlay.\n *\n * We need a container where all page components\n * exist that is separate from where the overlays\n * are added in the DOM. For most apps, this element\n * is the top most ion-router-outlet. In the event\n * that devs are not using a router,\n * they will need to add the \"ion-view-container-root\"\n * id to the element that contains all of their views.\n *\n * TODO: If Framework supports having multiple top\n * level router outlets we would need to update this.\n * Example: One outlet for side menu and one outlet\n * for main content.\n */\nexport const setRootAriaHidden = (hidden = false) => {\n    const root = getAppRoot(document);\n    const viewContainer = root.querySelector('ion-router-outlet, ion-nav, #ion-view-container-root');\n    if (!viewContainer) {\n        return;\n    }\n    if (hidden) {\n        viewContainer.setAttribute('aria-hidden', 'true');\n    }\n    else {\n        viewContainer.removeAttribute('aria-hidden');\n    }\n};\nexport const present = async (overlay, name, iosEnterAnimation, mdEnterAnimation, opts) => {\n    var _a, _b;\n    if (overlay.presented) {\n        return;\n    }\n    setRootAriaHidden(true);\n    document.body.classList.add(BACKDROP_NO_SCROLL);\n    hideOverlaysFromScreenReaders(overlay.el);\n    overlay.presented = true;\n    overlay.willPresent.emit();\n    (_a = overlay.willPresentShorthand) === null || _a === void 0 ? void 0 : _a.emit();\n    const mode = getIonMode(overlay);\n    // get the user's animation fn if one was provided\n    const animationBuilder = overlay.enterAnimation\n        ? overlay.enterAnimation\n        : config.get(name, mode === 'ios' ? iosEnterAnimation : mdEnterAnimation);\n    const completed = await overlayAnimation(overlay, animationBuilder, overlay.el, opts);\n    if (completed) {\n        overlay.didPresent.emit();\n        (_b = overlay.didPresentShorthand) === null || _b === void 0 ? void 0 : _b.emit();\n    }\n    /**\n     * When an overlay that steals focus\n     * is dismissed, focus should be returned\n     * to the element that was focused\n     * prior to the overlay opening. Toast\n     * does not steal focus and is excluded\n     * from returning focus as a result.\n     */\n    if (overlay.el.tagName !== 'ION-TOAST') {\n        restoreElementFocus(overlay.el);\n    }\n    /**\n     * If the focused element is already\n     * inside the overlay component then\n     * focus should not be moved from that\n     * to the overlay container.\n     */\n    if (overlay.keyboardClose && (document.activeElement === null || !overlay.el.contains(document.activeElement))) {\n        overlay.el.focus();\n    }\n    /**\n     * If this overlay was previously dismissed without being\n     * the topmost one (such as by manually calling dismiss()),\n     * it would still have aria-hidden on being presented again.\n     * Removing it here ensures the overlay is visible to screen\n     * readers.\n     */\n    overlay.el.removeAttribute('aria-hidden');\n};\n/**\n * When an overlay component is dismissed,\n * focus should be returned to the element\n * that presented the overlay. Otherwise\n * focus will be set on the body which\n * means that people using screen readers\n * or tabbing will need to re-navigate\n * to where they were before they\n * opened the overlay.\n */\nconst restoreElementFocus = async (overlayEl) => {\n    let previousElement = document.activeElement;\n    if (!previousElement) {\n        return;\n    }\n    const shadowRoot = previousElement === null || previousElement === void 0 ? void 0 : previousElement.shadowRoot;\n    if (shadowRoot) {\n        // If there are no inner focusable elements, just focus the host element.\n        previousElement = shadowRoot.querySelector(focusableQueryString) || previousElement;\n    }\n    await overlayEl.onDidDismiss();\n    /**\n     * After onDidDismiss, the overlay loses focus\n     * because it is removed from the document\n     *\n     * > An element will also lose focus [...]\n     * > if the element is removed from the document)\n     *\n     * https://developer.mozilla.org/en-US/docs/Web/API/Element/blur_event\n     *\n     * Additionally, `document.activeElement` returns:\n     *\n     * > The Element which currently has focus,\n     * > `<body>` or null if there is\n     * > no focused element.\n     *\n     * https://developer.mozilla.org/en-US/docs/Web/API/Document/activeElement#value\n     *\n     * However, if the user has already focused\n     * an element sometime between onWillDismiss\n     * and onDidDismiss (for example, focusing a\n     * text box after tapping a button in an\n     * action sheet) then don't restore focus to\n     * previous element\n     */\n    if (document.activeElement === null || document.activeElement === document.body) {\n        previousElement.focus();\n    }\n};\nexport const dismiss = async (overlay, data, role, name, iosLeaveAnimation, mdLeaveAnimation, opts) => {\n    var _a, _b;\n    if (!overlay.presented) {\n        return false;\n    }\n    const lastOverlay = doc !== undefined && getPresentedOverlays(doc).length === 1;\n    /**\n     * If this is the last visible overlay then\n     * we want to re-add the root to the accessibility tree.\n     */\n    if (lastOverlay) {\n        setRootAriaHidden(false);\n        document.body.classList.remove(BACKDROP_NO_SCROLL);\n    }\n    overlay.presented = false;\n    try {\n        // Overlay contents should not be clickable during dismiss\n        overlay.el.style.setProperty('pointer-events', 'none');\n        overlay.willDismiss.emit({ data, role });\n        (_a = overlay.willDismissShorthand) === null || _a === void 0 ? void 0 : _a.emit({ data, role });\n        const mode = getIonMode(overlay);\n        const animationBuilder = overlay.leaveAnimation\n            ? overlay.leaveAnimation\n            : config.get(name, mode === 'ios' ? iosLeaveAnimation : mdLeaveAnimation);\n        // If dismissed via gesture, no need to play leaving animation again\n        if (role !== GESTURE) {\n            await overlayAnimation(overlay, animationBuilder, overlay.el, opts);\n        }\n        overlay.didDismiss.emit({ data, role });\n        (_b = overlay.didDismissShorthand) === null || _b === void 0 ? void 0 : _b.emit({ data, role });\n        // Get a reference to all animations currently assigned to this overlay\n        // Then tear them down to return the overlay to its initial visual state\n        const animations = activeAnimations.get(overlay) || [];\n        animations.forEach((ani) => ani.destroy());\n        activeAnimations.delete(overlay);\n        /**\n         * Make overlay hidden again in case it is being reused.\n         * We can safely remove pointer-events: none as\n         * overlay-hidden will set display: none.\n         */\n        overlay.el.classList.add('overlay-hidden');\n        overlay.el.style.removeProperty('pointer-events');\n        /**\n         * Clear any focus trapping references\n         * when the overlay is dismissed.\n         */\n        if (overlay.el.lastFocus !== undefined) {\n            overlay.el.lastFocus = undefined;\n        }\n    }\n    catch (err) {\n        console.error(err);\n    }\n    overlay.el.remove();\n    revealOverlaysToScreenReaders();\n    return true;\n};\nconst getAppRoot = (doc) => {\n    return doc.querySelector('ion-app') || doc.body;\n};\nconst overlayAnimation = async (overlay, animationBuilder, baseEl, opts) => {\n    // Make overlay visible in case it's hidden\n    baseEl.classList.remove('overlay-hidden');\n    const aniRoot = overlay.el;\n    const animation = animationBuilder(aniRoot, opts);\n    if (!overlay.animated || !config.getBoolean('animated', true)) {\n        animation.duration(0);\n    }\n    if (overlay.keyboardClose) {\n        animation.beforeAddWrite(() => {\n            const activeElement = baseEl.ownerDocument.activeElement;\n            if (activeElement === null || activeElement === void 0 ? void 0 : activeElement.matches('input,ion-input, ion-textarea')) {\n                activeElement.blur();\n            }\n        });\n    }\n    const activeAni = activeAnimations.get(overlay) || [];\n    activeAnimations.set(overlay, [...activeAni, animation]);\n    await animation.play();\n    return true;\n};\nexport const eventMethod = (element, eventName) => {\n    let resolve;\n    const promise = new Promise((r) => (resolve = r));\n    onceEvent(element, eventName, (event) => {\n        resolve(event.detail);\n    });\n    return promise;\n};\nexport const onceEvent = (element, eventName, callback) => {\n    const handler = (ev) => {\n        removeEventListener(element, eventName, handler);\n        callback(ev);\n    };\n    addEventListener(element, eventName, handler);\n};\nexport const isCancel = (role) => {\n    return role === 'cancel' || role === BACKDROP;\n};\nconst defaultGate = (h) => h();\n/**\n * Calls a developer provided method while avoiding\n * Angular Zones. Since the handler is provided by\n * the developer, we should throw any errors\n * received so that developer-provided bug\n * tracking software can log it.\n */\nexport const safeCall = (handler, arg) => {\n    if (typeof handler === 'function') {\n        const jmp = config.get('_zoneGate', defaultGate);\n        return jmp(() => {\n            try {\n                return handler(arg);\n            }\n            catch (e) {\n                throw e;\n            }\n        });\n    }\n    return undefined;\n};\nexport const BACKDROP = 'backdrop';\nexport const GESTURE = 'gesture';\nexport const OVERLAY_GESTURE_PRIORITY = 39;\n/**\n * Creates a delegate controller.\n *\n * Requires that the component has the following properties:\n * - `el: HTMLElement`\n * - `hasController: boolean`\n * - `delegate?: FrameworkDelegate`\n *\n * @param ref The component class instance.\n */\nexport const createDelegateController = (ref) => {\n    let inline = false;\n    let workingDelegate;\n    const coreDelegate = CoreDelegate();\n    /**\n     * Determines whether or not an overlay is being used\n     * inline or via a controller/JS and returns the correct delegate.\n     * By default, subsequent calls to getDelegate will use\n     * a cached version of the delegate.\n     * This is useful for calling dismiss after present,\n     * so that the correct delegate is given.\n     * @param force `true` to force the non-cached version of the delegate.\n     * @returns The delegate to use and whether or not the overlay is inline.\n     */\n    const getDelegate = (force = false) => {\n        if (workingDelegate && !force) {\n            return {\n                delegate: workingDelegate,\n                inline,\n            };\n        }\n        const { el, hasController, delegate } = ref;\n        /**\n         * If using overlay inline\n         * we potentially need to use the coreDelegate\n         * so that this works in vanilla JS apps.\n         * If a developer has presented this component\n         * via a controller, then we can assume\n         * the component is already in the\n         * correct place.\n         */\n        const parentEl = el.parentNode;\n        inline = parentEl !== null && !hasController;\n        workingDelegate = inline ? delegate || coreDelegate : delegate;\n        return { inline, delegate: workingDelegate };\n    };\n    /**\n     * Attaches a component in the DOM. Teleports the component\n     * to the root of the app.\n     * @param component The component to optionally construct and append to the element.\n     */\n    const attachViewToDom = async (component) => {\n        const { delegate } = getDelegate(true);\n        if (delegate) {\n            return await delegate.attachViewToDom(ref.el, component);\n        }\n        const { hasController } = ref;\n        if (hasController && component !== undefined) {\n            throw new Error('framework delegate is missing');\n        }\n        return null;\n    };\n    /**\n     * Moves a component back to its original location in the DOM.\n     */\n    const removeViewFromDom = () => {\n        const { delegate } = getDelegate();\n        if (delegate && ref.el !== undefined) {\n            delegate.removeViewFromDom(ref.el.parentElement, ref.el);\n        }\n    };\n    return {\n        attachViewToDom,\n        removeViewFromDom,\n    };\n};\n/**\n * Constructs a trigger interaction for an overlay.\n * Presents an overlay when the trigger is clicked.\n *\n * Usage:\n * ```ts\n * triggerController = createTriggerController();\n * triggerController.addClickListener(el, trigger);\n * ```\n */\nexport const createTriggerController = () => {\n    let destroyTriggerInteraction;\n    /**\n     * Removes the click listener from the trigger element.\n     */\n    const removeClickListener = () => {\n        if (destroyTriggerInteraction) {\n            destroyTriggerInteraction();\n            destroyTriggerInteraction = undefined;\n        }\n    };\n    /**\n     * Adds a click listener to the trigger element.\n     * Presents the overlay when the trigger is clicked.\n     * @param el The overlay element.\n     * @param trigger The ID of the element to add a click listener to.\n     */\n    const addClickListener = (el, trigger) => {\n        removeClickListener();\n        const triggerEl = trigger !== undefined ? document.getElementById(trigger) : null;\n        if (!triggerEl) {\n            printIonWarning(`A trigger element with the ID \"${trigger}\" was not found in the DOM. The trigger element must be in the DOM when the \"trigger\" property is set on an overlay component.`, el);\n            return;\n        }\n        const configureTriggerInteraction = (targetEl, overlayEl) => {\n            const openOverlay = () => {\n                overlayEl.present();\n            };\n            targetEl.addEventListener('click', openOverlay);\n            return () => {\n                targetEl.removeEventListener('click', openOverlay);\n            };\n        };\n        destroyTriggerInteraction = configureTriggerInteraction(triggerEl, el);\n    };\n    return {\n        addClickListener,\n        removeClickListener,\n    };\n};\n/**\n * Ensure that underlying overlays have aria-hidden if necessary so that screen readers\n * cannot move focus to these elements. Note that we cannot rely on focus/focusin/focusout\n * events here because those events do not fire when the screen readers moves to a non-focusable\n * element such as text.\n * Without this logic screen readers would be able to move focus outside of the top focus-trapped overlay.\n *\n * @param newTopMostOverlay - The overlay that is being presented. Since the overlay has not been\n * fully presented yet at the time this function is called it will not be included in the getPresentedOverlays result.\n */\nconst hideOverlaysFromScreenReaders = (newTopMostOverlay) => {\n    var _a;\n    if (doc === undefined)\n        return;\n    const overlays = getPresentedOverlays(doc);\n    for (let i = overlays.length - 1; i >= 0; i--) {\n        const presentedOverlay = overlays[i];\n        const nextPresentedOverlay = (_a = overlays[i + 1]) !== null && _a !== void 0 ? _a : newTopMostOverlay;\n        /**\n         * If next overlay has aria-hidden then all remaining overlays will have it too.\n         * Or, if the next overlay is a Toast that does not have aria-hidden then current overlay\n         * should not have aria-hidden either so focus can remain in the current overlay.\n         */\n        if (nextPresentedOverlay.hasAttribute('aria-hidden') || nextPresentedOverlay.tagName !== 'ION-TOAST') {\n            presentedOverlay.setAttribute('aria-hidden', 'true');\n        }\n    }\n};\n/**\n * When dismissing an overlay we need to reveal the new top-most overlay to screen readers.\n * If the top-most overlay is a Toast we potentially need to reveal more overlays since\n * focus is never automatically moved to the Toast.\n */\nconst revealOverlaysToScreenReaders = () => {\n    if (doc === undefined)\n        return;\n    const overlays = getPresentedOverlays(doc);\n    for (let i = overlays.length - 1; i >= 0; i--) {\n        const currentOverlay = overlays[i];\n        /**\n         * If the current we are looking at is a Toast then we can remove aria-hidden.\n         * However, we potentially need to keep looking at the overlay stack because there\n         * could be more Toasts underneath. Additionally, we need to unhide the closest non-Toast\n         * overlay too so focus can move there since focus is never automatically moved to the Toast.\n         */\n        currentOverlay.removeAttribute('aria-hidden');\n        /**\n         * If we found a non-Toast element then we can just remove aria-hidden and stop searching entirely\n         * since this overlay should always receive focus. As a result, all underlying overlays should still\n         * be hidden from screen readers.\n         */\n        if (currentOverlay.tagName !== 'ION-TOAST') {\n            break;\n        }\n    }\n};\nexport const FOCUS_TRAP_DISABLE_CLASS = 'ion-disable-focus-trap';\n"],"mappings":"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","ignoreList":[]}